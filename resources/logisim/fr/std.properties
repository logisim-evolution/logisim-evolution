#
# Namechack
#
MatchedLabelNameError = L'\u00e9tiquette et le nom composant ne peuvent pas \u00eatre les m\u00eames (ils ne sont pas sensibles \u00e0 la casse). Veuillez sp\u00e9cifier une \u00e9tiquette diff\u00e9rente du nom du composant.
KeywordNameError = Label est un mot cl\u00e9 r\u00e9serv\u00e9 et ne peut pas \u00eatre utilis\u00e9. Veuillez sp\u00e9cifier une \u00e9tiquette diff\u00e9rente.
#
# std/Builtin.java
#
builtinLibrary = inclue
# instance/StdAttr.java
stdFacingAttr = Orientation
stdDataWidthAttr = Largeur données
stdTriggerAttr = Trigger
stdTriggerRising = Flanc Montant
stdTriggerFalling = Flanc descendant
stdTriggerHigh = Niveau haut
stdTriggerLow = Niveau bas
stdLabelAttr = Label
stdLabelFontAttr = Police du Label
# instance/InstanceTextField.java
changeLabelAction = Changer le Label
#
# std/base/Base.java
#
baseLibrary = Base

# std/base/BitExtender.java
extenderComponent = Extension de bit
<<<<<<< HEAD
extenderInAttr = Largeur de bit en entr\u00e9e
extenderOutAttr = Largeur de bit en sortie
=======
extenderInAttr = Largeur bus entrée
extenderOutAttr = Largeur bus sortie
>>>>>>> mbaillif-master
extenderTypeAttr = Type d'Extension
extenderOneType = Un
extenderZeroType = Z\u00e9ro
extenderSignType = Signe
extenderInputType = Entr\u00e9e
extenderMainLabel = \u00e9tendre
extenderOneLabel = 1
extenderZeroLabel = 0
extenderSignLabel = sign\u00e9
extenderInputLabel = entr\u00e9e

# std/base/Clock
clockComponent = Horloge
clockHighAttr = Dur\u00e9e haute
clockLowAttr = Dur\u00e9e basse
clockDurationValue = %s Tics
clockDurationOneValue = 1 Tic
porHighAttr = Temps reset
durationSmallMessage = La valeur doit \u00eatre au moins %s.
durationLargeMessage = La valeur doit \u00eatre %s ou moins.
freqInvalidMessage = La valeur n'est pas un entier valide
PowerOnResetComponent = POR
# std/base/Pin
pinComponent = Pin
pinInputName = Entr\u00e9e
pinOutputName = Sortie
pinThreeStateAttr = Trois \u00e9tats?
pinOutputAttr = Sortie?
pinPullAttr = Comportement Pull
pinPullNoneOption = Inchang\u00e9
pinPullUpOption = Pull Up
pinPullDownOption = Pull Down
pinLabelLocAttr = Position du label
pinInputToolTip = Ajouter un pin d'entr\u00e9e
pinOutputToolTip = Ajouter un pin de sortie
pinFrozenTitle = Pin attach\u00e9 au super-circuit.
pinFrozenQuestion = Le pin est li\u00e9 \u00e0 l'\u00e9tat du supercircuit. Cr\u00e9er un nouvel \u00e9tat pour le circuit?

# std/base/Probe
probeComponent = Sonde

# std/base/PullResistor
pullComponent = R\u00e9sistance de charge
pullTypeAttr = DIrection charge
pullZeroType = Z\u00e9ro
pullOneType = Un
pullErrorType = Erreur

# std/base/Text.java
textComponent = Label
textTextAttr = Texte
textFontAttr = Police
textHorzAlignAttr = Alignement horizontal
textHorzAlignLeftOpt = Gauche
textHorzAlignRightOpt = Droite
textHorzAlignCenterOpt = Centr\u00e9
textVertAlignAttr = Alignment vertical
textVertAlignTopOpt = Sommet
textVertAlignBaseOpt = Base
textVertAlignBottomOpt = Fond
textVertAlignCenterOpt = Centre

# std/base/Tunnel.java
tunnelComponent = Tunnel

#
# std/Wiring.java
#
<<<<<<< HEAD
wiringLibrary = C\u00e2blage
wiringGateAttr = Position de la porte logique
=======
wiringLibrary = Câblage
wiringGateAttr = Position de la Gate
>>>>>>> mbaillif-master
wiringGateBottomRightOption = Bas/Droite
wiringGateTopLeftOption = Haut/Gauche

# std/wiring/Transistor.java
transistorComponent = Transistor
transistorTypeAttr = Type
transistorTypeP = P-Type
transistorTypeN = N-Type

# std/wiring/TransmissionGate.java
transmissionGateComponent = Porte de transmission

# std/wiring/Power.java
powerComponent = Alimentation

# std/wiring/Ground.java
groundComponent = Masse

#
# std/Gates.java
#
gatesLibrary = Portes logiques
<<<<<<< HEAD
gateSizeAttr = Taille de la porte logique
gateSizeNarrowOpt = \u00e9troit
gateSizeNormalOpt = moyen
gateSizeWideOpt = large
gateNegateAttr = Inverse %s
gateInputsAttr = Nombre d'entr\u00e9es
=======
gateSizeAttr = Dimension dessins
gateSizeNarrowOpt = étroit
gateSizeNormalOpt = moyen
gateSizeWideOpt = large
gateNegateAttr = Inverseur %s
gateInputsAttr = Nombre d'entrées
>>>>>>> mbaillif-master
gateOutput01 = 0/1
gateOutput0Z = 0/flottant
gateOutputZ1 = flottant/1
gateOutputAttr = Valeur de sortie
xorBehaviorAttr = Comportement multi-entr\u00e9es
xorBehaviorOne = Quand une entr\u00e9e est Haut
xorBehaviorOdd = Quand un nombre impaire est Haut
# std/Constant.java
constantComponent = Constante
constantValueAttr = Valeur
# std/NotGate.java
notGateComponent = Porte NOT
# std/Buffer.java
bufferComponent = Buffer
# std/AndGate.java
andGateComponent = Porte AND
# std/NandGate.java
nandGateComponent = Porte NAND
# std/NorGate.java
norGateComponent = Porte NOR
# std/OrGate.java
orGateComponent = Porte OR
# std/XorGate.java
xorGateComponent = Porte XOR
# std/XnorGate.java
xnorGateComponent = Porte XNOR
# std/OddParityGate.java
oddParityComponent = Parit\u00e9 impaire
# std/EvenParityGate.java
evenParityComponent = Parit\u00e9 paire
# std/ControlledBuffer.java
<<<<<<< HEAD
controlledBufferComponent = Buffer controll\u00e9
controlledInverterComponent = Inverseur controll\u00e9
controlledControlOption = Controle de la position de la ligne
=======
controlledBufferComponent = Buffer controllé
controlledInverterComponent = Inverseur controllé
controlledControlOption = Position de la commande
>>>>>>> mbaillif-master
controlledLeftHanded = A gauche
controlledRightHanded = A droite
#
# std/Memory.java
#
memoryLibrary = M\u00e9moire / S\u00e9quenciel
memEnableLabel = en
# AbstractFlipFlop.java
flipFlopClockTip = Horloge: l'\u00e9tat impact sur le trigger
flipFlopQTip = Etat courrant du flip-flop
flipFlopNotQTip = Compl\u00e9ment \u00e0 l'\u00e9tat courrant du flip-flop
flipFlopResetTip = Clear: si 1, l'\u00e9tat du pin \u00e0 0 de mani\u00e8re asynchrone
flipFlopPresetTip = Preset: si 1, l'\u00e9tat du pin \u00e0 1 de mani\u00e8re asynchrone
flipFlopEnableTip = Enable: si 0, les trigger de l'horloge sont inop\u00e9rants
# std/Counter.java
counterComponent = Compteur
counterMaxAttr   = Valeur max
counterGoalAttr  = Action en cas de d\u00e9passement
counterGoalWrap  = Entourer
counterGoalStay  = Rester \u00e0 la valeur
counterGoalContinue = Continue le compte
counterGoalLoad  = Charger la valeur suivante
counterQTip      = Sortie: valeur courrant du compteur
counterClockTip  = Horloge: la valeur peut modifier le trigger
counterDataTip   = Data: valeur \u00e0 charger dans le compteur
counterLoadTip   = Load: si 1, charge \u00e0 partir des donn\u00e9es entr\u00e9es (if Count = 0) ou d\u00e9cr\u00e9mente
counterEnableTip = Count: si 1, le compteur s'incr\u00e9mente (ou d\u00e9cr\u00e9mente si Load = 1)
counterResetTip  = Clear: si 1, remet \u00e0 0 de mani\u00e8re asynchrone
counterCarryTip  = Carry: est \u00e0 1 si la valeur atteinte le maximum (minimum si d\u00e9cr\u00e9mente)
counterEnableLabel = ct
counterLabel = ctr
# std/DFlipFlop.java
dFlipFlopComponent = D Flip-Flop
# std/TFlipFlop.java
tFlipFlopComponent = T Flip-Flop
# std/JKFlipFlop.java
jkFlipFlopComponent = J-K Flip-Flop
# std/SRFlipFlop.java
srFlipFlopComponent = S-R Flip-Flop
# std/Random.java
randomSeedAttr = Semence
randomComponent = G\u00e9n\u00e9rateur al\u00e9atoire
randomQTip = Sortie: nombre courrant dans la s\u00e9quence
randomClockTip = Clock: la valeur peut changer avec le trigger
randomNextTip = Enable: avance au suivant dans la s\u00e9quence avec le trigger d'horloge
randomResetTip = Clear: si 1, initialise \u00e0 la semence de mani\u00e8re asynchrone
# std/Register.java
registerComponent = Registre
registerQTip = Sortie: valeur courrant du registre
registerDTip = Data: valeur stock\u00e9e dans l'horloge du trigger
registerClkTip = Clock: la valeur change avec le trigger 
registerClrTip = Clear: si 1, la valeur du pin mise \u00e0 0 de mani\u00e8re asynchrone
registerEnableTip = Enable: si 0, les trigger d'horloge sont inop\u00e9rants
registerLabel = reg
registerWidthLabel = (%sb)
registerShowInTab = Show in Registers Tab
# std/RamFactory.java
ramComponent = RAM
# std/RomFactory.java
romComponent = ROM
ramContentsAttr = Contenu Initial
romContentsAttr = Contenu
romContentsValue = (click pour \u00e9diter)
romChangeAction = Editer le contenu de la ROM
# std/Ram.java
ramAddrWidthAttr = Largeur d'adresse
<<<<<<< HEAD
ramDataWidthAttr = Largeur de donn\u00e9es
=======
ramDataWidthAttr = Largeur données
>>>>>>> mbaillif-master
ramDataAddrAttr = Byte Addressing
ramDataLabel = D
ramAddrLabel = A
ramWELabel = str
ramCSLabel = sel
ramOELabel = ld
ramClrLabel = clr
ramByteEnableTip0 = Byte enable for bits 7..0
ramByteEnableTip1 = Byte enable for bits 15..8
ramByteEnableTip2 = Byte enable for bits 23..16
ramByteEnableTip3 = Byte enable for bits 31..24
ramWithByteEnables = Use byte enables
ramNoByteEnables = Mot entier en lecture/\u00e9criture seulement
ramByteEnables = Contr\u00f4le lecture/\u00e9criture
ramGigabyteLabel = %sGB RAM
ramMegabyteLabel = %sMB RAM
ramKilobyteLabel = %sKB RAM
ramByteLabel = %sB RAM
romGigabyteLabel = %sGB ROM
romMegabyteLabel = %sMB ROM
romKilobyteLabel = %sKB ROM
romByteLabel = %sB ROM
memDataTip = Data: valeur charg\u00e9e depuis une adresse
memAddrTip = Address: emplacement acc\u00e9d\u00e9 en m\u00e9moire
memCSTip = Chip select: 0 d\u00e9sactive le composant
ramClkTip = Clock: la valeur en m\u00e9moire change sur flanc de 0 \u00e0 1
ramOETip = Load: si 1, charge la m\u00e9moire sur la sortie
ramWETip = Store: si 1, stock l'entr\u00e9e dans la m\u00e9moire
ramClrTip = Clear: when 1, remet le contenu \u00e0 0 de mani\u00e8re asynchrone
ramBusTip = Data: valeur charg\u00e9 ou stock\u00e9e \u00e0 l'adresse
ramInTip = Input: valeur \u00e0 charger \u00e0 l'adresse
ramBusAttr = Interface de donn\u00e9es
ramBusSynchCombined = Un chargement/stockage synchrone du port
ramBusAsynchCombined = Un chargement/stockage asynchrone du port
ramBusSeparate = S\u00e9pare le chargement et le stockage des ports
ramBidirDataBus = bidirectionnel
ramSeparateDataBus = monodirectionnel deux bus lire/\u00e9crire
ramDataAttr = Type de bus donn\u00e9es
ramAttrRdTick = Lire l'impl\u00e9mentation
ramAttrRdTickDefault = Lire sur le front de l'horloge s\u00e9lectionn\u00e9
ramAttrRdTickEarly = Attendre 1 sysclk avant de lire
ramEditMenuItem = Editer le contenu...
ramClearMenuItem = Effacer les contenus
ramLoadMenuItem = Charger l'image...
ramSaveMenuItem = Sauvegarder l'image...
ramConfirmClearTitle = Confirmer l'\u00e9ffacement
ramConfirmClearMsg = Etes vous s\u00fbr de vouloir remettre \u00e0 z\u00e9ro la sortie m\u00e9moire?
ramLoadDialogTitle = Charge une image RAM
ramLoadErrorTitle = Erreur de chargement
ramSaveDialogTitle = Sauvegarder une image RAM
ramSaveErrorTitle = Erreur de sauvegarde
# std/memory/ShiftRegister.java
shiftRegisterComponent = Registre \u00e0 d\u00e9calage
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Nombre d'\u00e9tages
shiftRegParallelAttr = Chargement parall\u00e8le
shiftRegShiftTip = Shift: d\u00e9calage d\u00e9sactiv\u00e9 quand 0
shiftRegClockTip = Clock: les valeurs peuvent changer avec le trigger
shiftRegClearTip = Clear: quand 1, remise \u00e0 z\u00e9ro compl\u00e8te et asynchrone
shiftRegInTip    = Input: valeur \u00e0 d\u00e9caler dans le premier \u00e9tage
shiftRegOutTip   = Output: est le contenu du dernier \u00e9tage
shiftRegLoadTip  = Load: quand 1 (avec shift = 0), tous les \u00e9tages chargent les entr\u00e9es
#
# std/Plexers.java
#
plexerLibrary = De/Multiplexeurs,Encodeurs
plexerSelectBitsAttr = Select Bits
plexerThreeStateAttr = Trois \u00e9tats?
plexerDisabledAttr = D\u00e9sactiv\u00e9 les sorties
plexerDisabledFloating = Flottant
plexerDisabledZero = Zero
plexerEnableAttr = Inclure l'activation ?
plexerSelectLocAttr = Selectionner l'emplacement
plexerSelectTopRightOption = Haut/Droite
plexerSelectBottomLeftOption = Fond/Gauche
# std/Multiplexer.java
multiplexerComponent = Multiplexeur
multiplexerSelectTip = Select: identifie l'entr\u00e9e qui devient la sortie
multiplexerEnableTip = Enable: si non 0, la sortie est l'entr\u00e9e s\u00e9lectionn\u00e9e
multiplexerInTip = Entr\u00e9e %s
multiplexerOutTip = Sortie
# std/Demultiplexer.java
demultiplexerComponent = Demultiplexeur
demultiplexerSelectTip = Select: identifie quelle sortie re\u00e7oit l'entr\u00e9e
demultiplexerEnableTip = Enable: si non 0, la sortie s\u00e9lectionn\u00e9e et l'entr\u00e9e
demultiplexerInTip = Entr\u00e9e
demultiplexerOutTip = Sortie %s
# std/Decoder.java
decoderComponent = Decodeur
decoderSelectTip = Select: identifie quelle sortie est \u00e0 1
decoderEnableTip = Enable: si non 0, la sortie s\u00e9lectionn\u00e9e est \u00e0 1
decoderOutTip = Sortie %s
# std/plexers/PriorityEncoder.java
priorityEncoderComponent = Encodeur prioritaire
priorityEncoderInTip = Entr\u00e9e %s
priorityEncoderOutTip = Sortie: adresse du 1 avec le plus haut indexe
priorityEncoderEnableInTip = Activer l'entr\u00e9e: 0 d\u00e9sactive le composant
priorityEncoderEnableOutTip = Activer la sortie: 1 si activ\u00e9 et aucune entr\u00e9e est \u00e0 1
priorityEncoderGroupSignalTip = Group Select: 1 si activ\u00e9 et n'importe quelle entr\u00e9e est \u00e0 1
# std/BitSelector.java
bitSelectorComponent = S\u00e9lecteur de Bit
bitSelectorGroupAttr = Bits en sortie
bitSelectorOutputTip = Sortie: valeur du groupe de bits s\u00e9lectionn\u00e9s dans data
bitSelectorDataTip = Data
bitSelectorSelectTip = Select: identifie quel groupe de donn\u00e9es est s\u00e9lectionn\u00e9
#
# arith/Arithmetic.java
#
arithmeticLibrary = Arithm\u00e9tique
# arith/Adder.java
adderComponent = Additionneur
adderInputTip = Entr\u00e9e: un des nombres \u00e0 additionner
adderOutputTip = Sortie: la somme des entr\u00e9e (plus la retenue en entr\u00e9e)
adderCarryInTip = Retenue en entr\u00e9e: si 1, 1 de plus est ajout\u00e9 \u00e0 la sortie
adderCarryOutTip = Retenue en sortie: 1 si la somme d\u00e9passe le nombre de bits disponibles
# arith/Subtractor.java
subtractorComponent = Soustracteur
subtractorMinuendTip = Diminu\u00e9: le nombre dont on soustrait
subtractorSubtrahendTip = Soustrait: le nombre \u00e0 soustraire du diminu\u00e9
subtractorOutputTip = Sortie: la diff\u00e9rence entre le diminu\u00e9 et le soustrait
subtractorBorrowInTip = Emprunt en entr\u00e9e: si 1 la sortie est dminu\u00e9e de 1
subtractorBorrowOutTip = Emprunt en sortie: 1 si la diff\u00e9rence est n\u00e9gative
# arith/Multiplier.java
multiplierComponent = Multiplicateur
multiplierInputTip = Entr\u00e9e: l'un des nombres \u00e0 multiplier
multiplierOutputTip = Output: le produit des entr\u00e9es plus la retenue en entr\u00e9e
multiplierCarryInTip = Retenue en entr\u00e9e: une valeur \u00e0 ajouter \u00e0 la sortie
multiplierCarryOutTip = Retenue en sortie: le bit de poids le plus fort du produit
# arith/Divider.java
dividerComponent = Diviseur
dividerUpperInput = num\u00e9rateur
dividerRemainderOutput = reste
dividerDividendLowerTip = num\u00e9rateur bas: la moiti\u00e9 basse du nombre \u00e0 diviser
dividerDividendUpperTip = num\u00e9rateur haut: la moiti\u00e9 haute du nombre \u00e0 diviser
dividerDivisorTip = Diviseur: d\u00e9nominateur par lequel diviser
dividerOutputTip = Sortie: le r\u00e9sultat de la division du num\u00e9rateur par le d\u00e9nominateur
dividerRemainderTip = Reste: (num\u00e9rateur - sortie * diviseur)
# arith/Negator.java
negatorComponent = Inverseur
negatorInputTip = Entr\u00e9e: le nombre \u00e0 inverser
negatorOutputTip = Sortie: le compl\u00e9men \u00e0 deux de l'inversion de l'entr\u00e9e
# arith/Comparator.java
comparatorComponent = Comparateur
comparatorType = Type num\u00e9rique
unsignedOption = Non sign\u00e9
twosComplementOption = compl\u00e9ment \u00e0 2
comparatorInputATip = A: membre de gauche de l'op\u00e9ration
comparatorInputBTip = B: membre de droite de l'op\u00e9ration
comparatorLessTip = Less: 1 si A est plus petit que B
comparatorEqualTip = Equal: 1 si A est \u00e9gal \u00e0 B
comparatorGreaterTip = Greater: 1 si A est plus grand que B
# arith/Shifter.java
shifterComponent = D\u00e9calage
shifterShiftAttr = Type de d\u00e9calage
shiftLogicalLeft = Logique \u00e0 gauche
shiftLogicalRight = Logique \u00e0 droite
shiftArithmeticRight = Arithm\u00e9tique \u00e0 droite
shiftRollLeft = Rotation \u00e0 gauche
shiftRollRight = Rotation \u00e0 droite
shifterDistanceTip = Distance: combien de d\u00e9calage sur l'entr\u00e9e
shifterInputTip = Entr\u00e9e: les bits \u00e0 d\u00e9caler
shifterOutputTip = Sortie: r\u00e9sultat du d\u00e9calage de l'entr\u00e9e
# arith/BitAdder.java
bitAdderComponent = Additionneur bit \u00e0 bit
bitAdderInputTip = Entr\u00e9e: les bits \u00e0 compter
bitAdderOutputManyTip = Sortie: combien de bits sont \u00e0 1
# arith/BitFinder.java
bitFinderComponent = Recherche de bits
bitFinderFindLabel = trouver
bitFinderHighLabel = haut
bitFinderLowLabel = bas
bitFinderHighOption = Ordre le plus haut %s
bitFinderLowOption = Ordre le plus bas %s
bitFinderTypeAttr = Type
bitFinderIndexHighTip = Index: index de l'entr\u00e9e avec l'ordre le plus haut %s
bitFinderIndexLowTip = Index: index de l'entr\u00e9e avec l'ordre le plus bas %s
bitFinderPresentTip = Pr\u00e9sence: 1 si l'entr\u00e9e contien un %s
bitFinderInputTip = Entr\u00e9e: les bits \u00e0 rechercher
#
# io
#
# io/Io.java
ioLibrary = Entr\u00e9e/Sortie
ioLabelCenter = Centre
ioBitWidthAttr = Largeur données
ioColorAttr = Couleur
ioLabelLocAttr = Position du label
ioLabelColorAttr = Couleur du label
ioActiveAttr = Actif si haut?
# io/Button.java
buttonComponent = Bouton
# io/Joystick.java
joystickComponent = Joystick
# io/Keyboard.java
keyboardComponent = Clavier
keybDesc = Clavier (buffer cap. %s)
keybBufferLengthAttr = Longueur du Buffer
keybClearTip = Clear: 1 efface le buffer
keybClockTip = Horloge: trigger consomme le premier caract\u00e8re du buffer
keybEnableTip = Read activ\u00e9: 0 d\u00e9sactive l'horloge
keybAvailTip = Disponible: 1 quand le tampon contient des caract\u00e8res
keybOutputTip = Donn\u00e9es: Valeur ASCII du premier caract\u00e8re du tampon
# io/Led.java
ledComponent = LED
RGBledComponent = LED RVB
# io/DipSwitch.java
dipswitchComponent = Dip switch
nrOfSwitch = Nbr. commutateur
# io/SevenSegment.java
sevenSegmentComponent = Afficheur 7-Segment
# io/HexDigit.java
hexDigitComponent = Afficheur Hexad\u00e9cimal
# io/DotMatrix.java
dotMatrixComponent = Matrice de LED
ioMatrixInput = Format de l'entr\u00e9e
ioMatrixRows = Ligne de la matrice
ioMatrixCols = Colonne de la matrice
ioOnColor = On Color
ioOffColor = Off Color
ioBackgroundColor = Fond (background)
ioMatrixPersistenceAttr = Persistence lumineuse
ioMatrixShape = Forme d'un point
ioInputColumn = Colonnes
ioInputRow = Lignes
ioInputSelect = Selectionner ligne/colonne
ioShapeCircle = Circulaire
ioShapeSquare = Carr\u00e9
# io/Tty.java
ttyComponent = TTY
ttyDesc = TTY (%s lignes, %s colonnes)
ttyDescShort = TTY
ttyRowsAttr = Lignes
ttyColsAttr = Colonnes
ttyClearTip = Effacer: 1 efface l'\u00e9cran
ttyClockTip = Horloge: trigger ajoute le caract\u00e8re en entr\u00e9e
ttyEnableTip = Active l'\u00e9criture: 0 d\u00e9sactive l'horloge
ttyInputTip = Donn\u00e9es: valeur ASCII du prochain character \u00e0 \u00e9crire
# io/PortIO.java
pioComponent = Port I/O
pioNumber = Nombre de contacte
pioShowBus = Type de connexion ?
pioBuses = Un ou plusieurs bus
pioPins = Pin Simple
# io/ReptarLocalBus.java
repLBComponent = Reptar Local Bus
#
# hdl
#
# hdl/hdl.java
hdlLibrary = HDL-IP
# hdl/VhdlEntity.java
vhdlComponent = VHDL Entity
vhdlContentAttr = Contenu
vhdlContentValue = (click pour \u00e9diter)
# hdl/VhdlParser.jave
emptySourceException = Impossible d'analyser le contenu vide
duplicatedEntityException = D\u00e9claration d'entit\u00e9 dupliqu\u00e9e d\u00e9tect\u00e9e
CannotFindEntityException = The entity declaration cannot be found
CannotFindLibrariesException = La d\u00e9claration d'entit\u00e9 est introuvable
invalidVhdlFile = La structure de fichier VHDL n'est pas valided
missingBracketException = Parenth\u00e8se manquante dans la d\u00e9claration des ports
portDeclarationException = Syntaxe de port ill\u00e9gale
multiplePortsDeclarationException = Syntaxe ill\u00e9gale de ports multiples
vectorDeclarationException = Syntaxe de vecteur illicite
lineDeclarationException = Syntaxe de ligne ill\u00e9gale
invalidTypeException = Type de port invalide
keywordNotFoundException = Le mot cl\u00e9 '% s' est introuvable dans la description de l'entit\u00e9
# HdlContentEditor.java
hdlFrameTitle = Logisim-evolution: HDL Editor
openButton = Importer...
saveButton = Exporter...
validateButton = Valider le contenu
closeButton = Fermer la fen\u00eatre
importMessage = Toute modification apport\u00e9e \u00e0 ce composant sera perdue. Importer quand m\u00eame?
importTitle = Confirmer l'importation
importOption = Importer
cancelOption = Annuler
confirmCloseYes = Oui
confirmCloseNo = Non
confirmCloseBackup = Cr\u00e9er une sauvegarde
confirmCloseTitle = Confirmer ferme
confirmCloseMessage = Toute modification apport\u00e9e \u00e0 ce composant sera perdue. Fermer quand m\u00eame?
# HdlContent
validationErrorButton = Continuer
validationParseError = Erreur d'analyse
#
# tcl
#
tclLibrary = TCL
tclConsoleReds = TCL REDS console
tclGeneric = TCL generic
tclConsoleContentFile = TCL content file

tclInterfaceDefinition = TCL interface VHDL entity
tclInterfaceDefinitionValue = (click pour \u00e9diter)
