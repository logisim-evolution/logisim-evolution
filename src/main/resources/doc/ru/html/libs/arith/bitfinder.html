<html lang="ru">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Искатель битов</title>
</head>

<body bgcolor="FFFFFF">

<h1><img align="center" src="../../../../icons/bitfindr.gif" width="32" height="32">
<em>Искатель битов</em></h1>

<p><table>
<tr><td><strong>Библиотека:</strong></td>
	<td><a href="index.html">Арифметика</a></td></tr>
<tr><td><strong>Введён в:</strong></td>
	<td>2.6.1</td></tr>
<tr><td valign="top"><strong>Внешний вид:</strong></td>
	<td valign="top"><img src="../../../../img-libs/bitfindr.png" width="44" height="43"></td></tr>
</table></p>

<h2>Поведение</h2>

<p>Компонент принимает многобитное значение на входе и определяет номер бита, причём номер бита отсчитывается от 0-го как от младшего бита. Какой в точности номер вычисляется, зависит от атрибута Тип, как показано на примерах в таблице ниже для 8-битного входного значения 11010100.</p>

<blockquote><table><thead>
<tr><th>Тип</th><th>Выходное значение для 11010100</th></td></tr>
</thead><tbody>
<tr><td>Младший 1</td><td align="center">2</td></tr>
<tr><td>Старший 1</td><td align="center">7</td></tr>
<tr><td>Младший 0</td><td align="center">0</td></tr>
<tr><td>Старший 0</td><td align="center">5</td></tr>
</tbody></table></blockquote>

<p>Для младшего 1 на выходе 2, потому что если вы нумеруете биты начиная с 0-го как с младшего бита, то первая 1, которую вы найдёте, будет под номером 2. (Биты с номерами 0 и 1 оба равны 0.) Для старшего 1 на выходе 7, потому что самый верхний бит 1 - под номером 7 (опять же, считая самый младший бит нулевым).</p>

<p>Выход компонента на южном крае показывает, был ли желаемый бит вообще найден. В примерах выше для входного значение 11010100 на южном выходе 1 во всех случаях. Но если на входе было бы 00000000 и компонент искал бы младшую 1, то на южном выходе был бы 0 - и на выходе на восточном крае был бы тоже 0.</p>

<p>Если во время поиска желаемого значения найдено значение, не являющееся ни 0, ни 1 (бит плавающий или содержит значение ошибки), то оба выходных значения будут полностью состоять из битов со значением ошибки. Заметьте, что это случается только если проблемный бит встречается до нахождения желаемого бита: для входного значения x1010100 на выходе всё ещё будет 2, если нужен младший 1; но там будут значения ошибки, если тип компонента указывает искать старший 1 или старший 0, поскольку старший бит содержит значение ошибки, а не 0 или 1.</p>

<h2>Контакты</h2>

<dl>

<dt>Западный край (вход, разрядность соответствует атрибуту Биты данных)</dt>
<dd>Многобитный вход, в значении которого ищется нужный бит.</dd>

<dt>Восточный край (выход, разрядность вычисляется как описано ниже)</dt>
<dd>Номер желаемого бита, считая младший бит нулевым. Разрядность - минимальное количество бит для хранения максимально возможного номера, который на единицу меньше, чем значение атрибута Биты данных.</dd>

<dt>Южный край (выход, разрядность равна 1)</dt>
<dd>Значение равно 1, если желаемый бит найден, 0, если все входные биты противоположны желаемому биту, и значение ошибки, если значение не равное 0 или 1 найдено до желаемого бита.</dd>

</dl>

<h2>Атрибуты</h2>

<p>Когда компонент выбран, или уже добавлен, комбинации от Alt-0 до Alt-9 меняют его атрибут <q>Биты данных</q>.</p>

<dl>

<dt>Биты данных</dt>
<dd>Разрядность входа.</dd>

<dt>Тип</dt>
<dd>Указывает, какой бит искать - младший 0, старший 0, младший 1, или старший 1.</dd>

</dl>

<h2>Поведение Инструмента Нажатие</h2>

<p>Нет.</p>

<h2>Поведение Инструмента Текст</h2>

<p>Нет.</p>

<p><a href="../index.html">Назад к <em>Справке по библиотеке</em></a></p>

</body>
</html>
