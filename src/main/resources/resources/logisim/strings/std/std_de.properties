#
# arith/Adder.java
#
adderCarryInTip = Übertragseingang: wenn 1 wird eine weitere 1 zur Summe addiert
adderCarryOutTip = Übertragsausgang: ist 1, wenn die Summe die verfügbare Bitbreite übersteigt
adderComponent = Addierer
adderInputTip = Eingang: einer der Summanden
adderOutputTip = Ausgang: die Summe der Eingänge (plus Übertragseingang)
#
# arith/ArithmeticLibrary.java
#
arithmeticLibrary = Arithmetik
#
# arith/BitAdder.java
#
bitAdderComponent = Bit-Zähler
bitAdderInputTip = Eingang: die zu zählenden Bits
bitAdderOutputManyTip = Ausgang: die Anzahl der 1-Bits an den Eingängen
gateInputsAttr = Anzahl der Eingänge
#
# arith/BitFinder.java
#
bitFinderComponent = Bit-Finder
bitFinderFindLabel = find
bitFinderHighLabel = high
bitFinderHighOption = Oberste %s
bitFinderIndexHighTip = Index: Index der höchstwertigsten %s des Eingangs
bitFinderIndexLowTip = Index: Index der niederwertigsten %s des Eingangs
bitFinderInputTip = Eingang: die zu durchsuchenden Bits
bitFinderLowLabel = low
bitFinderLowOption = Unterste %s
bitFinderPresentTip = Vorhanden: ist 1, wenn der Eingang eine %s enthält
bitFinderTypeAttr = Typ
#
# arith/Comparator.java
#
comparatorComponent = Komparator
comparatorEqualTip = Gleich: ist 1, wenn A gleich B ist
comparatorGreaterTip = Größer: ist 1, wenn A größer als B ist
comparatorInputATip = A: die Zahl vor dem Vergleichsoperator
comparatorInputBTip = B: die Zahl nach dem Vergleichsoperator
comparatorLessTip = Kleiner: ist 1, wenn A kleiner als B ist
comparatorType = Zahlentyp
twosComplementOption = Zweierkomplement
unsignedOption = ohne Vorzeichen
#
# arith/Divider.java
#
dividerComponent = Teiler
dividerDividendLowerTip = Dividend (unten): die untere Hälfte der zu teilenden Zahl
dividerDividendUpperTip = Dividend (oben): die obere Hälfte der zu teilenden Zahl
dividerDivisorTip = Divisor: die Zahl, durch die zu teilen ist
dividerOutputTip = Ausgang: das Ergebnis der Division von Dividend durch Divisor
dividerRemainderOutput = rem
dividerRemainderTip = Rest: der Rest der Division (Dividend - Ausgang * Divisor)
dividerUpperInput = upper
#
# arith/FPAdder.java
#
fpAdderComponent = Gleitkomma-Addierer
fpAdderOutputTip = Ausgang: Die Summe der Eingänge
fpErrorTip = Error: 1 wenn ein Ein- oder Ausgang NaN ist
#
# arith/FPComparator.java
#
fpComparatorComponent = Gleitkomma-Vergleicher
#
# arith/FPDivider.java
#
fpDividerDividendTip = Dividend: Die zu teilende Zahl
fpDividerComponent = Gleitkomma-Dividierer
#
# arith/FPMultiplier.java
#
fpMultiplierComponent = Gleitkomma-Multiplizierer
fpMultiplierOutputTip = Ausgang: Das Produkt der Eingänge
#
# arith/FPNegator.java
#
fpNegatorComponent = Gleitkomma-Negierer
fpNegatorOutputTip = Ausgang: Negierter Eingang
#
# arith/FPSubtractor.java
#
fpSubtractorComponent = Gleitkomma-Subdrahierer
#
# arith/FPToInt.java
#
ceilOption = Aufrunden
floorOption = Abrunden
fpToIntComponent = Gleitkomma zu Ganzzahl
fpToIntInputTip = Eingang: Die umzuwandelnde Gleitkommazahl
fpToIntOutputTip = Ausgang: Die vorzeichenbehaftete gerundete Gleitkommazahl
fpToIntType = Rundungsmodus
roundOption = Auf die nächste Zahl runden
truncateOption = Kürzen
#
# arith/IntToFP.java
#
intToFPComponent = Ganzzahl zu Gleitkomma
intToFPInputTip = Eingang: Die in eine Gleitkommazahl zu wandelnde Ganzzahl.
intToFPOutputTip = Ausgang: Die Gleitkommarepräsentation des Eingangs.
#
# arith/Multiplier.java
#
multiplierCarryInTip = Übertragseingang: zum Ergebnis zu addierender Wert
multiplierCarryOutTip = Übertragsausgang: die höherwertigen Bits des Produkts
multiplierComponent = Multiplizierer
multiplierInputTip = Eingang: eine der zu multiplizierenden Zahlen
multiplierOutputTip = Ausgang: das Produkt der Eingänge plus Übertragseingang
signedUnsignedOption = Signiert Unsigniert
#
# arith/Negator.java
#
negatorComponent = Negator
negatorInputTip = Eingang: die zu negierende Zahl
negatorOutputTip = Ausgang: das Zweierkomplement des Eingangs
#
# arith/Shifter.java
#
shiftArithmeticRight = Arithmetisch nach rechts
shifterComponent = Bitschieber
shifterDistanceTip = Distanz: wie weit der Eingang zu schieben ist
shifterInputTip = Eingang: die zu schiebenden Bits
shifterOutputTip = Ausgang: Ergebnis der Schiebung des Eingangs
shifterShiftAttr = Typ des Schiebens
shiftLogicalLeft = Logisch nach links
shiftLogicalRight = Logisch nach rechts
shiftRollLeft = Rotierend nach links
shiftRollRight = Rotierend nach rechts
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Leiheingang: wenn 1 wird eine weitere 1 vom Ergebnis abgezogen
subtractorBorrowOutTip = Leihausgang: ist 1, wenn die Differenz negativ ist
subtractorComponent = Subtrahierer
subtractorMinuendTip = Minuend: die Zahl, von der abzuziehen ist
subtractorOutputTip = Ausgang: die Differenz zwischen Minuend und Subtrahend
subtractorSubtrahendTip = Subtrahend: die Zahl, die abgezogen wird
#
# base/BaseLibrary.java
#
baseLibrary = Basis
#
# base/Text.java
#
textComponent = Beschriftung
textFontAttr = Zeichensatz
textColorAttr = Farbe
textHorzAlignAttr = Horizontale Ausrichtung
textHorzAlignCenterOpt = Zentriert
textHorzAlignLeftOpt = Links
textHorzAlignRightOpt = Rechts
textTextAttr = Text
textVertAlignAttr = Vertikale Ausrichtung
textVertAlignBaseOpt = Basis
textVertAlignBottomOpt = Unten
textVertAlignCenterOpt = Zentriert
textVertAlignTopOpt = Oben
#
# base/VhdlParser.java
#
CannotFindEntityException = Die Entitätserklärung kann nicht gefunden werden.
emptySourceException = Leere Inhalte können nicht analysiert werden.
genericDeclarationException = Syntax illegaler Generika
genericTypeException = Nicht unterstützter Generikatyp
genericValueException = Standardwert für nicht erkannte Generika
invalidTypeException = Ungültiger Porttyp
portDeclarationException = Illegale Port-Syntax
# ==> portTypeException =
#
# Builtin.java
#
builtinLibrary = Eingebaut
#
# gates/AndGate.java
#
andGateComponent = AND Gatter
#
# gates/Buffer.java
#
bufferComponent = Puffer
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Tristate-Puffer
controlledControlOption = Position der Steuerleitung
controlledInverterComponent = Tristate-Inverter
controlledLeftHanded = linke Seite
controlledRightHanded = rechte Seite
#
# gates/EvenParityGate.java
#
evenParityComponent = Gerade Parität
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/hochohmig
gateOutputAttr = Ausgabewert
gateOutputZ1 = hochohmig/1
gateSizeNormalOpt = Mittel
xorBehaviorAttr = Verhalten bei mehreren Eingängen
xorBehaviorOdd = Falls eine ungerade Anzahl gesetzt ist
xorBehaviorOne = Falls genau ein Eingang gesetzt ist
#
# gates/GatesLibrary.java
#
gatesLibrary = Gatter
#
# gates/NandGate.java
#
nandGateComponent = NAND Gatter
#
# gates/NegateAttribute.java
#
gateNegateAttr = Negiere %s
#
# gates/NorGate.java
#
norGateComponent = NOR Gatter
#
# gates/NotGate.java
#
notGateComponent = Inverter
#
# gates/OddParityGate.java
#
oddParityComponent = Ungerade Parität
#
# gates/OrGate.java
#
orGateComponent = OR Gatter
#
# gates/PLA.java
#
plaBitWidthIn = Bitbreite Eingang
plaBitWidthOut = Bitbreite Ausgang
input = Eingang
output = Ausgang
PLA = PLA
plaClickToEdit = (zum Bearbeiten anklicken)
plaEditMenuItem = PLA-Programm bearbeiten......
plaProgram = Programm
#
# gates/PLATable.java
#
plaEditorTitle = PLA-Programmeditor
plaFileCreateError = Es konnte keine Datei erstellt werden.
plaFileOpenError = Die Datei konnte nicht geöffnet werden.
plaLoadDialogTitle = PLA-Programm laden
plaLoadErrorTitle = Fehler beim Laden des PLA-Programms
plaSaveDialogTitle = PLA-Programm speichern
plaSaveErrorTitle = Fehler beim Speichern des PLA-Programms
# ==> plaExportButton =
# ==> plaImportButton =
# ==> plaOKButton =
# ==> plaCancelButton =
# ==> plaRemoveButton =
# ==> plaAddRowButton =
# ==> plaCommentsLabel =
# ==> plaInputLabel =
# ==> plaOutputLabel =
# ==> plaFileIoException =
# ==> plaInvalideInputBitError =
# ==> plaInvalideOutputBitError =
# ==> plaRowExactOutBitError =
# ==> plaRowExactInBitError =
# ==> plaRowMissingOutputError =
# ==> plaTableError =
#
# gates/XnorGate.java
#
xnorGateComponent = XNOR Gatter
#
# gates/XorGate.java
#
xorGateComponent = XOR Gatter
#
# InstanceComponent.java
#
KeywordNameError = Label ist ein reserviertes Schlüsselwort und kann nicht verwendet werden. Bitte geben Sie ein anderes Label an.
MatchedLabelNameError = Label und Komponentenname dürfen nicht identisch (Groß-/Kleinschreibung wird nicht beachtet) sein. Bitte geben Sie ein anderes Label als den Komponentennamen an.
#
# InstanceTextField.java
#
changeLabelAction = Beschriftung ändern
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = Dip-Schalter
nrOfSwitch = Anzahl der Schalter
#
# io/LedCluster.java
#
#
# io/DotMatrix.java
#
ioInputColumn = Spalten
ioInputRow = Zeilen
ioInputSelect = Zeilen / Spalten auswählen
ioMatrixCols = Matrixspalten
ioMatrixInput = Eingabeformat
ioMatrixPersistenceAttr = Nachleuchtdauer
ioMatrixRows = Matrixzeilen
ioMatrixShape = Punktform
ioShapeCircle = rund
ioShapeSquare = quadratisch
ioShapePaddedSquare = umrandetes Quadrat
ioLedBarComponent = LED Leiste
ioLedBarSegments = Segmente
ioLedBarInput = Eingabeformat:
ioLedBarInputSeparated = getrennt
ioLedBarInputOneWire = eine Leitung
#
# io/extra/Buzzer.java
#
buzzerFrequecy = Frequenz
buzzerVolume = Volumen
buzzerVolumeBitWidth = Volumenbitbreite
buzzerUnitDhz = dHz (0,1Hz)
buzzerWaveform = Signalform
buzzerSine = Sinus
buzzerSquare = Rechteck
buzzerSmoothLevel = Glättungsstärke
buzzerSmoothWidth = Fenstergröße
buzzerChannel = Kanal
buzzerChannelBoth = beide
buzzerChannelLeft = links
buzzerChannelRight = rechts
buzzerTriangle = Dreieck
buzzerSawtooth = Sägezahn
buzzerNoise = Weißes Rauschen
buzzerDutyCycle = Einschaltdauer
enableSound = Ton aktivieren
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Randfarbe
bothOption = beide
ClearDiagram = Diagramm leeren
DigitalOscilloscopeClock = Takt
DrawClockFrontLine = Takt Flanken anzeigen
noOption = keine
ShowClockAttribute = Taktsignal anzeigen
stdTriggerFalling = Fallende Flanke
stdTriggerRising = Steigende Flanke
#
# io/extra/ExtraIoLibrary.java
#
buzzerComponent = Summer
DigitalOscilloscopeComponent = Digital Oszilloskop
PlaRomComponent = PLA
Slider = Schieberegler
switchComponent = Schalter
#
# io/extra/PlaRom.java
#
memCSTip = Chip-Auswahl: 0 deaktiviert das Bauteil
PlaANDAttr = Verundungen
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = PLA ROM %s Bearbeitungsfenster
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Anzahl der Zustände
ProgrammableGeneratorComponent = Progr. Generator
ramClearMenuItem = Inhalt löschen
ramEditMenuItem = Inhalt bearbeiten ...
romContentsAttr = Inhalt
romContentsValue = (Klicken zum Bearbeiten)
#
# io/extra/Slider.java
#
left_to_rightOption = von links nach rechts
right_to_leftOption = von rechts nach links
#
# io/HexDigit.java
#
hexDigitDataTip = Daten: Nibble zur hexadezimalen Darstellung
hexDigitDPTip = Dezimalpunkt: wenn 1: Dezimalpunkt eingeschaltet.
#
# io/IoLibrary.java
#
buttonComponent = Taster
dipswitchComponent = Dip-Schalter
dotMatrixComponent = LED-Matrix
hexDigitComponent = Hexadezimale Anzeige
ioActiveAttr = Eingeschaltet bei H-Signal?
ioBackgroundColor = Hintergrund
ioColorAttr = Farbe
ioLibrary = Eingabe/Ausgabe
ioOffColor = Farbe AUS
ioOnColor = Farbe AN
joystickComponent = Joystick
ledComponent = LED
pioComponent = Port I/O
repLBComponent = Reptar Lokaler Bus
RGBledComponent = RGBLED
sevenSegmentComponent = 7-Segmentanzeige
ttyComponent = Terminal
#
# io/Button.java
#
buttonPressAttr = Logik level
buttonPressActive = aktiv wenn gedrückt
buttonPressPassive = passiv wenn gedrückt
#
# io/Joystick.java
#
ioBitWidthAttr = Bitbreite
joystickCoordinateX = Ausgang: x-Koordinate
joystickCoordinateY = Ausgang: y-Koordinate
#
# io/Keyboard.java
#
keybAvailTip = Verfügbar: 1 wenn der Puffer Zeichen enthält
keybBufferLengthAttr = Pufferlänge
keybClearTip = Löschen: wenn 1 wird der Puffer gelöscht
keybClockTip = Takt: Triggersignal entfernt das vorderste Zeichen des Puffers
keybDesc = Tastatur (Pufferkap. %s)
keybEnableTip = Lesefreigabe: 0 sperrt das Taktsignal
keyboardComponent = Tastatur
keybOutputTip = Daten: ASCII-Wert des vordersten Zeichens im Puffer
#
# io/PortIO.java
#
pioDirection = Port Typ:
pioInput = Eingang
pioInputs = Eingänge %s
pioIOMultiple = I/O (Einzelde Freigabe)
pioIOSingle = I/O (Gemeinsame Freigabe)
pioNumber = Anzahl der Pins
pioOutEnable = Ausgabe freigeben
pioOutEnables = Ausgaben freigeben %s
pioOutput = Ausgang
pioOutputs = Ausgänge %s
#
# io/ReptarLocalBus.java
#
repLBTip = B-Spitze
#
# io/RgbLed.java
#
BLUE = Blauer Eingang
GREEN = Grüner Eingang
RED = Roter Eingang
#
# io/SevenSegment.java
#
DecimalPoint = Dezimalpunkt
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
SevenSegDP = Hat Dezimalpunkt
#
# io/Telnet.java
#
telnetComponent = Telnet
telnetModeAttr = Verwende Telnet-Protokoll
telnetPortAttr = Port
telnetInTip = Eingang: zu senden Daten
telnetOutTip = Ausgang: empfangene Daten
telnetClkTip = Takt: bei Triggersignal Daten lesen/senden
telnetWriteTip = Lesen aktivieren
telnetReadTip = Senden aktivieren
telnetAvailableTip = Verfügbarkeit: Daten zum Lesen verfügbar
#
# io/Tty.java
#
ttyClearTip = Löschen: 1 löscht den Bildschirm
ttyClockTip = Takt: Triggersignal übernimmt das Zeichen vom Eingang
ttyColsAttr = Spalten
ttyDesc = Terminal (%s Zeilen, %s Spalten)
ttyDescShort = Terminal
ttyEnableTip = Schreibfreigabe: 0 sperrt das Taktsignal
ttyInputTip = Daten: ASCII-Wert des nächsten zu schreibenden Zeichens
ttyRowsAttr = Zeilen
#
# io/Video.java
#
rgbVideoCLK = Takt
rgbVideoColor = Farbmodus
rgbVideoComponent = RGB-Video
rgbVideoCursor = Cursor
rgbVideoData = Daten im %s-Format
rgbVideoHeight = Höhe
rgbVideoReset = Verhalten zurücksetzen
rgbVideoRST = Zurücksetzen
rgbVideoScale = Skalierung
rgbVideoWE = Schreibfreigabe
rgbVideoWidth = Breite
rgbVideoX = X-Koordinate
rgbVideoY = Y-Koordinate
#
# bfh/bcd2sevenseg.java
#
BCDValue = BCD-Wert
BCD2SevenSegment = BCD auf Siebensegmentanzeige
#
# bfh/BfhLibrary.java
#
BFHMegaFunctions = BFH Mega-Funktionen
Bin2BCD = Binär zu BCD
#
# bfh/bin2bcd.java
#
BinaryDataBits = Binäre-Datenbits
BinaryInputTip = Binäre-Eingabe
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Takt: Zustandsaktualisierung bei Triggersignal
flipFlopNotQTip = Aktuellen Flip-Flop-Zustand invertieren
flipFlopPresetTip = Setzen: wenn 1, gehe asynchron zu Zustand 1
flipFlopQTip = Aktueller Flip-Flop-Zustand
flipFlopResetTip = Löschen: wenn 1, gehe asynchron zu Zustand 0
#
# memory/Counter.java
#
counterCarryTip = Übertrag: ist 1, wenn der Zähler den Höchstwert erreicht (Minimalwert beim Abwärtszählen)
counterClockTip = Takt: Wert kann bei Triggersignal aktualisiert werden
counterComponent = Zähler
counterDataTip = Daten: in den Zähler zu ladender Wert
counterEnableLabel = ct
counterEnableTip = Takt: wenn 1, zähle aufwärts (oder abwärts falls Laden = 1)
counterGoalAttr = Bei Überlauf:
counterGoalContinue = Zähle weiter
counterGoalLoad = Lade den nächsten Wert
counterGoalStay = Halte an
counterGoalWrap = Starte neu
counterLabel = ctr
counterLoadTip = Laden: wenn 1, lade den Wert vom Daten-Eingang (falls Takt = 0) oder zähle abwärts
counterMaxAttr = Höchstwert
counterQTip = Ausgang: aktueller Wert des Zählers
counterResetTip = Löschen: wenn 1 wird der Zähler asynchron auf 0 gesetzt
counterUpDownTip = Aufwärts Abwärts: wenn 1, Zähler erhöht, wenn 0, Zähler verringert sich.
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
memAsyncRead = Asynchrones Lesen:
memByte = Verwendung von Byte-Freigaben
memDual = Zweifach
memEnables = Aktiviert:
memLine = Zeilenfreigaben verwenden
memLineSize = Größe der Linie
memMisaligned = Fehlausrichtungen erlauben?
memOcto = Achtfach
memQuad = Vierfach
memRaw = Lesen nach Schreiben
memReadBehav = Leseverhalten
memSingle = Einzeln
memWar = Schreiben nach Lesen
ramAddrWidthAttr = Bitbreite der Adresse
ramDataWidthAttr = Bitbreite der Daten
ramSelAttr = Auswählen
stdTriggerHigh = H-Niveau
stdTriggerLow = L-Niveau
#
# memory/MemMenu.java
#
ramConfirmClearMsg = Sind Sie sicher, dass der Speicher auf Null gesetzt werden soll?
ramConfirmClearTitle = Löschen bestätigen
ramLoadMenuItem = Speicherabbild laden...
ramSaveMenuItem = Speicherabbild speichern...
#
# memory/MemoryLibrary.java
#
dFlipFlopComponent = D Flip-Flop
memoryLibrary = Speicher
tFlipFlopComponent = T Flip-Flop
#
# memory/Ram.java
#
ramComponent = RAM
#
# memory/RamAppearance.java
#
memAddrTip = Adresse: Zugriffsposition im Speicher
memDataTip = Daten: von der Adresse geladene Daten
memDataTip0 = Daten: Wert geladen von Adresse 0
memDataTip1 = Daten: Wert geladen von Adresse 1
memDataTip2 = Daten: Wert geladen von Adresse 2
memDataTip3 = Daten: Wert geladen von Adresse 3
ramByteEnableTip0 = Byte-Freigabe für Byte 0
ramByteEnableTip1 = Byte-Freigabe für Byte 1
ramByteEnableTip2 = Byte-Freigabe für Byte 2
ramByteEnableTip3 = Byte-Freigabe für Byte 3
ramClkTip = Takt: Speicherinhalt wird beim Übergang von 0 auf 1 aktualisiert
ramClrPin = Clear: eine Eins setzt alle Speicherplätze auf 0
ramInTip = Eingang: an der Adresse zu speichernder Wert
ramInTip0 = Eingabe: Wert, der auf Adresse 0 gespeichert werden soll
ramInTip1 = Eingabe: Wert, der an Adresse 1 gespeichert werden soll
ramInTip2 = Eingabe: Wert, der auf Adresse 2 gespeichert werden soll
ramInTip3 = Eingabe: Wert, der auf Adresse 3 gespeichert werden soll
ramLETip0 = Zeilenfreigabe für Adresse 0
ramLETip1 = Zeilenfreigabe für Adresse 1
ramLETip2 = Zeilenfreigabe für Adresse 2
ramLETip3 = Zeilenfreigabe für Adresse 3
ramOETip = Laden: wenn 1 wird Speicherinhalt auf Ausgang übertragen
ramWETip = Speichern: wenn 1 wird Eingang in Speicher übertragen
#
# memory/RamAttributes.java
#
ramBidirDataBus = Ein bidirektionaler Datenbus
ramByteEnables = Lese-/Schreib-Steuerung
RamClearPin = Clear Pin verwenden
ramDataAttr = Datenbus-Implementierung
ramNoByteEnables = Nur Lesen/Schreiben von ganzen Wörtern
ramSeparateDataBus = Separater Datenbus für Lesen und Schreiben
ramTypeAttr = Ram-Typ
ramTypeNonVolatile = nichtflüchtig
ramTypeVolatile = flüchtige
ramWithByteEnables = Byte verwenden aktiviert
#
# memory/Random.java
#
randomClockTip = Takt: Wert kann bei Triggersignal aktualisiert werden
randomComponent = Zufallsgenerator
randomLabel = zufällig
randomNextTip = Freigabe: wechsle zum nächsten Schritt der Sequenz bei Triggersignal
randomQTip = Ausgang: aktuelle Zahl in der Zahlenfolge
randomResetTip = Löschen: wenn 1 wird asynchron auf den ursprünglichen Startwert zurückgesetzt
randomSeedAttr = Startwert
randomWidthLabel = Breite: %d
#
# memory/Register.java
#
registerClkTip = Takt: Wert wird bei Triggersignal aktualisiert
registerClrTip = Löschen: wenn 1 wird der Wert asynchron auf 0 gesetzt
registerComponent = Register
registerDTip = Daten: beim Triggersignal zu speichernder Wert
registerEnableTip = Freigabe: wenn 0 sind Taktsignale unwirksam
registerLabel = reg
registerQTip = Ausgang: aktueller Wert des Registers
registerShowInTab = In Registerkarten anzeigen
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = ROM-Inhalt bearbeiten
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Löschen: wenn 1 werden alle Werte asynchron auf 0 gesetzt
shiftRegClockTip = Takt: Werte können bei Triggersignal aktualisiert werden
shiftRegInTip = Eingang: Wert, der in die erste Stufe geschoben werden soll
shiftRegisterComponent = Schieberegister
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Anzahl der Stufen
shiftRegLoadTip = Laden: wenn 1 (mit Freigabe = 0) werden alle Stufen von den Eingängen geladen
shiftRegOutTip = Ausgang: der Inhalt der letzten Stufe
shiftRegParallelAttr = Paralleles Laden
shiftRegShiftTip = Freigabe: wenn 0 ist das Schieben gesperrt
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Bit-Wähler
bitSelectorDataTip = Eingang
bitSelectorGroupAttr = Ausgangsbits
bitSelectorOutputTip = Ausgang: Wert der ausgewählten Gruppe von Bits vom Eingang
bitSelectorSelectTip = Auswahl: gibt an, welche Gruppe von Bits ausgewählt werden soll
#
# plexers/Decoder.java
#
decoderEnableTip = Aktivierung: wenn nicht 0, wird 1 auf ausgewählten Ausgang geschaltet
decoderOutTip = Ausgang %s
decoderSelectTip = Auswahl: gibt an, welcher Ausgang auf 1 gesetzt wird
#
# plexers/Demultiplexer.java
#
demultiplexerEnableTip = Aktivierung: wenn nicht 0, wird Eingang auf ausgewählten Ausgang geschaltet
demultiplexerInTip = Eingang
demultiplexerOutTip = Ausgang %s
demultiplexerSelectTip = Auswahl: gibt an, an welchen Ausgang der Eingang durchgeschaltet wird
#
# plexers/Multiplexer.java
#
multiplexerEnableTip = Aktivierung: wenn nicht 0 wird ausgewählter Eingang auf Ausgang geschaltet
multiplexerInTip = Eingang %s
multiplexerOutTip = Ausgang
multiplexerSelectTip = Auswahl: gibt an, welcher Eingang an den Ausgang durchgeschaltet wird
#
# plexers/PlexersLibrary.java
#
decoderComponent = Dekoder
demultiplexerComponent = Demultiplexer
gateSizeAttr = Gattergröße
gateSizeNarrowOpt = Schmal
gateSizeWideOpt = Breit
multiplexerComponent = Multiplexer
plexerDisabledAttr = Ausgang deaktivieren
plexerDisabledFloating = Offen
plexerDisabledZero = Null
plexerEnableAttr = Eingang freigeben?
plexerLibrary = Auswahlschaltungen
plexerSelectBitsAttr = Auswahlleitungen
plexerThreeStateAttr = Threestate?
priorityEncoderComponent = Prioritätsenkoder
#
# plexers/PriorityEncoder.java
#
priorityEncoderEnableInTip = Freigabeeingang: 0 sperrt das Bauteil
priorityEncoderEnableOutTip = Freigabeausgang: 1 wenn freigegeben und kein Eingang auf 1 gesetzt
priorityEncoderGroupSignalTip = Gruppenauswahl: 1 wenn einer der Eingänge auf 1 gesetzt
priorityEncoderInTip = Eingang %s
priorityEncoderOutTip = Ausgang: Adresse des höchst-indizierten, auf 1 gesetzten Eingangs
#
# StdAttr.java
#
ioLabelColorAttr = Farbe der Beschriftung
stdClassicAppearance = Klassisches Logisim
stdDataWidthAttr = Datenbits
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Ausrichtung
stdFPDataWidthAttr = Größe der Gleitkommazahl
stdLabelAttr = Beschriftung
stdLabelCenter = Zentrum
stdLabelFontAttr = Zeichensatz der Beschriftung
stdLabelLocAttr = Labelposition
stdLabelVisibility = Etikett sichtbar
stdLogisimEvolutionAppearance = Logisim-evolution
stdTriggerAttr = Trigger
stdSelectLocAttr = Position der Eingänge
stdSelectBottomLeftOption = Unten/Links
stdSelectTopRightOption = Oben/Rechts
#
# tcl/TclLibrary.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = TCL Inhaltsdatei
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = TCL REDS Konsole
#
# tcl/TclGeneric.java
#
tclGeneric = TCL generisch
tclInterfaceDefinition = TCL-Schnittstelle VHDL-Einheit
tclInterfaceDefinitionValue = (zum Bearbeiten anklicken)
#
# ttl/AbstractTtlGate.java
#
GNDPin = GND-Pin %s
VCCPin = VCC-Pin %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Ausblendung
DisplayDecoderComponent = Display-Decoder
DisplayDecoderInTip = Input
DisplayDecoderOutTip = Output
ioMultiBit = Multi-Bit
LampTestInTip = Eingang Lampentest
LT = LT
memEnableLabel = en
RBI = RBI
RippleBlankingInputInTip = Ripple Blanking Eingang
#
# ttl/TtlLibrary.java
#
ShowInternalStructure = Interne Struktur anzeigen
TTL7400 = 7400: Vierfach 2-Eingangs-NAND-Gatter
TTL7402 = 7402: Vierfach 2-Eingangs-NOR-Gatter
TTL7404 = 7404: Sechsfach Invertierer
TTL7408 = 7408: Vierfach 2-Eingangs-UND-Gatter
TTL7410 = 7410: Dreifach 3-Eingangs-NAND-Gatter
TTL7411 = 7411: Dreifach 3-Eingangs-UND-Gatter
TTL74125 = 74125: Vierfach Bus-Puffer, Drei-Status-Ausgänge, negative Freigabe
TTL74151 = 74151: 8 zu 1 Leitungsauswahl
TTL74153 = 74153: Zweifach 4 zu 1 Leitungsauswahl
TTL74157 = 74157: Vierfach 2 zu 1 Leitungsauswahl
TTL74158 = 74158: Vierfach 2 zu 1 Leitungsauswahl, negierter Ausgang
# ==> TTL74138 =
TTL74139 = 74139: Zweifach 2 zu 4 Decoder
TTL7413 = 7413: Zweifach 4-Eingangs-NAND-Gatter (Schmitt-Trigger)
TTL7414 = 7414: Sechsfach Invertierer (Schmitt-Trigger)
TTL74161 = 74161: synchroner 4-bit-Zähler mit Clear
TTL74163 = 74163: synchroner 4-bit-Zähler mit synchronem Clear
TTL74164 = 74164: 8-Bit Serielles zu Parallel Schieberegister
# ==> TTL74165 =
# ==> TTL74165 =
# ==> TTL74166 =
TTL74175 = 74175: Vierfach D-Flipflop, asynchroner Clear
TTL7418 = 7418: Zweifach 4-Eingangs-NAND-Gatter (Schmitt-Trigger)
TTL74181 = 74181: Arithmetisch-logische Einheit
# ==> TTL74182 =
TTL7419 = 7419: Sechsfach Invertierer (Schmitt-Trigger)
TTL74192 = 74192: 4-Bit Decaden Zähler (Hoch/Runter)
TTL74193 = 74193: 4-Bit Binär Zähler (Hoch/Runter)
TTL7420 = 7420: Zweifach 4-Eingangs-NAND-Gatter
TTL7421 = 7421: Zweifach 4-Eingangs-UND-Gatter
TTL7424 = 7424: Vierfach 2-Eingangs-NAND-Gatter (Schmitt-Trigger)
# ==> TTL74240 =
# ==> TTL74241 =
# ==> TTL74244 =
# ==> TTL74245 =
# ==> TTL74266 =
TTL7427 = 7427: Dreifach 3-Eingangs-NOR-Gatter
TTL74273 = 74273: Achtfach D-Flipflop mit Clear
TTL74283 = 74283: 4-Bit-Binär-Volladdierer mit Clear
TTL74299 = 74299: 8-Bit-Universalschieberegister mit Tri-State-Ausgängen
TTL7430 = 7430: Einfach 8-Eingangs-NAND-Gatter
TTL7432 = 7432: Vierfach 2-Einganges-ODER-Gatter
TTL7434 = 7434: Sechsfach Puffer
TTL7436 = 7436: Vierfach 2-Eingangs-NOR-Gatter
TTL74377 = 74377: Achtfach D-Flipflop mit Freigabe
TTL74381 = 74381: Arithmetisch-logische Einheit (ALU)
TTL7442 = 7442: BCD auf Dezimaldecoder
TTL7443 = 7443: Excess-3 zu Dezimal Decoder
TTL7444 = 7444: Gray zu dezimaler Decoder
TTL7447 = 7447: BCD zu 7-Segment Decoder
TTL7451 = 7451: Zweifach AND-OR-INVERT-Gatter
TTL7454 = 7454: Vierfach UND-OR-INVERT-Gatter
TTL74541 = 74541: Achtfach Puffer / Leitungstreiber
TTL7458 = 7458: Zweifach AND-OR Gatter
TTL7464 = 7464: 4-2-3-2-2 AND-OR-INVERT-Gatter
TTL74670 = 74670: 4-mal-4-Bit-Registerspeicher mit Tri-State-Ausgängen
TTL747266 = 747266: Vierfach 2-Eingangs-XNOR-Gatter
TTL7474 = 7474: Zweifach D-Flipflops mit Preset und Clear
TTL7485 = 7485: 4-Bit Größenvergleicher
TTL7486 = 7486: Vierfach 2-Eingangs-XOR-Gatter
TTL7487 = 7487: 4-Bit Wahr/Komplement, Null/Eins-Elemente
VccGndPorts = Vcc- und Gnd-Pins aktivieren
#
# wiring/BitExtender.java
#
extenderInAttr = Datenbits Eingang
extenderInputLabel = Eingang
extenderInputType = Eingang
extenderMainLabel = erweitern
extenderOneLabel = 1
extenderOneType = Eins
extenderOutAttr = Datenbits Ausgang
extenderSignLabel = Vorzeichen
extenderSignType = Vorzeichen
extenderTypeAttr = Art der Erweiterung
extenderZeroLabel = 0
extenderZeroType = Null
#
# wiring/Clock.java
#
clockComponent = Takt
clockHighAttr = Dauer H-Signal
clockLowAttr = Dauer L-Signal
clockPhaseAttr = Phasenverschiebung
#
# wiring/Constant.java
#
constantComponent = Konstante
constantValueAttr = Wert
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 Takt
clockDurationValue = %s Takte
durationLargeMessage = Wert darf höchstens %s sein.
durationSmallMessage = Wert muß mindestens %s sein.
freqInvalidMessage = Wert ist nicht ganzzahlig
PORDurationOneValue = 1 Sek
PORDurationValue = %s Sek
#
# wiring/Pin.java
#
PinCancel = Abbrechen
pinComponent = Pin
PinEnterDecimal = Dezimalzahl eingeben
PinEnterFloat = Gleitkommazahl eingeben
pinFrozenQuestion = Der Pin ist mit dem Zustand der höheren Ebene verknüpft. Einen neuen Schaltungszustand erstellen?
pinFrozenTitle = Der Pin ist in der höheren Ebene zugeordnet.
pinInputName = Eingang
pinInputToolTip = Eingangspin hinzufügen
PinOkay = OK
pinOutputAttr = Ausgang?
pinOutputName = Ausgang
pinOutputToolTip = Ausgangspin hinzufügen
pinPullAttr = Pull-Verhalten
pinPullDownOption = Pull-Down
pinPullNoneOption = Unverändert
pinPullUpOption = Pull-Up
pinResetValue = Startwert:
pinThreeStateAttr = Threestate?
#
# wiring/PowerOnReset.java
#
PowerOnResetComponent = POR
# ==> porLongName =
porHighAttr = POR-Zeit
# ==> PorSize =
# ==> porSizeMedium =
# ==> porSizeNarrow =
# ==> porSizeWide =
# ==> porTransition =
# ==> porHightoLow =
# ==> porLowToHigh =
#
# wiring/Probe.java
#
probeComponent = Testpunkt
#
# wiring/ProbeAttributes.java
#
probeNewPin = Pfeilformen
stdAppearanceAttr = Aussehen
#
# wiring/PullResistor.java
#
pullComponent = Pull-Widerstand
pullErrorType = Fehler
pullOneType = Eins
pullTypeAttr = Pull-Richtung
pullZeroType = Null
#
# wiring/Transistor.java
#
transistorNDrain = Drain: eine niedrige Quelle zieht den Drain nach unten (nur wenn das Gate hoch ist).
transistorNGate = Gate: wenn hoch, lässt der Strom durch den Transistor fließen.
transistorNSource = Quelle: eine niedrige Quelle zieht den Drain niedrig (nur wenn das Gate hoch ist).
transistorPDrain = Drain: eine hohe Quelle zieht den Drain nach oben (nur wenn das Gate niedrig ist).
transistorPGate = Gate: wenn niedrig, lässt der Strom durch den Transistor fließen.
transistorPSource = Quelle: eine hohe Quelle zieht den Drain hoch (nur wenn das Gate niedrig ist).
transistorTypeAttr = Type
transistorTypeN = N-Type
transistorTypeP = P-Type
#
# wiring/TransmissionGate.java
#
transmissionGateDrain = Ablauf: quellengesteuert, abhängig von p-Gate und n-Gate
transmissionGateNGate = n-gate: wenn niedrig, lässt die niedrige Quelle durch, um die Entwässerung zu erreichen.
transmissionGatePGate = p-gate: wenn hoch, lässt es zu, dass eine hohe Quelle durchströmt und abfließt.
transmissionGateSource = Quelle: steuert den Abfluss, abhängig von p-gate und n-gate
#
# wiring/Tunnel.java
#
tunnelComponent = Tunnel
#
# wiring/WiringLibrary.java
#
extenderComponent = Bit-Erweiterung
groundComponent = Masse
noConnectionComponent = Nicht anschließen
powerComponent = Versorgungsspannung
transistorComponent = Transistor
transmissionGateComponent = Übertragungsgatter
wiringLibrary = Verdrahtung
input.output.extra = Ein-/Ausgang Extra
