#
# arith/Adder.java
#
adderCarryInTip = Retenue en entrée : si 1, 1 est ajouté à la sortie
adderCarryOutTip = Retenue en sortie : 1 si la somme dépasse le nombre de bits disponibles
adderComponent = Additionneur
adderInputTip = Entrée : nombre à additionner
adderOutputTip = Sortie : la somme des entrées (plus la retenue en entrée)
#
# arith/Arithmetic.java
#
arithmeticLibrary = Arithmétique
#
# arith/BitAdder.java
#
bitAdderComponent = Additionneur bit à bit
bitAdderInputTip = Entrée : les bits à compter
bitAdderOutputManyTip = Sortie : combien de bits sont à 1
gateInputsAttr = Nombre d'entrées
#
# arith/BitFinder.java
#
bitFinderComponent = Recherche de bits
bitFinderFindLabel = trouver
bitFinderHighLabel = haut
bitFinderHighOption = Ordre le plus haut %s
bitFinderIndexHighTip = Index : index de l'entrée avec l'ordre le plus haut %s
bitFinderIndexLowTip = Index : index de l'entrée avec l'ordre le plus bas %s
bitFinderInputTip = Entrée : les bits à rechercher
bitFinderLowLabel = bas
bitFinderLowOption = Ordre le plus bas %s
bitFinderPresentTip = Présence : 1 si l'entrée contient un %s
bitFinderTypeAttr = Type
#
# arith/Comparator.java
#
comparatorComponent = Comparateur
comparatorEqualTip = Égal : 1 si A est égal à B
comparatorGreaterTip = Supérieur : 1 si A est plus grand que B
comparatorInputATip = A : membre de gauche de l'opération
comparatorInputBTip = B : membre de droite de l'opération
comparatorLessTip = Inférieur : 1 si A est plus petit que B
comparatorType = Type numérique
twosComplementOption = complément à 2
unsignedOption = Non signé
#
# arith/Divider.java
#
dividerComponent = Diviseur
dividerDividendLowerTip = numérateur bas : la moitié basse du nombre à diviser
dividerDividendUpperTip = numérateur haut: la moitié haute du nombre à diviser
dividerDivisorTip = Diviseur: dénominateur par lequel diviser
dividerOutputTip = Sortie : le résultat de la division du numérateur par le dénominateur
dividerRemainderOutput = reste
dividerRemainderTip = Reste : (numérateur - sortie * diviseur)
dividerUpperInput = numérateur
#
# arith/Multiplier.java
#
multiplierCarryInTip = Retenue en entrée: une valeur à ajouter à la sortie
multiplierCarryOutTip = Retenue en sortie: le bit de poids le plus fort du produit
multiplierComponent = Multiplicateur
multiplierInputTip = Entrée : l'un des nombres à multiplier
multiplierOutputTip = Sortie : le produit des entrées plus la retenue en entrée
#
# arith/Negator.java
#
negatorComponent = Inverseur
negatorInputTip = Entrée : le nombre à inverser
negatorOutputTip = Sortie : le complément à deux de l'inversion de l'entrée
#
# arith/Shifter.java
#
shiftArithmeticRight = Décalage arithmétique à droite
shifterComponent = Décalage
shifterDistanceTip = Distance : combien de décalage sur l'entrée
shifterInputTip = Entrée : les bits à décaler
shifterOutputTip = Sortie : résultat du décalage de l'entrée
shifterShiftAttr = Type de décalage
shiftLogicalLeft = Décalage logique à gauche
shiftLogicalRight = Décalage logique à droite
shiftRollLeft = Décalage rotation à gauche
shiftRollRight = Décalage rotation à droite
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Emprunt en entrée: si 1 la sortie est dminuée de 1
subtractorBorrowOutTip = Emprunt en sortie: 1 si la différence est négative
subtractorComponent = Soustracteur
subtractorMinuendTip = Minuende : le nombre dont on soustrait
subtractorOutputTip = Sortie : la différence entre le diminué et le soustrait
subtractorSubtrahendTip = Soustrahende : le nombre à soustraire du diminué
#
# base/Base.java
#
baseLibrary = Base
#
# base/Text.java
#
textComponent = Label
textFontAttr = Police
textHorzAlignAttr = Alignement horizontal
textHorzAlignCenterOpt = Centré
textHorzAlignLeftOpt = Gauche
textHorzAlignRightOpt = Droite
textTextAttr = Texte
textVertAlignAttr = Alignment vertical
textVertAlignBaseOpt = Base
textVertAlignBottomOpt = Fond
textVertAlignCenterOpt = Centre
textVertAlignTopOpt = Sommet
#
# base/VhdlParser.java
#
CannotFindEntityException = Impossible de trouver la déclaration d'entité
emptySourceException = Impossible de lire une constante vide
genericDeclarationException = Syntaxe de générique invalide
genericTypeException = Type de générique non supporté
genericValueException = Valeur par défaut de générique invalide
invalidTypeException = Type de port non valide
portDeclarationException = Syntaxe de port illégale
#
# Builtin.java
#
builtinLibrary = inclue
#
# gates/AndGate.java
#
andGateComponent = Porte AND
#
# gates/Buffer.java
#
bufferComponent = Tampon
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Tampon contrôlé
controlledControlOption = Position de la commande
controlledInverterComponent = Inverseur contrôlé
controlledLeftHanded = À gauche
controlledRightHanded = À droite
#
# gates/EvenParityGate.java
#
evenParityComponent = Parité paire
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/flottant
gateOutputAttr = Valeur de sortie
gateOutputZ1 = flottant/1
gateSizeNormalOpt = moyen
xorBehaviorAttr = Comportement multi-entrées
xorBehaviorOdd = Quand un nombre impaire sont Haut
xorBehaviorOne = Quand un seul est Haut
#
# gates/Gates.java
#
gatesLibrary = Portes logiques
#
# gates/NandGate.java
#
nandGateComponent = Porte NAND
#
# gates/NegateAttribute.java
#
gateNegateAttr = Inverseur %s
#
# gates/NorGate.java
#
norGateComponent = Porte NOR
#
# gates/NotGate.java
#
notGateComponent = Porte NOT
#
# gates/OddParityGate.java
#
oddParityComponent = Parité impaire
#
# gates/OrGate.java
#
orGateComponent = Porte OR
#
# gates/PLA.java
#
plaBitWidthIn = Largeur du foret en
plaBitWidthOut = Largeur du panneton vers l'extérieur
input = entrée
output = sortie
PLA = PLA
plaClickToEdit = (cliquer pour modifier)
plaEditMenuItem = Modifier le programme PLA...
plaProgram = Programme
#
# gates/PLATable.java
#
plaEditorTitle = Éditeur de programme PLA
plaFileCreateError = Impossible de créer le fichier.
plaFileOpenError = Impossible d'ouvrir le fichier.
plaLoadDialogTitle = Charger le programme PLA
plaLoadErrorTitle = Erreur de chargement du programme PLA
plaSaveDialogTitle = Enregistrer le programme PLA
plaSaveErrorTitle = Erreur d'enregistrement du programme PLA
#
# gates/XnorGate.java
#
xnorGateComponent = Porte XNOR
#
# gates/XorGate.java
#
xorGateComponent = Porte XOR
#
# InstanceComponent.java
#
KeywordNameError = Label est un mot clé réservé et ne peut pas être utilisé. Veuillez spécifier une étiquette différente.
MatchedLabelNameError = L'étiquette et le nom du composant ne peuvent pas être les mêmes (ils ne sont pas sensibles à la casse). Veuillez spécifier une étiquette différente du nom du composant.
#
# InstanceTextField.java
#
changeLabelAction = Changer l'étiquette
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = DIP-switch
nrOfSwitch = Nbr. interrupteurs
#
# io/DotMatrix.java
#
ioInputColumn = Colonnes
ioInputRow = Lignes
ioInputSelect = Sélectionner ligne/colonne
ioMatrixCols = Colonnes
ioMatrixInput = Format de l'entrée
ioMatrixPersistenceAttr = Persistence lumineuse
ioMatrixRows = Lignes
ioMatrixShape = Forme d'un point
ioShapeCircle = Circulaire
ioShapeSquare = Carrée
#
# io/extra/Buzzer.java
#
buzzerFrequecy = fréquence
buzzerVolume = volume
buzzerVolumeBitWidth = nombre de bits du volume
buzzerUnitDhz = dHz (0,1Hz)
enableSound = Activer le son
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Couleur de la bordure
bothOption = tous les deux
ClearDiagram = Effacer le graphique
DigitalOscilloscopeClock = horloge
DrawClockFrontLine = tracer le front de l'horloge
noOption = aucun
ShowClockAttribute = Afficher l'attribut horloge
stdTriggerFalling = Front descendant
stdTriggerRising = Front montant
#
# io/extra/ITA_IO.java
#
buzzerComponent = Buzzer
DigitalOscilloscopeComponent = Oscilloscope numérique
PlaRomComponent = PLA
Slider = Glissière
switchComponent = Interrupteur
#
# io/extra/PlaRom.java
#
memCSTip = Chip select: 0 désactive le composant
PlaANDAttr = Et
PlaOutputsAttr = Sortie
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = Fenêtre d'édition PLA %s
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Nombre d'états
ProgrammableGeneratorComponent = Générateur progressif
ramClearMenuItem = Effacer le contenu
ramEditMenuItem = Modifier le contenu...
romContentsAttr = Contenu
romContentsValue = (cliquer pour modifier)
#
# io/extra/Slider.java
#
left_to_rightOption = de gauche à droite
right_to_leftOption = de droite à gauche
#
# io/HexDigit.java
#
hexDigitDataTip = Données : semioctet à afficher en hexadécimal
hexDigitDPTip = Point décimal : allume le point décimal
#
# io/Io.java
#
buttonComponent = Bouton
dipswitchComponent = DIP-switch
dotMatrixComponent = Matrice de LEDs
hexDigitComponent = Afficheur hexadécimal
ioActiveAttr = Actif si haut ?
ioBackgroundColor = Couleur du fond
ioColorAttr = Couleur
ioLibrary = Entrée/Sortie
ioOffColor = Couleur éteinte
ioOnColor = Couleur allumée
joystickComponent = Joystick
ledComponent = LED
pioComponent = Port E/S
repLBComponent = Reptar Local Bus
RGBledComponent = LED RVB
sevenSegmentComponent = Afficheur 7 segments
ttyComponent = TTY
#
# io/Joystick.java
#
ioBitWidthAttr = Largeur données
#
# io/Keyboard.java
#
keybAvailTip = Disponible : 1 quand le tampon contient des caractères
keybBufferLengthAttr = Taille du tampon
keybClearTip = Clear : 1 vide le tampon
keybClockTip = Horloge : le front montant consomme le premier caractère du buffer
keybDesc = Clavier (capacité %s)
keybEnableTip = Read activé: 0 désactive l'horloge
keyboardComponent = Clavier
keybOutputTip = Données : Valeur ASCII du premier caractère du tampon
#
# io/PortIO.java
#
pioDirection = Type de port
pioInput = Entrées seulement
pioInputs = Entrées %s
pioIOMultiple = E/S (activation bit par bit)
pioIOSingle = E/S (activation globale)
pioNumber = Nombre de broches
pioOutEnable = Activer la sortie
pioOutEnables = Activer les sorties %s
pioOutput = Sorties seulement
pioOutputs = Sorties %s
#
# io/ReptarLocalBus.java
#
repLBTip = Pointe B
#
# io/RGBLed.java
#
BLUE = Entrée bleue
GREEN = Entrée verte
RED = Entrée rouge
#
# io/SevenSegment.java
#
DecimalPoint = Point décimal
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
SevenSegDP = Affiche le point décimal
#
# io/Tty.java
#
ttyClearTip = Clear : 1 efface l'écran
ttyClockTip = Clock : le front montant ajoute le caractère en entrée
ttyColsAttr = Colonnes
ttyDesc = TTY (%s lignes, %s colonnes)
ttyDescShort = TTY
ttyEnableTip = Write enable : 0 désactive l'horloge
ttyInputTip = Data : valeur ASCII du prochain character à écrire
ttyRowsAttr = Lignes
#
# io/Video.java
#
rgbVideoCLK = Horloge
rgbVideoColor = Modèle de couleur
rgbVideoComponent = Écran RVB
rgbVideoCursor = Curseur
rgbVideoData = Données dans le format %s
rgbVideoHeight = Hauteur
rgbVideoReset = Mode de réinitialisation
rgbVideoRST = Réinitialiser
rgbVideoScale = Échelle
rgbVideoWE = Écriture autorisée
rgbVideoWidth = Largeur
rgbVideoX = Coordonnée X
rgbVideoY = Coordonnée Y
#
# library/bcd2sevenseg.java
#
BCDValue = valeur BCD
BCD2SevenSegment = BCD vers 7 segments
#
# library/BFHPraktika.java
#
BFHMegaFunctions = Méga-fonctions BFH
Bin2BCD = Binaire vers BCD
#
# library/bin2bcd.java
#
BinaryDataBits = Bits de données binaires
BinaryInputTip = Entrée binaire
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Clock : mise à jour sur front montant
flipFlopNotQTip = Complément de l'état courant de la bascule
flipFlopPresetTip = Preset : si 1, passe la sortie à 1 de manière asynchrone
flipFlopQTip = État courant de la bascule
flipFlopResetTip = Clear : si 1, passe la sortie à 0 de manière asynchrone
#
# memory/Counter.java
#
counterCarryTip = Carry : est à 1 si la valeur atteinte le maximum (minimum si décrémente)
counterClockTip = Clock : mise à jour permise sur front montant
counterComponent = Compteur
counterDataTip = Data : valeur à charger dans le compteur
counterEnableLabel = ct
counterEnableTip = Count : si 1, le compteur s'incrémente (ou décrémente)
counterGoalAttr = Action en cas de dépassement
counterGoalContinue = Continue de compter
counterGoalLoad = Charger la valeur suivante
counterGoalStay = Rester à la valeur
counterGoalWrap = Reboucler
counterLabel = ctr
counterLoadTip = Load : si 1, charge à partir des données d'entrée
counterMaxAttr = Valeur max
counterQTip = Output : valeur actuelle du compteur
counterResetTip = Clear : si 1, remet à 0 de manière asynchrone
counterUpDownTip = UpDown : Si 1 incrémente, si 0 décremente
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = Bascule J-K
#
# memory/Mem.java
#
memAsyncRead = Lecture asynchrone :
memByte = Par adressage
memDual = Double
memEnables = Activation :
memLine = Par signal (Output Enable)
memLineSize = Taille de la ligne
memMisaligned = Autoriser accès non-aligné?
memOcto = Octo
memQuad = Quad
memRaw = Lecture après écriture
memReadBehav = Comportement de lecture
memSingle = Simple
memWar = Écriture après lecture
ramAddrWidthAttr = Largeur d'adresse
ramDataWidthAttr = Largeur des données
ramSelAttr = Sélection
stdTriggerHigh = Niveau haut
stdTriggerLow = Niveau bas
#
# memory/MemMenu.java
#
ramConfirmClearMsg = Êtes-vous sûr de vouloir remettre à zéro la mémoire ?
ramConfirmClearTitle = Confirmer l'effacement
ramLoadMenuItem = Charger l'image...
ramSaveMenuItem = Sauvegarder l'image...
#
# memory/Memory.java
#
dFlipFlopComponent = Bascule D
memoryLibrary = Mémoire / Séquentiel
tFlipFlopComponent = Bascule T
#
# memory/Ram.java
#
ramComponent = RAM
#
# memory/RamAppearance.java
#
memAddrTip = Address : emplacement accédé en mémoire
memDataTip = Data : valeur chargée depuis une adresse
memDataTip0 = Data : valeur chargée à partir de l'adresse 0
memDataTip1 = Data : valeur chargée à partir de l'adresse 1
memDataTip2 = Data : valeur chargée à partir de l'adresse 2
memDataTip3 = Data : valeur chargée à partir de l'adresse 3
ramByteEnableTip0 = Activation de l'octet 0
ramByteEnableTip1 = Activation de l'octet 1
ramByteEnableTip2 = Activation de l'octet 2
ramByteEnableTip3 = Activation de l'octet 3
ramClkTip = Clock : la valeur en mémoire change sur front montant
ramClrPin = Clear : a on met tous les emplacements de mémoire à 0
ramInTip = Input : valeur à charger à l'adresse
ramInTip0 = Input : valeur à stocker à l'adresse 0
ramInTip1 = Input : valeur à stocker à l'adresse 1
ramInTip2 = Input : valeur à stocker à l'adresse 2
ramInTip3 = Input : valeur à stocker à l'adresse 3
ramLETip0 = Activer la ligne pour l'adresse 0
ramLETip1 = Activer la ligne pour l'adresse 1
ramLETip2 = Activer la ligne pour l'adresse 2
ramLETip3 = Activer la ligne pour l'adresse 3
ramOETip = Load : si 1, charge de la mémoire vers la sortie
ramWETip = Store : si 1, stocke l'entrée dans la mémoire
#
# memory/RamAttributes.java
#
ramBidirDataBus = Bus bidirectionnel
ramByteEnables = Contrôle lecture/écriture
RamClearPin = Broche d'effacement
ramDataAttr = Type de bus de données
ramNoByteEnables = Mot entier en lecture/écriture seulement
ramSeparateDataBus = Deux bus monodirectionnels
ramTypeAttr = Type de RAM
ramTypeNonVolatile = non volatile
ramTypeVolatile = volatile
ramWithByteEnables = Utiliser les activations par octet
#
# memory/Random.java
#
randomClockTip = Clock : mise à jour sur front montant
randomComponent = Générateur aléatoire
randomLabel = aléatoire
randomNextTip = Enable : avance au suivant dans la séquence sur front montant
randomQTip = Output : nombre actuel de la séquence
randomResetTip = Clear : si 1, remet à la graine initiale de manière asynchrone
randomSeedAttr = Graine
randomWidthLabel = Largeur : %d
#
# memory/Register.java
#
registerClkTip = Clock : mise à jour sur front montant
registerClrTip = Clear : si 1, met à 0 de manière asynchrone
registerComponent = Registre
registerDTip = Data : valeur stockée lors du front montant
registerEnableTip = Enable : si 0, désactive les mises à jour
registerLabel = reg
registerQTip = Sortie : valeur actuelle du registre
registerShowInTab = Afficher dans l'onglet Registres
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = Editer le contenu de la ROM
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Clear: quand 1, remise à zéro complète et asynchrone
shiftRegClockTip = Clock: les valeurs peuvent changer avec le trigger
shiftRegInTip = Input: valeur à décaler dans le premier étage
shiftRegisterComponent = Registre à décalage
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Nombre d'étages
shiftRegLoadTip = Load: quand 1 (avec shift
shiftRegOutTip = Output: est le contenu du dernier étage
shiftRegParallelAttr = Chargement parallèle
shiftRegShiftTip = Shift: décalage désactivé quand 0
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Sélecteur de Bit
bitSelectorDataTip = Data
bitSelectorGroupAttr = Bits en sortie
bitSelectorOutputTip = Sortie: valeur du groupe de bits sélectionnés dans data
bitSelectorSelectTip = Select: identifie quel groupe de données est sélectionné
#
# plexers/Decoder.java
#
decoderEnableTip = Enable: si non 0, la sortie sélectionnée est à 1
decoderOutTip = Sortie %s
decoderSelectTip = Select: identifie quelle sortie est à 1
#
# plexers/Demultiplexer.java
#
demultiplexerEnableTip = Enable: si non 0, la sortie sélectionnée et l'entrée
demultiplexerInTip = Entrée
demultiplexerOutTip = Sortie %s
demultiplexerSelectTip = Select: identifie quelle sortie reçoit l'entrée
#
# plexers/Multiplexer.java
#
multiplexerEnableTip = Enable: si non 0, la sortie est l'entrée sélectionnée
multiplexerInTip = Entrée %s
multiplexerOutTip = Sortie
multiplexerSelectTip = Select: identifie l'entrée qui devient la sortie
#
# plexers/Plexers.java
#
decoderComponent = Decodeur
demultiplexerComponent = Demultiplexeur
gateSizeAttr = Dimension dessins
gateSizeNarrowOpt = étroit
gateSizeWideOpt = large
multiplexerComponent = Multiplexeur
plexerDisabledAttr = Désactivé les sorties
plexerDisabledFloating = Flottant
plexerDisabledZero = Zero
plexerEnableAttr = Inclure l'activation ?
plexerLibrary = De/Multiplexeurs,Encodeurs
plexerSelectBitsAttr = Select Bits
plexerSelectBottomLeftOption = Fond/Gauche
plexerSelectLocAttr = Selectionner l'emplacement
plexerSelectTopRightOption = Haut/Droite
plexerThreeStateAttr = Trois états ?
priorityEncoderComponent = Encodeur prioritaire
#
# plexers/PriorityEncoder.java
#
priorityEncoderEnableInTip = Activer l'entrée: 0 désactive le composant
priorityEncoderEnableOutTip = Activer la sortie: 1 si activé et aucune entrée est à 1
priorityEncoderGroupSignalTip = Group Select: 1 si activé et n'importe quelle entrée est à 1
priorityEncoderInTip = Entrée %s
priorityEncoderOutTip = Sortie: adresse du 1 avec le plus haut indexe
#
# StdAttr.java
#
ioLabelColorAttr = Couleur de l'étiquette
stdClassicAppearance = Logisim classique
stdDataWidthAttr = Largeur données
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Orientation
stdLabelAttr = Étiquette
stdLabelCenter = Centre
stdLabelFontAttr = Police de l'étiquette
stdLabelLocAttr = Emplacement de l'étiquette
stdLabelVisibility = Étiquette visible
stdLogisimEvolutionAppearance = Logisim-Evolution
stdTriggerAttr = Trigger
#
# tcl/Tcl.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = TCL content file
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = TCL REDS console
#
# tcl/TclGeneric.java
#
tclGeneric = TCL generic
tclInterfaceDefinition = TCL interface VHDL entity
tclInterfaceDefinitionValue = (cliquer pour éditer)
#
# ttl/AbstractTtlGate.java
#
GNDPin = Broche de terre %s
VCCPin = Broche VCC %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Suppression
DisplayDecoderComponent = Décodeur d'affichage
DisplayDecoderInTip = Entrée
DisplayDecoderOutTip = Sortie
ioMultiBit = multi bit
LampTestInTip = Entrée test lampe
LT = LT
memEnableLabel = en
RBI = RBI
RippleBlankingInputInTip = Entrée de suppression de l'ondulation
#
# ttl/TTL.java
#
ShowInternalStructure = Afficher la structure interne
TTL7400 = 7400 : quadruple porte NAND à 2 entrées
TTL7402 = 7402 : quad porte NOR 2 entrées quadruple
TTL7404 = 7404 : onduleur hexagonal
TTL7408 = 7408 : quad 2 entrées ET porte d'entrée
TTL7410 = 7410 : triple porte NAND à 3 entrées
TTL7411 = 7411 : triple 3 entrées ET porte d'entrée
TTL74125 = 74125 : tampon quadruple bus, sorties à trois états, validation négative
TTL7413 = 7413 : double porte NAND à 4 entrées (schmitt-trigger)
TTL7414 = 7414 : onduleur hexagonal (schmitt-trigger)
TTL74165 = 74165 : registre à décalage parallèle-à-série 8 bits
TTL74175 = 74175 : bascule quadruple en D, remise à zéro asynchrone
TTL7418 = 7418 : double porte NAND à 4 entrées (schmitt-trigger)
TTL7419 = 7419 : onduleur hexagonal (schmitt-trigger)
TTL7420 = 7420 : double porte NAND 4 entrées à 4 entrées
TTL7421 = 7421 : double 4 entrées ET porte d'entrée
TTL7424 = 7424 : quad 2 entrées NAND gate (schmitt-trigger)
TTL74266 = 74266 : quad porte XNOR 2 entrées quadruple
TTL7427 = 7427 : triple porte NOR à 3 entrées NOR
TTL74273 = 74273 : bascule octale en D avec bascule transparente
TTL74283 = 74283 : Additionneur complet binaire 4 bits
TTL7430 = 7430 : porte NAND simple à 8 entrées
TTL7432 = 7432 : quad 2 entrées OU porte OU
TTL7436 = 7436 : quad 2 entrées porte NOR 2 entrées
TTL74377 = 74377 : bascule octale D-Flipflop avec validation
TTL7442 = 7442 : BCD vers décodeur décimal
TTL7443 = 7443 : Excès-3 au décodeur décimal
TTL7444 = 7444 : Code Gray vers décimal
TTL7447 = 7447 : BCD vers décodeur 7 segments
TTL7451 = 7451 : porte double AND-OR-INVERT
TTL7454 = 7454 : Quatre portes ET-OU-OU-INVERTES larges
TTL7458 = 7458 : porte double AND-OR
TTL7464 = 7464 : 4-2-3-3-2 Porte AND-OR-INVERT
TTL7474 = 7474 : double D-Flipflops avec préréglage et clair
TTL7485 = 7485 : comparateur de grandeurs 4 bits
TTL7486 = 7486 : quadruple porte XOR à 2 entrées
VccGndPorts = Activer les ports Vcc et Gnd
#
# wiring/BitExtender.java
#
extenderInAttr = Largeur bus entrée
extenderInputLabel = entrée
extenderInputType = Entrée
extenderMainLabel = étendre
extenderOneLabel = 1
extenderOneType = Un
extenderOutAttr = Largeur bus sortie
extenderSignLabel = signé
extenderSignType = Signe
extenderTypeAttr = Type d'extension
extenderZeroLabel = 0
extenderZeroType = Zéro
#
# wiring/Clock.java
#
clockComponent = Horloge
clockHighAttr = Durée haute
clockLowAttr = Durée basse
#
# wiring/Constant.java
#
constantComponent = Constante
constantValueAttr = Valeur
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 tic
clockDurationValue = %s tics
durationLargeMessage = La valeur doit être %s ou moins.
durationSmallMessage = La valeur doit être au moins %s.
freqInvalidMessage = La valeur n'est pas un entier valide
PORDurationOneValue = 1 sec
PORDurationValue = %s secs
#
# wiring/Pin.java
#
PinCancel = Annuler
pinComponent = Broche
PinEnterDecimal = Entrer décimal
pinFrozenQuestion = La broche est lié à l'état du supercircuit. Créer un nouvel état pour le circuit ?
pinFrozenTitle = Broche attachée au super-circuit.
pinInputName = Entrée
pinInputToolTip = Ajouter une broche d'entrée
PinOkay = OK
pinOutputAttr = Sortie ?
pinOutputName = Sortie
pinOutputToolTip = Ajouter une broche de sortie
pinPullAttr = Comportement
pinPullDownOption = Rappel (pull-down)
pinPullNoneOption = Inchangé
pinPullUpOption = Tirage (pull-up)
pinThreeStateAttr = Trois états ?
#
# wiring/PowerOnReset.java
#
porHighAttr = Temps reset
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Sonde
#
# wiring/ProbeAttributes.java
#
probeNewPin = Formes de flèche
stdAppearanceAttr = Apparence
#
# wiring/PullResistor.java
#
pullComponent = Résistance de charge
pullErrorType = Erreur
pullOneType = Un
pullTypeAttr = Direction charge
pullZeroType = Zéro
#
# wiring/Transistor.java
#
transistorNDrain = drain: une source bas tirera le drain sur bas (uniquement lorsque la porte est haute)
transistorNGate = gate: à l'état haut, laisse passer le courant dans le transistor
transistorNSource = source: une source bas tirera le drain sur bas (seulement lorsque la porte est haute)
transistorPDrain = drain: une source haut tirera le drain haut (uniquement lorsque la porte est bas)
transistorPGate = gate: au niveau bas, laisse passer le courant à travers le transistor
transistorPSource = source: une source haut tirera le drain vers haut (uniquement lorsque la porte est bas)
transistorTypeAttr = Type
transistorTypeN = N-Type
transistorTypeP = P-Type
#
# wiring/TransmissionGate.java
#
transmissionGateDrain = drain: contrôlé par la source, en fonction du type de porte p ou n
transmissionGateNGate = n-gate: au niveau bas, laisse passer la source bas vers drain
transmissionGatePGate = p-gate: au niveau haut, laisse passer la source haut vers drain
transmissionGateSource = source: Contrôle le drain, en fonction du type de porte p ou n
#
# wiring/Tunnel.java
#
tunnelComponent = Tunnel
#
# wiring/Wiring.java
#
extenderComponent = Extension de bit
groundComponent = Masse
noConnectionComponent = Ne pas connecter
powerComponent = Alimentation
transistorComponent = Transistor
transmissionGateComponent = Porte de transmission
wiringGateAttr = Position de la porte
wiringGateBottomRightOption = Bas/droite
wiringGateTopLeftOption = Haut/gauche
wiringLibrary = Câblage


