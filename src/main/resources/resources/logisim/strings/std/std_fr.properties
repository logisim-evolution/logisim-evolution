#
# arith/Adder.java
#
adderCarryInTip = Retenue en entrée: si 1, 1 est ajouté à la sortie
adderCarryOutTip = Retenue en sortie: 1 si la somme dépasse le nombre de bits disponibles
adderComponent = Additionneur
adderInputTip = Entrée: nombre à additionner
adderOutputTip = Sortie: la somme des entrées (plus la retenue en entrée)
#
# arith/ArithmeticLibrary.java
#
arithmeticLibrary = Arithmétique
#
# arith/BitAdder.java
#
bitAdderComponent = Additionneur bit à bit
bitAdderInputTip = Entrée: les bits à compter
bitAdderOutputManyTip = Sortie: combien de bits sont à 1
gateInputsAttr = Nombre d'entrées
#
# arith/BitFinder.java
#
bitFinderComponent = Recherche de bits
bitFinderFindLabel = trouver
bitFinderHighLabel = haut
bitFinderHighOption = Ordre le plus haut %s
bitFinderIndexHighTip = Index: index de l'entrée avec l'ordre le plus haut %s
bitFinderIndexLowTip = Index: index de l'entrée avec l'ordre le plus bas %s
bitFinderInputTip = Entrée: les bits à rechercher
bitFinderLowLabel = bas
bitFinderLowOption = Ordre le plus bas %s
bitFinderPresentTip = Présence: 1 si l'entrée contient un %s
bitFinderTypeAttr = Type
#
# arith/Comparator.java
#
comparatorComponent = Comparateur
comparatorEqualTip = Égal: 1 si A est égal à B
comparatorGreaterTip = Supérieur: 1 si A est plus grand que B
comparatorInputATip = A: membre de gauche de l'opération
comparatorInputBTip = B: membre de droite de l'opération
comparatorLessTip = Inférieur: 1 si A est plus petit que B
comparatorType = Type numérique
twosComplementOption = complément à 2
unsignedOption = Non signé
#
# arith/Divider.java
#
dividerComponent = Diviseur
dividerDividendLowerTip = numérateur bas: la moitié basse du nombre à diviser
dividerDividendUpperTip = numérateur haut: la moitié haute du nombre à diviser
dividerDivisorTip = Diviseur: dénominateur par lequel diviser
dividerOutputTip = Sortie: le résultat de la division du numérateur par le dénominateur
dividerRemainderOutput = reste
dividerRemainderTip = Reste: (numérateur - sortie * diviseur)
dividerUpperInput = numérateur
#
# arith/FPAdder.java
#
fpAdderComponent = Additionneur à virgule flottante
fpAdderOutputTip = Sortie: la somme des entrées
fpErrorTip = Erreur: 1 si l'entrée ou la sortie est NaN
#
# arith/FPComparator.java
#
fpComparatorComponent = Comparateur à virgule flottante
#
# arith/FPDivider.java
#
fpDividerDividendTip = Dividende: le nombre à diviser
fpDividerComponent = Diviseur à virgule flottante
#
# arith/FPMultiplier.java
#
fpMultiplierComponent = Multiplicateur à virgule flottante
fpMultiplierOutputTip = Sortie: le produit des entrées
#
# arith/FPNegator.java
#
fpNegatorComponent = Négateur en virgule flottante
fpNegatorOutputTip = Négation de l'entrée
#
# arith/FPSubtractor.java
#
fpSubtractorComponent = Soustracteur à virgule flottante
#
# arith/FPToInt.java
#
ceilOption = Arrondi supérieur
floorOption = Arrondi inférieur
fpToIntComponent = Virgule flottante à integer
fpToIntInputTip = Entrée: la valeur virgule flottante à convertir
fpToIntOutputTip = Sortie: sortie signée contenant la valeur arrondie en virgule flottante.
fpToIntType = Mode de l'arrondi
roundOption = Arrondir au plus proche
truncateOption = Tronquer
#
# arith/IntToFP.java
#
intToFPComponent = Entier à virgule flottante
intToFPInputTip = Entrée: le nombre entier à convertir en virgule flottante
intToFPOutputTip = Sortie: la forme en virgule flottante de l'entrée
#
# arith/Multiplier.java
#
multiplierCarryInTip = Retenue en entrée: une valeur à ajouter à la sortie
multiplierCarryOutTip = Retenue en sortie: le bit de poids le plus fort du produit
multiplierComponent = Multiplicateur
multiplierInputTip = Entrée: l'un des nombres à multiplier
multiplierOutputTip = Sortie: le produit des entrées plus la retenue en entrée
#
# arith/Negator.java
#
negatorComponent = Inverseur
negatorInputTip = Entrée: le nombre à inverser
negatorOutputTip = Sortie: le complément à deux de l'inversion de l'entrée
#
# arith/Shifter.java
#
shiftArithmeticRight = Décalage arithmétique à droite
shifterComponent = Décalage
shifterDistanceTip = Distance: combien de décalage sur l'entrée
shifterInputTip = Entrée: les bits à décaler
shifterOutputTip = Sortie: résultat du décalage de l'entrée
shifterShiftAttr = Type de décalage
shiftLogicalLeft = Décalage logique à gauche
shiftLogicalRight = Décalage logique à droite
shiftRollLeft = Décalage rotation à gauche
shiftRollRight = Décalage rotation à droite
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Emprunt en entrée: si 1 la sortie est dminuée de 1
subtractorBorrowOutTip = Emprunt en sortie: 1 si la différence est négative
subtractorComponent = Soustracteur
subtractorMinuendTip = Minuende: le nombre dont on soustrait
subtractorOutputTip = Sortie: la différence entre le diminué et le soustrait
subtractorSubtrahendTip = Soustrahende: le nombre à soustraire du diminué
#
# base/BaseLibrary.java
#
baseLibrary = Base
#
# base/Text.java
#
textComponent = Label
textFontAttr = Police
textColorAttr = Couleur
textHorzAlignAttr = Alignement horizontal
textHorzAlignCenterOpt = Centré
textHorzAlignLeftOpt = Gauche
textHorzAlignRightOpt = Droite
textTextAttr = Texte
textVertAlignAttr = Alignment vertical
textVertAlignBaseOpt = Base
textVertAlignBottomOpt = Fond
textVertAlignCenterOpt = Centre
textVertAlignTopOpt = Sommet
#
# base/VhdlParser.java
#
CannotFindEntityException = Impossible de trouver la déclaration d'entité
emptySourceException = Impossible de lire une constante vide
genericDeclarationException = Syntaxe de générique invalide
genericTypeException = Type de générique non supporté
genericValueException = Valeur par défaut de générique invalide
invalidTypeException = Type de port non valide
portDeclarationException = Syntaxe de port illégale
portTypeException = Type de port non pris en charge: "%s". Veuillez utiliser uniquement "std_logic" et "std_logic_vector".
#
# Builtin.java
#
builtinLibrary = inclue
#
# gates/AndGate.java
#
andGateComponent = Porte AND
#
# gates/Buffer.java
#
bufferComponent = Tampon
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Tampon contrôlé
controlledControlOption = Position de la commande
controlledInverterComponent = Inverseur contrôlé
controlledLeftHanded = À gauche
controlledRightHanded = À droite
#
# gates/EvenParityGate.java
#
evenParityComponent = Parité paire
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/flottant
gateOutputAttr = Valeur de sortie
gateOutputZ1 = flottant/1
gateSizeNormalOpt = moyen
xorBehaviorAttr = Comportement multi-entrées
xorBehaviorOdd = Quand un nombre impaire sont Haut
xorBehaviorOne = Quand un seul est Haut
#
# gates/GatesLibrary.java
#
gatesLibrary = Portes logiques
#
# gates/NandGate.java
#
nandGateComponent = Porte NAND
#
# gates/NegateAttribute.java
#
gateNegateAttr = Inverseur %s
#
# gates/NorGate.java
#
norGateComponent = Porte NOR
#
# gates/NotGate.java
#
notGateComponent = Porte NOT
#
# gates/OddParityGate.java
#
oddParityComponent = Parité impaire
#
# gates/OrGate.java
#
orGateComponent = Porte OR
#
# gates/PLA.java
#
plaBitWidthIn = Largeur de donnée en entrée
plaBitWidthOut = Largeur de donnée en sortie
input = entrée
output = sortie
PLA = Réseau logique programmable (PLA)
plaClickToEdit = (cliquer pour modifier)
plaEditMenuItem = Modifier le programme PLA...
plaProgram = Programme
#
# gates/PLATable.java
#
plaEditorTitle = Editeur de programme PLA
plaFileCreateError = Impossible de créer le fichier.
plaFileOpenError = Impossible d'ouvrir le fichier.
plaLoadDialogTitle = Charger le programme PLA
plaLoadErrorTitle = Erreur de chargement du programme PLA
plaSaveDialogTitle = Enregistrer le programme PLA
plaSaveErrorTitle = Erreur d'enregistrement du programme PLA
plaExportButton = Exporter
plaImportButton = Importer
plaOKButton = Ok
plaCancelButton = Annuler
plaRemoveButton = Supprimer
plaAddRowButton = Ajout ligne
plaCommentsLabel = Commentaire
plaInputLabel = entrée
plaOutputLabel = sortie
plaFileIoException = PLA le fichier n'a pas de données.
plaInvalideInputBitError = PLA La ligne %s contiens un bit d'entré invalide %s.
plaInvalideOutputBitError = PLA La ligne %s contiens un bit de sortie invalide %s.
plaRowExactOutBitError = PLA La ligne %s doit avoir exactement %s bits de sortie.
plaRowExactInBitError = PLA La ligne %s doit avoir exactement %s bits d'entré.
plaRowMissingOutputError = PLA La ligne %s manque de sorties.
plaTableError = Erreur dans la table PLA
#
# gates/XnorGate.java
#
xnorGateComponent = Porte XNOR
#
# gates/XorGate.java
#
xorGateComponent = Porte XOR
#
# InstanceComponent.java
#
KeywordNameError = Label est un mot clé réservé et ne peut pas être utilisé. Veuillez spécifier une étiquette différente.
MatchedLabelNameError = L'étiquette et le nom du composant ne peuvent pas être les mêmes (ils ne sont pas sensibles à la casse). Veuillez spécifier une étiquette différente du nom du composant.
#
# InstanceTextField.java
#
changeLabelAction = Changer l'étiquette
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = DIP-switch
nrOfSwitch = Nbr. interrupteurs
#
# io/LedCluster.java
#
#
# io/DotMatrix.java
#
ioInputColumn = Colonnes
ioInputRow = Lignes
ioInputSelect = Sélectionner ligne/colonne
ioMatrixCols = Colonnes
ioMatrixInput = Format de l'entrée
ioMatrixPersistenceAttr = Persistance lumineuse
ioMatrixRows = Lignes
ioMatrixShape = Forme d'un pixel
ioShapeCircle = Circulaire
ioShapeSquare = Carrée
ioShapePaddedSquare = Carrée avec bordure
ioLedBarComponent = Bargraphes LED
ioLedBarSegments = Segments
ioLedBarInput = Format d'entrée
ioLedBarInputSeparated = Séparé
ioLedBarInputOneWire = Un fil
#
# io/extra/Buzzer.java
#
buzzerFrequecy = fréquence
buzzerVolume = volume
buzzerVolumeBitWidth = Largeur de donnée volume
buzzerUnitDhz = dHz (0,1Hz)
buzzerWaveform = Type de signal
buzzerSine = Sinusoïdal
buzzerSquare = Carré
buzzerSmoothLevel = Degré de lissage
buzzerSmoothWidth = Fenêtre de lissage
buzzerChannel = Canal
buzzerChannelBoth = Les deux
buzzerChannelLeft = Gauche
buzzerChannelRight = Droite
buzzerTriangle = Triangulaire
buzzerSawtooth = Dents de scie
buzzerNoise = Bruit blanc
buzzerDutyCycle = Rapport cyclique
enableSound = Activer le son
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Couleur de la bordure
bothOption = tous les deux
ClearDiagram = Effacer le graphique
DigitalOscilloscopeClock = horloge
DrawClockFrontLine = tracer le front de l'horloge
noOption = aucun
ShowClockAttribute = Afficher l'attribut horloge
stdTriggerFalling = Front descendant
stdTriggerRising = Front montant
#
# io/extra/ExtraIoLibrary.java
#
buzzerComponent = Buzzer
DigitalOscilloscopeComponent = Oscilloscope numérique
PlaRomComponent = Réseau logique programmable (PLA)
Slider = Glissière
switchComponent = Interrupteur
#
# io/extra/PlaRom.java
#
memCSTip = Chip select: 0 désactive le composant
PlaANDAttr = Nombre de portes Et
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = Fenêtre d'édition PLA %s
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Nombre d'états
ProgrammableGeneratorComponent = Générateur progressif
ramClearMenuItem = Effacer le contenu
ramEditMenuItem = Modifier le contenu...
romContentsAttr = Contenu
romContentsValue = (cliquer pour modifier)
#
# io/extra/Slider.java
#
left_to_rightOption = de gauche à droite
right_to_leftOption = de droite à gauche
#
# io/HexDigit.java
#
hexDigitDataTip = Données: semioctet à afficher en hexadécimal
hexDigitDPTip = Point décimal: allume le point décimal
#
# io/IoLibrary.java
#
buttonComponent = Bouton
dipswitchComponent = Interrupeur DIP
dotMatrixComponent = Matrice de LEDs
hexDigitComponent = Afficheur hexadécimal
ioActiveAttr = Actif si haut ?
ioBackgroundColor = Couleur du fond
ioColorAttr = Couleur
ioLibrary = Entrée/Sortie
ioOffColor = Couleur éteinte
ioOnColor = Couleur allumée
joystickComponent = Manette
ledComponent = LED
pioComponent = Port E/S
repLBComponent = Reptar Local Bus
RGBledComponent = LED RVB
sevenSegmentComponent = Afficheur 7 segments
ttyComponent = TTY
#
# io/Button.java
#
buttonPressAttr = Niveau logique
buttonPressActive = actif si pressé
buttonPressPassive = passif si pressé
#
# io/Joystick.java
#
ioBitWidthAttr = Largeur de donnée
joystickCoordinateX = Sortie: coordonnée x
joystickCoordinateY = Sortie: coordonnée y
#
# io/Keyboard.java
#
keybAvailTip = Disponible: 1 quand le tampon contient des caractères
keybBufferLengthAttr = Taille du tampon
keybClearTip = Clear: 1 vide le tampon
keybClockTip = Horloge: le front montant consomme le premier caractère du buffer
keybDesc = Clavier (capacité %s)
keybEnableTip = Read activé: 0 désactive l'horloge
keyboardComponent = Clavier
keybOutputTip = Données: Valeur ASCII du premier caractère du tampon
#
# io/PortIO.java
#
pioDirection = Type de port
pioInput = Entrées seulement
pioInputs = Entrées %s
pioIOMultiple = E/S (activation bit par bit)
pioIOSingle = E/S (activation globale)
pioNumber = Nombre de broches
pioOutEnable = Activer la sortie
pioOutEnables = Activer les sorties %s
pioOutput = Sorties seulement
pioOutputs = Sorties %s
#
# io/ReptarLocalBus.java
#
repLBTip = Pointe B
#
# io/RgbLed.java
#
BLUE = Entrée bleue
GREEN = Entrée verte
RED = Entrée rouge
#
# io/SevenSegment.java
#
DecimalPoint = Point décimal
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
SevenSegDP = Affiche le point décimal
#
# io/Telnet.java
#
telnetComponent = Telnet
telnetModeAttr = Utiliser protocole Telnet
telnetPortAttr = Port
# ==> telnetInTip =
# ==> telnetOutTip =
# ==> telnetClkTip =
# ==> telnetWriteTip =
# ==> telnetReadTip =
# ==> telnetAvailableTip =
#
# io/Tty.java
#
ttyClearTip = Clear: 1 efface l'écran
ttyClockTip = Clock: le front montant ajoute le caractère en entrée
ttyColsAttr = Colonnes
ttyDesc = TTY (%s lignes, %s colonnes)
ttyDescShort = TTY
ttyEnableTip = Write enable: 0 désactive l'horloge
ttyInputTip = Data: valeur ASCII du prochain character à écrire
ttyRowsAttr = Lignes
#
# io/Video.java
#
rgbVideoCLK = Horloge
rgbVideoColor = Modèle de couleur
rgbVideoComponent = Écran RVB
rgbVideoCursor = Curseur
rgbVideoData = Données dans le format %s
rgbVideoHeight = Hauteur
rgbVideoReset = Mode de réinitialisation
rgbVideoRST = Réinitialiser
rgbVideoScale = Échelle
rgbVideoWE = Écriture autorisée
rgbVideoWidth = Largeur
rgbVideoX = Coordonnée X
rgbVideoY = Coordonnée Y
#
# bfh/bcd2sevenseg.java
#
BCDValue = valeur BCD
BCD2SevenSegment = BCD vers 7 segments
#
# bfh/BfhLibrary.java
#
BFHMegaFunctions = Méga-fonctions BFH
Bin2BCD = Binaire vers BCD
#
# bfh/bin2bcd.java
#
BinaryDataBits = Bits de données binaires
BinaryInputTip = Entrée binaire
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Clock: mise à jour sur front montant
flipFlopNotQTip = Complément de l'état courant de la bascule
flipFlopPresetTip = Preset: si 1, passe la sortie à 1 de manière asynchrone
flipFlopQTip = État courant de la bascule
flipFlopResetTip = Clear: si 1, passe la sortie à 0 de manière asynchrone
#
# memory/Counter.java
#
counterCarryTip = Carry: est à 1 si la valeur atteinte le maximum (minimum si décrémente)
counterClockTip = Clock: mise à jour permise sur front montant
counterComponent = Compteur
counterDataTip = Data: valeur à charger dans le compteur
counterEnableLabel = ct
counterEnableTip = Count: si 1, le compteur s'incrémente (ou décrémente)
counterGoalAttr = Action en cas de dépassement
counterGoalContinue = Continue de compter
counterGoalLoad = Charger la valeur suivante
counterGoalStay = Rester à la valeur
counterGoalWrap = Reboucler
counterLabel = ctr
counterLoadTip = Load: si 1, charge à partir des données d'entrée
counterMaxAttr = Valeur max
counterQTip = Output: valeur actuelle du compteur
counterResetTip = Clear: si 1, remet à 0 de manière asynchrone
counterUpDownTip = UpDown: Si 1 incrémente, si 0 décremente
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = Bascule J-K
#
# memory/Mem.java
#
memAsyncRead = Lecture asynchrone:
memByte = Par byte
memDual = Double
memEnables = Activation:
memLine = Par ligne
memLineSize = Nombre de lignes
memMisaligned = Autoriser accès non-aligné ?
memOcto = Octo
memQuad = Quad
memRaw = Lecture après écriture
memReadBehav = Comportement de lecture
memSingle = Simple
memWar = Écriture après lecture
ramAddrWidthAttr = Largeur d'adresse
ramDataWidthAttr = Largeur de donnée
ramSelAttr = Polarité du select
stdTriggerHigh = Niveau haut
stdTriggerLow = Niveau bas
#
# memory/MemMenu.java
#
ramConfirmClearMsg = Êtes-vous sûr de vouloir remettre à zéro la mémoire ?
ramConfirmClearTitle = Confirmer l'effacement
ramLoadMenuItem = Charger l'image...
ramSaveMenuItem = Sauvegarder l'image...
#
# memory/MemoryLibrary.java
#
dFlipFlopComponent = Bascule D
memoryLibrary = Mémoire / Séquentiel
tFlipFlopComponent = Bascule T
#
# memory/Ram.java
#
ramComponent = RAM
#
# memory/RamAppearance.java
#
memAddrTip = Address: emplacement accédé en mémoire
memDataTip = Data: valeur chargée depuis une adresse
memDataTip0 = Data: valeur chargée à partir de l'adresse 0
memDataTip1 = Data: valeur chargée à partir de l'adresse 1
memDataTip2 = Data: valeur chargée à partir de l'adresse 2
memDataTip3 = Data: valeur chargée à partir de l'adresse 3
ramByteEnableTip0 = Activation de l'octet 0
ramByteEnableTip1 = Activation de l'octet 1
ramByteEnableTip2 = Activation de l'octet 2
ramByteEnableTip3 = Activation de l'octet 3
ramClkTip = Clock: la valeur en mémoire change au déclanchement
ramClrPin = Clear: à 1 réinitialise la mémoire à 0
ramInTip = Input: valeur à charger à l'adresse
ramInTip0 = Input: valeur à stocker à l'adresse 0
ramInTip1 = Input: valeur à stocker à l'adresse 1
ramInTip2 = Input: valeur à stocker à l'adresse 2
ramInTip3 = Input: valeur à stocker à l'adresse 3
ramLETip0 = Activer la ligne pour l'adresse 0
ramLETip1 = Activer la ligne pour l'adresse 1
ramLETip2 = Activer la ligne pour l'adresse 2
ramLETip3 = Activer la ligne pour l'adresse 3
ramOETip = Load: si 1, charge de la mémoire vers la sortie
ramWETip = Store: A l'activation stocke l'entrée dans la mémoire
#
# memory/RamAttributes.java
#
ramBidirDataBus = Bus bidirectionnel
ramByteEnables = Contrôle lecture/écriture
RamClearPin = Broche d'effacement
ramDataAttr = Type de bus de données
ramNoByteEnables = Mot entier en lecture/écriture seulement
ramSeparateDataBus = Deux bus omnidirectionnels
ramTypeAttr = Type de RAM
ramTypeNonVolatile = non volatile
ramTypeVolatile = volatile
ramWithByteEnables = Utiliser les activations par octet
#
# memory/Random.java
#
randomClockTip = Clock: mise à jour sur front montant
randomComponent = Générateur aléatoire
randomLabel = aléatoire
randomNextTip = Enable: avance au suivant dans la séquence sur front montant
randomQTip = Output: nombre actuel de la séquence
randomResetTip = Clear: si 1, remet à la graine initiale de manière asynchrone
randomSeedAttr = Graine
randomWidthLabel = Largeur: %d
#
# memory/Register.java
#
registerClkTip = Clock: mise à jour sur front montant
registerClrTip = Clear: si 1, met à 0 de manière asynchrone
registerComponent = Registre
registerDTip = Data: valeur stockée lors du front montant
registerEnableTip = Enable: si 0, désactive les mises à jour
registerLabel = reg
registerQTip = Sortie: valeur actuelle du registre
registerShowInTab = Afficher dans l'onglet Registres
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = Éditer le contenu de la ROM
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Clear: quand 1, remise à zéro complète et asynchrone
shiftRegClockTip = Clock: les valeurs peuvent changer avec le trigger
shiftRegInTip = Input: valeur à décaler dans le premier étage
shiftRegisterComponent = Registre à décalage
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Nombre d'étages
shiftRegLoadTip = Load: quand 1 (avec shift
shiftRegOutTip = Output: est le contenu du dernier étage
shiftRegParallelAttr = Chargement parallèle
shiftRegShiftTip = Shift: décalage désactivé quand 0
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Sélecteur de Bit
bitSelectorDataTip = Data
bitSelectorGroupAttr = Bits en sortie
bitSelectorOutputTip = Sortie: valeur du groupe de bits sélectionnés dans data
bitSelectorSelectTip = Select: identifie quel groupe de données est sélectionné
#
# plexers/Decoder.java
#
decoderEnableTip = Enable: si non 0, la sortie sélectionnée est à 1
decoderOutTip = Sortie %s
decoderSelectTip = Select: identifie quelle sortie est à 1
#
# plexers/Demultiplexer.java
#
demultiplexerEnableTip = Enable: si non 0, la sortie sélectionnée et l'entrée
demultiplexerInTip = Entrée
demultiplexerOutTip = Sortie %s
demultiplexerSelectTip = Select: identifie quelle sortie reçoit l'entrée
#
# plexers/Multiplexer.java
#
multiplexerEnableTip = Enable: si non 0, la sortie est l'entrée sélectionnée
multiplexerInTip = Entrée %s
multiplexerOutTip = Sortie
multiplexerSelectTip = Select: identifie l'entrée qui devient la sortie
#
# plexers/PlexersLibrary.java
#
decoderComponent = Decodeur
demultiplexerComponent = Demultiplexeur
gateSizeAttr = Dimension dessin
gateSizeNarrowOpt = étroit
gateSizeWideOpt = large
multiplexerComponent = Multiplexeur
plexerDisabledAttr = Désactiver les sorties
plexerDisabledFloating = Flottant
plexerDisabledZero = Zero
plexerEnableAttr = Inclure l'activation ?
plexerLibrary = De/Multiplexeurs,Encodeurs
plexerSelectBitsAttr = Largeur du select
plexerThreeStateAttr = Trois états ?
priorityEncoderComponent = Encodeur prioritaire
#
# plexers/PriorityEncoder.java
#
priorityEncoderEnableInTip = Activer l'entrée: 0 désactive le composant
priorityEncoderEnableOutTip = Activer la sortie: 1 si activé et aucune entrée est à 1
priorityEncoderGroupSignalTip = Group Select: 1 si activé et n'importe quelle entrée est à 1
priorityEncoderInTip = Entrée %s
priorityEncoderOutTip = Sortie: adresse du 1 avec le plus haut indexe
#
# StdAttr.java
#
ioLabelColorAttr = Couleur de l'étiquette
stdClassicAppearance = Logisim classique
stdDataWidthAttr = Largeur de donnée
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Orientation
stdFPDataWidthAttr = Dimension flottant
stdLabelAttr = Étiquette
stdLabelCenter = Centre
stdLabelFontAttr = Police de l'étiquette
stdLabelLocAttr = Emplacement de l'étiquette
stdLabelVisibility = Étiquette visible
stdLogisimEvolutionAppearance = Logisim-Evolution
stdTriggerAttr = Trigger
stdSelectLocAttr = Sélectionner l'emplacement
stdSelectBottomLeftOption = Fond/Gauche
stdSelectTopRightOption = Haut/Droite
#
# tcl/TclLibrary.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = TCL content file
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = TCL REDS console
#
# tcl/TclGeneric.java
#
tclGeneric = TCL generic
tclInterfaceDefinition = TCL interface VHDL entity
tclInterfaceDefinitionValue = (cliquer pour éditer)
#
# ttl/AbstractTtlGate.java
#
GNDPin = Broche de terre %s
VCCPin = Broche VCC %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Suppression
DisplayDecoderComponent = Décodeur d'affichage
DisplayDecoderInTip = Entrée
DisplayDecoderOutTip = Sortie
ioMultiBit = multi bit
LampTestInTip = Entrée test lampe
LT = LT
memEnableLabel = en
RBI = RBI
RippleBlankingInputInTip = Entrée de suppression de l'ondulation
#
# ttl/TtlLibrary.java
#
ShowInternalStructure = Afficher la structure interne
TTL7400 = 7400: quadruple porte NON-ET (NAND) à 2 entrées
TTL7402 = 7402: quadruple porte NON-OU (NOR) à 2 entrées
TTL7404 = 7404: six portes inverseuses NON (NOT)
TTL7408 = 7408: quadruple portes ET (AND) à deux entrées
TTL7410 = 7410: triple porte NON-ET (NAND) à 3 entrées
TTL7411 = 7411: triple porte ET (AND) à 3 entrées
TTL74125 = 74125: tampon quadruple bus, sorties à trois états, validation négative
TTL74151 = 74151: sélecteur de données de 8 lignes à 1 ligne
TTL74153 = 74153: sélecteur de données double de 4 lignes à 1 ligne
TTL74157 = 74157: sélecteur de données quadruple de 2 lignes à 1 ligne
TTL74158 = 74158: sélecteur quadruple de 2 lignes à 1 ligne, sorties inversées
TTL74138 = 74138: décodeur de 3 lignes à 8 lignes
TTL74139 = 74139: décodeur double de 2 lignes à 4 lignes
TTL7413 = 7413: double porte NON-ET (NAND) à 4 entrées (schmitt-trigger)
TTL7414 = 7414: six portes inverseuses NON (NOT) avec trigger de Schmitt
TTL74161 = 74161: compteur binaire 4 bits à comptage synchrone réinitialisable
TTL74163 = 74163: compteur binaire 4 bits synchrone, prépositionnable,réinitialisable
TTL74164 = 74164: registre à décalage 8 bits à sorties parallèles, réinitialisation asynchrone
TTL74165 = 74165: registre à décalage parallèle-à-série 8 bits
TTL74166 = 74166: registre à décalage 8 bits à préchargement parallèle synchrone,réinitialisation asynchrone
TTL74175 = 74175: quadruple bascule D, remise à zéro asynchrone
TTL7418 = 7418: double porte NON_ET (NAND) à 4 entrées (schmitt-trigger)
TTL74181 = 74181: Unité arithmétique et logique
TTL74182 = 74182: générateur de retenue anticipée
TTL7419 = 7419: six portes inverseuses NON (NOT) avec trigger de Schmitt
TTL74192 = 74192: compteur decompteur BCD,synchrone
TTL74193 = 74193: Compteur decompteur 4-bits binaire
# ==> TTL74194 =
TTL7420 = 7420: double porte NON-ET (NAND) à 4 entrées
TTL7421 = 7421: double porte  ET (AND) à 4 entrées
TTL7424 = 7424: quadruple porte NON_ET (NAND) à 2 entrées avec trigger de Schmitt
TTL74240 = 74240: tampon inverseur 8 bits avec sortie à trois états.
TTL74241 = 74241: tampon 8 bits avec sortie à trois états.
TTL74244 = 74244:  tampon 2 × 4 bits avec sortie à trois états.
TTL74245 = 74245: tampon bidirectionnel 8 bits avec sortie à trois états
TTL74266 = 74266: quadruple  2 entrées XNOR  (collecteur ouvert)
TTL7427 = 7427: triple porte NON-OU (NOR) à 3 entrées
TTL74273 = 74273: huit bascules D. bascule transparente
TTL74283 = 74283: additionneur complet binaire 4 bits
TTL74299 = 74299: registre à décalage universel de 8 bits avec sorties à 3 états
TTL7430 = 7430: porte NON_ET (NAND) simple à 8 entrées
TTL7432 = 7432: quadruple portes OU (OR) à 2 entrées
TTL7434 = 7434: six tampons non-inverseurs
TTL7436 = 7436: quadruple portes NON_OU (NOR) 2 entrées
TTL74377 = 74377: huit bascules D avec validation
TTL74381 = 74381: unité arithmétique et logique (ALU)
TTL7442 = 7442: BCD vers décodeur décimal
TTL7443 = 7443: décodeur 4 bits vers décimal incrémenté de 3
TTL7444 = 7444: Code Gray vers décimal
TTL7447 = 7447: BCD vers décodeur 7 segments
TTL7451 = 7451: double portes ET-OU-NON
TTL7454 = 7454: quadruple portes ET-OU-NON
TTL74541 = 74541: tampon 8 bits avec sortie à trois états.
TTL7458 = 7458: double portes ET-OU (AND-OR)
TTL7464 = 7464: 4-2-3-3-2 Porte ET-OU-NON
TTL74670 = 74670: banc de registre 4 fois 4 bits avec sorties trois-état
TTL747266 = 747266: quadruple portes XNOR 2 entrées
TTL7474 = 7474: deux bascules D prépositionnables et réinitialisables
TTL7485 = 7485: comparateur de magnitude 4 bits
TTL7486 = 7486: quadruple portes OU exclusif (XOR) à 2 entrées
TTL7487 = 7487 : 4 bits Vrai/complément, éléments zéro/un
VccGndPorts = Activer les ports Vcc et Gnd
#
# wiring/BitExtender.java
#
extenderInAttr = Largeur de donnée entrée
extenderInputLabel = entrée
extenderInputType = Entrée
extenderMainLabel = étendre
extenderOneLabel = 1
extenderOneType = Un
extenderOutAttr = Largeur de donnée sortie
extenderSignLabel = signé
extenderSignType = Signe
extenderTypeAttr = Type d'extension
extenderZeroLabel = 0
extenderZeroType = Zéro
#
# wiring/Clock.java
#
clockComponent = Horloge
clockHighAttr = Durée haute
clockLowAttr = Durée basse
clockPhaseAttr = Décalage de phase
#
# wiring/Constant.java
#
constantComponent = Constante
constantValueAttr = Valeur
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 tic
clockDurationValue = %s tics
durationLargeMessage = La valeur doit être %s ou moins.
durationSmallMessage = La valeur doit être au moins %s.
freqInvalidMessage = La valeur n'est pas un entier valide
PORDurationOneValue = 1 sec
PORDurationValue = %s secs
#
# wiring/Pin.java
#
# ==> pinBehaviorAttr =
PinCancel = Annuler
pinComponent = Broche
PinEnterDecimal = Saisie d'un décimal
PinEnterFloat = Saisie d'un flottant
pinFrozenQuestion = La broche est lié à l'état du supercircuit. Créer un nouvel état pour le circuit ?
pinFrozenTitle = Broche attachée au super-circuit.
pinInputName = Entrée
pinInputOption = Entrée
pinInputToolTip = Ajouter une broche d'entrée
PinOkay = OK
pinOutputName = Sortie
pinOutputOption = Sortie
pinOutputToolTip = Ajouter une broche de sortie
pinPullDownOption = Rappel (pull-down)
pinPullUpOption = Tirage (pull-up)
pinResetValue = Valeur initiale:
pinSimpleOption = Simple
pinTristateOption = Trois états
pinTypeAttr = Type
#
# wiring/PowerOnReset.java
#
PowerOnResetComponent = POR
porLongName = Reset démarrage
porHighAttr = Temps reset
PorSize = Format du dessins
porSizeMedium = Moyen
porSizeNarrow = Petit
porSizeWide = Grand
porTransition = Port transition
porHighToLow = Haut vers bas
porLowToHigh = Bas vers haut
#
# wiring/Probe.java
#
probeComponent = Sonde
#
# wiring/ProbeAttributes.java
#
probeNewPin = Forme de flèche
stdAppearanceAttr = Apparence
#
# wiring/PullResistor.java
#
pullComponent = Résistance de charge
pullErrorType = Erreur
pullOneType = Un
pullTypeAttr = Direction charge
pullZeroType = Zéro
#
# wiring/Transistor.java
#
transistorNDrain = drain: une source bas tirera le drain sur bas (uniquement lorsque la porte est haute)
transistorNGate = gate: à l'état haut, laisse passer le courant dans le transistor
transistorNSource = source: une source bas tirera le drain sur bas (seulement lorsque la porte est haute)
transistorPDrain = drain: une source haut tirera le drain haut (uniquement lorsque la porte est bas)
transistorPGate = gate: au niveau bas, laisse passer le courant à travers le transistor
transistorPSource = source: une source haut tirera le drain vers haut (uniquement lorsque la porte est bas)
transistorTypeAttr = Type
transistorTypeN = N-Type
transistorTypeP = P-Type
#
# wiring/TransmissionGate.java
#
transmissionGateDrain = drain: contrôlé par la source, en fonction du type de porte p ou n
transmissionGateNGate = n-gate: au niveau bas, laisse passer la source bas vers drain
transmissionGatePGate = p-gate: au niveau haut, laisse passer la source haut vers drain
transmissionGateSource = source: Contrôle le drain, en fonction du type de porte p ou n
#
# wiring/Tunnel.java
#
tunnelComponent = Tunnel
#
# wiring/WiringLibrary.java
#
extenderComponent = Extension de bit
groundComponent = Masse
noConnectionComponent = Ne pas connecter
powerComponent = Alimentation
transistorComponent = Transistor
transmissionGateComponent = Porte de transmission
wiringLibrary = Câblage
input.output.extra = Entrée/Sortie (extra)
