#
# arith/Adder.java
#
adderCarryInTip = Carry In: jeśli 1, do wyjścia dodana jest dodatkowa 1
adderCarryOutTip = Wykonaj: 1 jeśli suma przelewa dostępne bity
AdderComponent = żmija
adderInputTip = Wejście: jedna z liczb do dodania
adderOutputTip = Wyjście: suma wejść (plus carry in)
#
# arith/Arithmetic.java
#
arithmeticLibrary = Arytmetyka
#
# arith/BitAdder.java
#
bitAdderComponent = Sumator bitów
bitAdderInputTip = Wejście: bity do policzenia
bitAdderOutputManyTip = Wyjście: ile bitów wejściowych jest 1
gateInputsAttr = liczba wejść
#
# arith/BitFinder.java
#
bitFinderComponent = Wyszukiwarka Bitów
bitFinderFindLabel = znajdź
bitFinderHighLabel = wysoki
bitFinderHighOption = Najwyższa kolejność %s
bitFinderIndexHighTip = indeks: indeks najwyższego rzędu wejścia %s
bitFinderIndexLowTip = Indeks: indeks najniższego rzędu wejścia %s
bitFinderInputTip = Wejście: bity do przeszukania
bitFinderLowLabel = niski
bitFinderLowOption = Najniższa kolejność %s
bitFinderPresentTip = Obecny: 1 jeśli wejście zawiera %s
bitFinderTypeAttr = Typ
#
# arith/Comparator.java
#
comparatorComponent = komparator
comparatorEqualTip = Równy: 1 jeśli A jest równe B
comparatorGreaterTip = większy: 1 jeśli A jest większe niż B
comparatorInputATip = A: liczba poprzedzająca operację porównywania
comparatorInputBTip = B: numer następujący po operacji porównania
comparatorLessTip = Mniej: 1 jeżeli A jest mniejsze od B
comparatorType = Typ numeryczny
twosComplementOption = Uzupełnienie 2
unsignedOption = niepodpisany
#
# arith/Divider.java
#
dividerComponent = Dzielenie
dividerDividendLowerTip = Dolna Dywidenda: dolna połowa liczby do podziału
dividerDividendUpperTip = Górna Dywidenda: górna połowa liczby do podziału
dividerDivisorTip = dzielnik: liczba, o którą należy podzielić
dividerOutputTip = Wyjście: wynik dzielenia dywidendy przez dzielnik
dividerRemainderOutput = prz
dividerRemainderTip = Przypomnienie: reszta (dywidenda - wyjście * dzielnik)
dividerUpperInput = górny
#
# arith/Multiplier.java
#
multiplierCarryInTip = Carry In: kwota, którą należy dodać do wyjścia
multiplierCarryOutTip = Carry Out: górne bity produktu
multiplierComponent = Mnożnik
multiplierInputTip = Wejście: jedna z liczb do pomnożenia
multiplierOutputTip = Wyjście: iloczyn wejść i przeniesienia
#
# arith/Negator.java
#
negatorComponent = Negator
negatorInputTip = Wejście: liczba do zanegowania
negatorOutputTip = Wyjście: negacja obustronnego uzupełniania wejścia
#
# arith/Shifter.java
#
shiftArithmeticRight = Artmetyczna Racja
shifterComponent = Przesuwnik
shifterDistanceTip = Odległość: jak daleko przesunąć wejście
shifterInputTip = wejście: bity do przesunięcia
shifterOutputTip = Wyjście: wynik przesunięcia wejścia
ShifterShiftAttr = typ zmiany biegów
shiftLogicalLeft = Logiczne Lewo
shiftLogicalRight = Logiczne Prawo
shiftRollLeft = Obróć w lewo
shiftRollRight = Obróć w prawo
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Borrow In: jeżeli 1, produkcja jest zmniejszona o 1
subtractorBorrowOutTip = Borrow Out: 1 jeśli różnica daje wartość ujemną
subtractorComponent = Odejmowanie
subtractorMinuendTip = Odjemna: liczba, od której należy odjąć
subtractorOutputTip = Wyjście: różnica pomiędzy minuend a subtrahendem
subtractorSubtrahendTip = Odjemnik: liczba do odjęcia od minuendu
#
# base/Base.java
#
baseLibrary = Baza
#
# base/Text.java
#
textComponent = Etykieta
textFontAttr = Czcionka
textHorzAlignAttr = Wyrównanie poziome
textHorzAlignCenterOpt = Centrum
textHorzAlignLeftOpt = Lewy
textHorzAlignRightOpt = Prawo
textTextAttr = Tekst
textVertAlignAttr = Wyrównanie pionowe
textVertAlignBaseOpt = Baza
textVertAlignBottomOpt = Dół
textVertAlignCenterOpt = Centrum
textVertAlignTopOpt = Góra
#
# base/VhdlParser.java
#
CannotFindEntityException = Nie można znaleźć deklaracji podmiotu
emptySourceException = Nie można analizować pustej zawartości
genericDeclarationException = Nielegalna składnia generyków
genericTypeException = nieobsługiwany typ leków generycznych
genericValueException = Nierozpoznane leki generyczne wartość domyślna
invalidTypeException = Nieprawidłowy typ portu
portDeclarationException = Nielegalna składnia portowa
#
# Builtin.java
#
builtinLibrary = Wbudowany
#
# gates/AndGate.java
#
andGateComponent = Bramka AND
#
# gates/Buffer.java
#
bufferComponent = Bufor
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Bufor kontrolowany
controlledControlOption = Lokalizacja linii sterującej
controlledInverterComponent = Przetwornik sterowany
controlledLeftHanded = Leworęczny
controlledRightHanded = Praworęczny
#
# gates/EvenParityGate.java
#
evenParityComponent = Parzysty parytet
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/ruchome
gateOutputAttr = Wartość wyjściowa
gateOutputZ1 = ruchome/1
gateSizeNormalOpt = Średnie
xorBehaviorAttr = Zachowanie wielokrotnego wejścia
xorBehaviorOdd = Kiedy liczba nieparzysta jest włączona
xorBehaviorOne = Gdy jedno wejście jest włączone
#
# gates/Gates.java
#
gatesLibrary = Bramki
#
# gates/NandGate.java
#
nandGateComponent = Bramka NAND
#
# gates/NegateAttribute.java
#
gateNegateAttr = Negacja %s
#
# gates/NorGate.java
#
norGateComponent = Bramka NOR
#
# gates/NotGate.java
#
NotGateComponent = Bramka NOT
#
# gates/OddParityGate.java
#
oddParityComponent = Nieparzysty parytet
#
# gates/OrGate.java
#
orGateComponent = Bramka OR
#
# gates/PLA.java
#
Bit Width In = szerokość bitu wejściowego
Bit Width Out = Szerokość bitu wyjściowego
input = wejście
output = wyjście
PLA = PLA
plaClickToEdit = (kliknij, aby edytować)
plaEditMenuItem = Edycja programu PLA...
plaProgram = Program...
#
# gates/PLATable.java
#
plaEditorTitle = Edytor programu PLA
plaFileCreateError = Nie można utworzyć pliku.
plaFileOpenError = Nie można było otworzyć pliku.
plaLoadDialogTitle = Wczytaj program PLA.
plaLoadErrorTitle = Błąd ładowania programu PLA
plaSaveDialogTitle = Zapisz program PLA
plaSaveErrorTitle = Program do zapisywania błędów PLA
#
# gates/XnorGate.java
#
xnorGateComponent = Bramka XNOR
#
# gates/XorGate.java
#
xorGateComponent = Bramka XOR
#
# InstanceComponent.java
#
KeywordNameError = Etykieta jest zastrzeżonym słowem kluczowym i nie może być używana. Proszę podać inną etykietę.
MatchedLabelNameError = Etykieta i nazwa komponentu mogą nie być takie same (wielkość liter nie ma znaczenia). Proszę podać inną etykietę niż nazwa komponentu.
#
# InstanceTextField.java
#
changeLabelAction = Zmień etykietę
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = przełącznik DIP
nrOfSwitch = Numer przełącznika
#
# io/DotMatrix.java
#
ioInputColumn = Kolumny
ioInputRow = Rzędy
ioInputSelect = wybierz Rows/Columns
ioMatrixCols = Kolumny Matrycowe
ioMatrixInput = Format wejściowy
ioMatrixPersistenceAttr = Trwałość światła
ioMatrixRows = Rows Matrix
ioMatrixShape = Kropka
ioShapeCircle = Okrężnik
ioShapeSquare = kwadrat
#
# io/extra/Buzzer.java
#
buzzerFrequecy = częstotliwość
buzzerVolume = objętość
buzzerVolumeBitWidth = szerokość bitu głośności
dHz (0,1Hz) = dHz (0,1Hz)
enableSound = Włącz dźwięk
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Kolor granicy
bothOption = oba
ClearDiagram = Przejrzysty wykres
DigitalOscilloscopeClock = zegar
DrawClockFrontLine = narysuj linię frontu zegara
noOption = brak
ShowClockAttribute = Pokaż atrybut zegara
stdTriggerFalling = Spadająca krawędź
stdTriggerRising = Wzrastająca krawędź
#
# io/extra/ITA_IO.java
#
buzzerComponent = Brzęczyk
DigitalOscilloscopeComponent = cyfrowy oscyl.
PlaRomComponent = PLA
Slider = suwak
switchComponent = switch
#
# io/extra/PlaRom.java
#
memCSTip = Chip select: 0 wyłącza komponent
PlaANDAttr = I
PlaOutputsAttr = Wyjście
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = okno edycji PlaRom %s
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = liczba państw
ProgrammableGeneratorComponent = generator Progr.
ramClearMenuItem = Przejrzysta treść
ramEditMenuItem = Edytuj zawartość...
romContentsAttr = Treść
romContentsValue = (kliknij, aby edytować)
#
# io/extra/Slider.java
#
left_to_rightOption = od lewej do prawej
right_to_leftOption = od prawej do lewej
#
# io/HexDigit.java
#
hexDigitDataTip = Dane: nibble do wyświetlania w hex
hexDigitDPTip = DecimalPoint: zapala kropkę dziesiętną
#
# io/Io.java
#
buttonComponent = Przycisk
dipswitchComponent = Dipswitch
dotMatrixComponent = Matryca LED
hexDigitComponent = Wyświetlacz sześciocyfrowy
ioActiveAttr = Aktywne gdy wysoki?
ioBackgroundColor = Tło
ioColorAttr = Kolor
ioLibrary = Wejście/Wyjście
ioOffColor = Off Color
ioOnColor = On Color
joystickComponent = Joystick
ledComponent = LED
pioComponent = Port I/O
repLBComponent = Reptar Local Bus
RGBledComponent = RGBLED
sevenSegmentComponent = Wyświetlacz 7-Segmentowy
ttyComponent = TTY
#
# io/Joystick.java
#
ioBitWidthAttr = Szerokość bitu
#
# io/Keyboard.java
#
keybAvailTip = Dostępna: 1 gdy bufor zawiera znaki
keybBufferLengthAttr = Długość bufora
keybClearTip = Wyczyść: 1 opróżnia bufor
keybClockTip = Zegar: wyzwalacz zużywa przedni znak bufora
keybDesc = klawiatura (czapka buforowa. %s)
keybEnableTip = Read enable: 0 wyłącza zegar
keyboardComponent = Klawiatura
keybOutputTip = Dane: Wartość ASCII znaku frontu bufora
#
# io/PortIO.java
#
pioDirection = typ portu:
pioInput = Tylko wejścia
pioInputs = Inputs %s
pioIOMultiple = I/O (zezwolenie na każdy bit)
pioIOSingle = I/O (pojedyncze zezwolenie)
pioNumber = Liczba pinów
pioOutEnable = zezwolenie na wyjście
pioOutEnables = Wyjście umożliwia %s
pioOutput = Tylko wyjścia
pioOutputs = Wyjścia %s
#
# io/ReptarLocalBus.java
#
repLBTip = końcówka B
#
# io/RGBLed.java
#
NIEBIESKI = wejście niebieskie
ZIELONY = wejście zielone
RED = wejście czerwone
#
# io/SevenSegment.java
#
DecimalPoint = punkt dziesiętny
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
SevenSegDP = ma kropkę dziesiętną:
#
# io/Tty.java
#
ttyClearTip = Clear: 1 Clears screen
ttyClockTip = Zegar: wyzwalacz dodaje znak na wejściu
ttyColsAttr = Kolumny
ttyDesc = TTY (%s rzędów, %s cols)
ttyDescShort = TTY
ttyEnableTip = Aktywacja zapisu: 0 wyłącza zegar
ttyInputTip = Dane: Wartość ASCII kolejnego znaku do zapisu
ttyRowsAttr = Rows
#
# io/Video.java
#
rgbVideoCLK = Zegar
rgbVideoColor = Model kolorowy
rgbVideoComponent = RGB Video
rgbVideoCursor = Kursor
rgbVideoData = Dane w formacie %s
rgbVideoHeight = Wysokość
rgbVideoReset = Resetuj zachowanie
rgbVideoRST = Resetowanie
rgbVideoScale = Skala
rgbVideoWE = Write Enable
rgbVideoSzrokość = Szerokość
rgbVideoX = Współrzędna X
rgbVideoY = Y Współrzędna
#
# library/bcd2sevenseg.java
#
Wartość BCD = wartość BCD
BCD2SevenSegment = BCD do siedmiu segmentów
#
# biblioteka/BFHPraktika.java
#
BFH mega funkcje = BFH mega funkcje
Bin2BCD = Binairy do BCD
#
# library/bin2bcd.java
#
Bity danych binarnych = bity danych binarnych
BinairyInputTip = wejście Binairy
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Clock: aktualizacja stanu wyzwalacza
flipFlopNotQTip = Uzupełnienie aktualnego stanu klapki
flipFlopPresetTip = Wstępnie ustawiony: Kiedy 1, stan pinów na 1 asynchronicznie
flipFlopQTip = aktualny stan klapki
flipFlopResetTip = Wyczyść: Kiedy 1, stan pinu do 0 asynchronicznie
#
# memory/Counter.java
#
counterCarryTip = Nośność: wynosi 1, gdy wartość osiąga maksimum (minimum w przypadku dekrementowania)
counterClockTip = Zegar: wartość może być aktualizowana po wyzwoleniu
CounterComponent = Licznik
counterDataTip = Dane: wartość do załadowania do licznika
counterEnableLabel = ct
counterEnableTip = Włącz: gdy 1, licznik przyrostów lub dekadencji
counterGoalAttr = Działanie na przelewie
counterGoalContinue = Kontynuuj liczenie
counterGoalLoad = Załaduj następną wartość
counterGoalStay = Trzymaj się wartości
counterGoalWrap = Owiń się
counterLabel = ctr
counterLoadTip = Obciążenie: gdy 1, obciążenie z wprowadzania danych
counterMaxAttr = Wartość maksymalna
counterQTip = Wyjście: aktualna wartość licznika
counterResetTip = Clear: kiedy 1, resetuje się asynchronicznie do 0
counterUpDownTip = góra-dół: kiedy 1, licznik przyrostów, kiedy 0, licznik dekretacji
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
memAsyncRead = odczyt asynchroniczny:
memByte = Użycie bajtu umożliwia
memDual = Dual
memEnables = Włącza:
memLine = Linia użytkowa umożliwia
memLineSize = Rozmiar linii
memMisaligned = Pozwólcie sobie na to?
memOcto = Octo
memQuad = Quad
memRaw = Przeczytaj po napisaniu
memReadBehav = Przeczytaj zachowanie
memSingle = pojedynczy
memWar = Napisz po przeczytaniu
ramAddrWidthAttr = Adres Szerokość bitu
ramDataWidthAttr = Szerokość bitu danych
ramSelAttr = Wybierz
stdTriggerHigh = wysoki poziom
stdTriggerLow = niski poziom
#
# memory/MemMenu.java
#
ramConfirmClearMsg = Czy na pewno chcesz wyzerować pamięć?
ramConfirmClearTitle = Potwierdź Wyczyść
ramLoadMenuItem = Załaduj obraz...
ramSaveMenuItem = Zapisz obraz...
#
# memory/Memory.java
#
dFlipFlopComponent = D Flip-Flop
memoryLibrary = Pamięć
tFlipFlopComponent = T Flip-Flop
#
# memory/Ram.java
#
ramComponent = RAM
#
# memory/RamAppearance.java
#
memAddrTip = Adres: lokalizacja dostępna w pamięci
memDataTip = Dane: wartość załadowana z adresu
memDataTip0 = Dane: wartość załadowana z adresu+0
memDataTip1 = Dane: wartość załadowana z adresu+1
memDataTip2 = Dane: wartość załadowana z adresu+2
memDataTip3 = Dane: wartość załadowana z adresu+3
ramByteEnableTip0 = Bajt enable dla bajtu 0
ramByteEnableTip1 = Bajt enable dla bajtu 1
ramByteEnableTip2 = Bajt enable dla bajtu 2
ramByteEnableTip3 = Bajt enable dla bajtu 3
ramClkTip = Zegar: aktualizacja wartości pamięci przy wzroście od 0 do 1
ramClrPin = Clear: jeden ustawia wszystkie lokalizacje pamięci na 0
ramInTip = Wejście: wartość, która ma być zapisana pod adresem
ramInTip0 = Wejście: wartość do zapisania pod adresem+0
ramInTip1 = Wejście: wartość do zapisania pod adresem+1
ramInTip2 = Wejście: wartość do zapisania pod adresem+2
ramInTip3 = wejście: wartość, która ma być zapisana pod adresem+3
ramLETip0 = Włączenie linii dla adresu+0
ramLETip1 = zezwolenie na linię dla adresu+1
ramLETip2 = Włączenie linii dla adresu+2
ramLETip3 = Włączenie linii dla adresu+3
ramOETip = Obciążenie: jeżeli 1, to pamięć załadunkowa do wyjścia
ramWETip = Zapisz: jeśli 1, zapisz wejście do pamięci
#
# memory/RamAttributes.java
#
ramBidirDataBus = jedna dwukierunkowa magistrala danych
ramByteEnables = kontrola zapisu odczytu
RamClearPin = Użyj przezroczystej szpilki
ramDataAttr = implementacja magistrali danych
ramNoByteEnables = Całe słowo tylko do odczytu/zapisu
ramSeparateDataBus = Oddzielna magistrala danych do odczytu i zapisu
ramTypeAttr = typ Ram
RamTypeNonVolatile = nieulotny
RamTypeVolatile = lotny
ramWithByteEnables = Użycie bajtu umożliwia
#
# memory/Random.java
#
randomClockTip = Zegar: wartość może być aktualizowana po wyzwoleniu
randomComponent = Generator losowy
randomLabel = losowy
randomNextTip = Włączony: kroki do następnego w kolejności przy wyzwalaniu zegara.
randomQTip = Wyjście: bieżąca liczba w kolejności
randomResetTip = Clear: Kiedy 1, resetuje się asynchronicznie do początkowego ziarna.
randomSeedAttr = materiał siewny
randomWidthLabel = Szerokość: %d
#
# memory/Register.java
#
registerClkTip = Zegar: aktualizacja wartości przy wyzwalaniu
registerClrTip = Wyczyść: Kiedy 1, wartość pinu do 0 asynchronicznie
registerComponent = Rejestr
registerDTip = Dane: wartość zapisana na wyzwalaczu zegarowym
registerEnableTip = Włącz: Gdy 0, wyzwalacze zegara są nieskuteczne
registerLabel = reg
registerQTip = Wyjście: aktualna wartość rejestru
registerShowInTab = Pokaż w zakładce Registers
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = Edytuj zawartość ROMu
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Wyczyść: kiedy 1, resetuje wszystko do 0 asynchronicznie
shiftRegClockTip = Zegar: wartości mogą być aktualizowane przy wyzwalaniu
shiftRegInTip = wejście: wartość, która ma być przeniesiona do pierwszego etapu
shiftRegisterComponent = Rejestr zmian
shiftRegisterLabel1 = reg zmianowy
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = liczba etapów
shiftRegLoadTip = Obciążenie: kiedy 1 (z przesunięciem = 0), obciążenie wszystkich etapów z wejść
shiftRegOutTip = Wyjście: jest zawartością ostatniego etapu
shiftRegParallelAttr = Obciążenie równoległe
shiftRegShiftTip = Shift: zmiana jest wyłączona, gdy 0
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Selektor bitów
bitSelectorDataTip = Dane
bitSelectorGroupAttr = Bity wyjściowe
bitSelectorOutputTip = Wyjście: wartość wybranej grupy bitów z danych
bitSelectorSelectTip = Wybierz: określa, która grupa danych została wybrana.
#
# plexers/Decoder.java
#
DecoderEnableTip = Enable: jeśli nie 0, wybrane wyjście wynosi 1
DecoderOutTip = wyjście %s
DecoderSelectTip = Wybierz: określa, które wyjście jest 1
#
# plexers/Demultiplexer.java
#
demultiplexerEnableTip = Enable: gdy nie ma wartości 0, wybrane wyjście jest wejściem.
demultiplexerInTip = wejście
demultiplexerOutTip = wyjście %s
demultiplexerSelectTip = Wybierz: określa, które wyjście odbiera sygnał wejściowy
#
# plexers/Multiplexer.java
#
multiplexerEnableTip = Enable: jeśli nie 0, wyjście jest wybranym wejściem.
multiplexerInTip = wejście %s
multiplexerOutTip = wyjście
multiplexerSelectTip = Wybierz: określa, które wejście stanie się wyjściem.
#
# plexers/Plexers.java
#
DecoderComponent = Dekoder
demultiplexerComponent = Demultiplekser
gateSizeAttr = Rozmiar bramy
gateSizeNarrowOpt = Wąski
gateSizeWideOpt = Szeroki
multiplexerComponent = Multiplekser
plexerDisabledAttr = Wyłączone wyjście
plexerDisabledFloating = pływający
plexerDisabledZero = Zero
plexerEnableAttr = Dołączyć Enable?
plexerLibrary = Pleksery
plexerSelectBitsAttr = Wybór bitów
plexerSelectBottomLeftOption = Bottom/LeftOption
plexerSelectLocAttr = wybierz lokalizację
plexerSelectTopRightOption = góra/prawa
plexerThreeStateAttr = Trzy-Stany?
priorityEncoderComponent = Priorytetowy koder
#
# plexers/PriorityEncoder.java
#
priorityEncoderEnableInTip = Włącz wejście: 0 wyłącza komponent
priorityEncoderEnableOutTip = Włącz wyjście: 1 jeśli włączone, a żadne z wejść nie jest 1
priorityEncoderGroupSignalTip = Wybierz grupę: 1 jeśli jest włączony, a dowolne wejście ma wartość 1
priorityEncoderInTip = wejście %s
priorityEncoderOutTip = Wyjście: adres najwyżej indeksowanego 1 wejścia
#
# StdAttr.java
#
ioLabelColorAttr = Kolor etykiety
stdClassicAppearance = Klasyczny Logisim
stdDataWidthAttr = Bity danych
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Okładzina
stdLabelAttr = Etykieta
stdLabelCenter = Centrum
stdLabelFontAttr = Czcionka etykiety
stdLabelLocAttr = Lokalizacja etykiety
stdLabelVisibility = Etykieta Widoczna
stdLogisimEvolutionAppearance = Logisim-Evolution
stdTriggerAttr = Trigger
#
# tcl/Tcl.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = plik zawartości TCL
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = konsola TCL REDS
#
# tcl/TclGeneric.java
#
tclGeneric = TCL generic
tclInterfaceDefinition = interfejs TCL Podmiot VHDL
tclInterfaceDefinitionValue = (kliknij, aby edytować)
#
# ttl/AbstractTtlGate.java
#
GNDPin = Sworzeń uziemiający %s
VCCPin = pin VCC %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Wygaszenie
DisplayDecoderComponent = Dekoder wyświetlacza
DisplayDecoderInTip = wejście
DisplayDecoderOutTip = Wyjście
ioMultiBit = multi bit
LampTestInTip = wejście do testu lampy
LT = LT
memEnableLabel = pl
RBI = RBI
RippleBlankingInputInTip = wejście wygaszania tętnienia
#
# ttl/TTL.java
#
ShowInternalStructure = Pokaż strukturę wewnętrzną
TTL7400 = 7400: poczwórna bramka 2-wejściowa NAND
TTL7402 = 7402: poczwórna bramka 2-wejściowa NOR
TTL7404 = 7404: falownik sześciokątny
TTL7408 = 7408: quad 2-wejściowy I bramka
TTL7410 = 7410: potrójna bramka 3-wejściowa NAND
TTL7411 = 7411: potrójne 3 wejścia i bramka
TTL74125 = 74125: bufor czterobusowy, wyjścia trójstanowe, ujemne zezwolenie
TTL7413 = 7413: podwójna 4-wejściowa bramka NAND (schmitt-trigger)
TTL7414 = 7414: falownik sześciokątny (schmitt-trigger)
TTL74165 = 74165: 8-bitowy rejestr przesunięcia równoległego do szeregowego
TTL74175 = 74175: quad D-flipflop, reset asynchroniczny
TTL7418 = 7418: podwójna 4-wejściowa bramka NAND (schmitt-trigger)
TTL7419 = 7419: falownik sześciokątny (schmitt-trigger)
TTL7420 = 7420: podwójna 4-wejściowa bramka NAND
TTL7421 = 7421: podwójne 4 wejścia i brama
TTL7424 = 7424: poczwórna 2-wejściowa bramka NAND (schmitt-trigger)
TTL74266 = 74266: quad 2-wejściowa bramka XNOR
TTL7427 = 7427: potrójna bramka 3-wejściowa NOR
TTL74273 = 74273: ośmiokrotny D-Flipflop z przezroczystą klapką
TTL74283 = 74283: 4-bitowa binarna pełna adder
TTL7430 = 7430: pojedyncza 8-wejściowa bramka NAND
TTL7432 = 7432: poczwórna bramka 2-wejściowa OR
TTL7436 = 7436: poczwórna bramka 2-wejściowa NOR
TTL74377 = 74377: ośmiokątny D-Flipflop z zezwoleniem
TTL7442 = 7442: BCD do dekodera dziesiętnego
TTL7443 = 7443: Nadmiar-3 do dekodera dziesiętnego
TTL7444 = 7444: Dekoder szary do dekodera dziesiętnego
TTL7447 = 7447: dekoder BCD na 7-segmentowy
TTL7451 = 7451: podwójna brama AND-OR-INVERT
TTL7454 = 7454: Cztery szerokie bramy AND-OR-INVERT
TTL7458 = 7458: podwójna bramka AND-OR
TTL7464 = 7464: 4-2-3-2 bramka AND-OR-INVERT
TTL7474 = 7474: podwójne klapki D z ustawieniem wstępnym i przezroczystością
TTL7485 = 7485: 4-bitowy komparator wielkości
TTL7486 = 7486: quad 2-wejściowa bramka XOR
VccGndPorts = włączenie portów Vcc i Gnd
#
# wiring/BitExtender.java
#
extenderInAttr = Szerokość bitu w
extenderInputLabel = wejście
extenderInputType = wejście
extenderMainLabel = rozszerzyć
extenderOneLabel = 1
extenderOneType = Jeden
extenderOutAttr = Szerokość bitowa
extenderSignLabel = znak
extenderSignType = Znak
extenderTypeAttr = Typ rozszerzenia
extenderZeroLabel = 0
extenderZeroType = Zero
#
# wiring/Clock.java
#
clockComponent = Zegar
clockHighAttr = wysoki czas trwania
clockLowAttr = niski czas trwania
#
# wiring/Constant.java
#
constantComponent = Stała
constantValueAttr = Wartość
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 Tick
clockDurationValue = %s Kleszcze
durationLargeMessage = Wartość musi być %s lub mniejsza.
durationSmallMessage = Wartość musi wynosić co najmniej %s.
freqInvalidMessage = Wartość nie jest poprawną liczbą całkowitą.
PORDurationOneValue = 1 sek.
PORDurationValue = %s Seks
#
# wiring/Pin.java
#
PinCancel = Anuluj
pinComponent = Pin
PinEnterDecimal = Wprowadź wartości dziesiętne
pinFrozenQuestion = Pin jest przywiązany do stanu superukładu. Stworzyć nowy stan obwodu?
pinFrozenTitle = Pin połączony z super obwodem.
pinInputName = Wejście
pinInputToolTip = Dodaj pin wejściowy
PinOkay = OK
pinOutputAttr = Wyjście?
pinOutputName = Wyjście
pinOutputToolTip = Dodaj pin wyjściowy
pinPullAttr = Ciągnięcie
pinPullDownOption = Pociągnij w dół
pinPullNoneOption = Bez zmian
pinPullUpOption = Podciągnięcie
pinThreeStateAttr = Trzy-Stany?
#
# wiring/PowerOnReset.java
#
porHighAttr = POR-time
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Sonda
#
# wiring/ProbeAttributes.java
#
probeNewPin = Kształty strzałek
stdAppearanceAttr = Wygląd
#
# wiring/PullResistor.java
#
pullComponent = Rezystor ciągu
pullErrorType = Błąd
pullOneType = Jeden
pullTypeAttr = Kierunek ciągnienia
pullZeroType = Zero
#
# wiring/Transistor.java
#
transistorNDrain = odpływ: niskie źródło pociągnie za sobą niski odpływ (tylko gdy brama jest wysoka)
transistorNGate = bramka: gdy jest wysoki, pozwala na przepływ prądu przez tranzystor
transistorNSource = źródło: niskie źródło pociągnie za sobą niski odpływ (tylko gdy brama jest wysoka)
transistorPDrain = odpływ: wysokie źródło będzie wyciągać odpływ wysoko (tylko przy niskiej bramie)
transistorPGate = bramka: gdy jest niski, pozwala na przepływ prądu przez tranzystor
transistorPSource = źródło: wysokie źródło pociągnie za sobą wysoki odpływ (tylko gdy brama jest niska)
transistorTypeAttr = Typ
transistorTypeN = N-TypeN
transistorTypeP = P-TypeP
#
# wiring/TransmissionGate.java
#
transmissionGateDrain = odpływ: sterowany przez źródło, w zależności od p-gate i n-gate
transmissionGateNGate = n-gate: gdy jest niski, pozwala na przejście niskiego źródła do odpływu wody
transmissionGatePGate = p-gate: gdy jest wysoki, pozwala na przejście wysokiego źródła do odpływu wody
transmissionGateSource = źródło: steruje odpływem w zależności od p-gate i n-gate
#
# wiring/Tunnel.java
#
tunnelComponent = Tunel
#
# wiring/Wiring.java
#
extenderComponent = Extender bitów
groundComponent = Grunt
noConnectionComponent = Nie podłączaj
powerComponent = Moc
transistorComponent = Tranzystor
transmissionGateComponent = Brama transmisyjna
wiringGateAttr = lokalizacja bramy
wiringGateBottomRightOption = Dół/Prawo
wiringGateTopLeftOption = Górna/lewa strona
wiringLibrary = Okablowanie


