#
# Reviewed MOR: 2021-07-05 (WiP)
#
#
# arith/Adder.java
#
adderCarryInTip = Carry In: jeśli 1, do wyjścia dodana jest dodatkowa 1
adderCarryOutTip = Carry Out: 1 jeśli suma przekracza dostępne bity
adderComponent = Dodawanie
adderInputTip = Wejście: jedna z liczb do dodania
adderOutputTip = Wyjście: suma wejść (plus carry in)
#
# arith/ArithmeticLibrary.java
#
arithmeticLibrary = Arytmetyka
#
# arith/BitAdder.java
#
bitAdderComponent = Dodawanie bitów
bitAdderInputTip = Wejście: bity do policzenia
bitAdderOutputManyTip = Wyjście: ile bitów wejściowych jest równa 1
gateInputsAttr = liczba wejść
#
# arith/BitFinder.java
#
bitFinderComponent = Wyszukiwarka bitów
bitFinderFindLabel = znajdź
bitFinderHighLabel = wysoki
# bitFinderHighOption = Highest-order %s
#bitFinderHighOption = Najwyższa kolejność %s
# bitFinderIndexHighTip = Index: index of input's highest-order %s
#bitFinderIndexHighTip = indeks: indeks najwyższego rzędu wejścia %s
# bitFinderIndexLowTip = Index: index of input's lowest-order %s
#bitFinderIndexLowTip = Indeks: indeks najniższego rzędu wejścia %s
bitFinderInputTip = Wejście: bity do przeszukania
bitFinderLowLabel = niski
# bitFinderLowOption = Lowest-order %s
#bitFinderLowOption = Najniższa kolejność %s
bitFinderPresentTip = Obecne: 1 jeśli wejście zawiera %s
bitFinderTypeAttr = Typ
#
# arith/Comparator.java
#
comparatorComponent = Porównywanie
comparatorEqualTip = Równe: 1 jeśli A jest równe B
comparatorGreaterTip = Większe: 1 jeśli A jest większe niż B
comparatorInputATip = A: liczba poprzedzająca operację porównywania
comparatorInputBTip = B: numer następujący po operacji porównania
comparatorLessTip = Mniejsze: 1 jeżeli A jest mniejsze od B
comparatorType = Typ numeryczny
# twosComplementOption = 2's Complement
twosComplementOption = Uzupełnienie 2
unsignedOption = Bez znaku
#
# arith/Divider.java
#
dividerComponent = Dzielenie
dividerDividendLowerTip = Dolna dzielna: dolna połowa liczby do podzielenia
dividerDividendUpperTip = Górna dzielna: górna połowa liczby do podzielenia
dividerDivisorTip = Dzielnik: liczba, przez którą należy podzielić
dividerOutputTip = Wyjście: wynik dzielenia dzielnej przez dzielnik
# dividerRemainderOutput = rem
dividerRemainderOutput = reszta
dividerRemainderTip = Reszta: reszta (dzielna - wyjście * dzielnik)
dividerUpperInput = górna
#
# arith/FPAdder.java
#
fpAdderComponent = Dodawanie zmiennoprzecinkowe
fpAdderOutputTip = Wyjście: suma danych wejściowych
fpErrorTip = Błąd: 1 jeśli wejście lub wyjście nie jest liczbą
#
# arith/FPComparator.java
#
fpComparatorComponent = Porównywanie zmiennoprzecinkowe
#
# arith/FPDivider.java
#
fpDividerDividendTip = Dzielna: liczba od podzielenia
fpDividerComponent = Dzielenie zmiennoprzecinkowe
#
# arith/FPMultiplier.java
#
fpMultiplierComponent = Mnożenie zmiennoprzecinkowe
fpMultiplierOutputTip = Wyjście: iloczyn danych wejściowych
#
# arith/FPNegator.java
#
fpNegatorComponent = Inwersja zmiennoprzecinkowa
fpNegatorOutputTip = Wyjście: zanegowane dane wejściowe
#
# arith/FPSubtractor.java
#
fpSubtractorComponent = Odejmowanie zmiennoprzecinkowe
#
# arith/FPToInt.java
#
ceilOption = Zaokrąglaj w górę
floorOption = Zaokrąglaj w dół
# fpToIntComponent = Floating Point to Integer
fpToIntComponent = Liczba zmiennoprzecinkowa do całkowitej
fpToIntInputTip = Wejście: liczba zmiennoprzecinkowa do skonwertowania na całkowitą
fpToIntOutputTip = Output: signed output containing the rounded floating point value
fpToIntType = Sposób zaokrąglania
roundOption = Do najbliższej wartości
truncateOption = Obcinanie
#
# arith/IntToFP.java
#
intToFPComponent = Liczba całkowita do zmiennoprzecinkowej
# intToFPInputTip = Input: the integer to convert to floating point
# ==> intToFPInputTip =
# intToFPOutputTip = Output: the floating point form of the input
# ==> intToFPOutputTip =
#
# arith/Multiplier.java
#
# multiplierCarryInTip = Carry In: an amount to be added into the output
multiplierCarryInTip = Carry In: kwota, którą należy dodać do wyjścia
# multiplierCarryOutTip = Carry Out: the upper bits of the product
multiplierCarryOutTip = Carry Out: górne bity produktu
multiplierComponent = Mnożenie
# multiplierInputTip = Input: one of the numbers to multiply
multiplierInputTip = Wejście: jedna z liczb do pomnożenia
# multiplierOutputTip = Output: the product of the inputs, plus the carry in
multiplierOutputTip = Wyjście: iloczyn wejść i przeniesienia
#
# arith/Negator.java
#
negatorComponent = Negator
# negatorInputTip = Input: the number to be negated
negatorInputTip = Wejście: liczba do zanegowania
# negatorOutputTip = Output: the two's-complement negation of the input
negatorOutputTip = Wyjście: negacja obustronnego uzupełniania wejścia
#
# arith/Shifter.java
#
shiftArithmeticRight = Artmetyczne w prawo
shifterComponent = Przesuwnik
shifterDistanceTip = Odległość: o ile przesunąć dane wejściowe
shifterInputTip = Wejście: bity do przesunięcia
shifterOutputTip = Wyjście: wynik przesunięcia danych wejściowych
shifterShiftAttr = Rodzaj przesuwania
shiftLogicalLeft = Logiczne w lewo
shiftLogicalRight = Logiczne w prawo
shiftRollLeft = Rotacja w lewo
shiftRollRight = Rotacja w prawo
#
# arith/Subtractor.java
#
# subtractorBorrowInTip = Borrow In: if 1, output is decreased by 1
subtractorBorrowInTip = Borrow In: jeżeli 1, produkcja jest zmniejszona o 1
# subtractorBorrowOutTip = Borrow Out: 1 if the difference yields a negative value
subtractorBorrowOutTip = Borrow Out: 1 jeśli różnica daje wartość ujemną
# subtractorComponent = Subtractor
subtractorComponent = Odejmowanie
# subtractorMinuendTip = Minuend: the number from which to subtract
subtractorMinuendTip = Odjemna: liczba, od której należy odjąć
# subtractorOutputTip = Output: the difference of the minuend and the subtrahend
subtractorOutputTip = Wyjście: różnica pomiędzy minuend a subtrahendem
# subtractorSubtrahendTip = Subtrahend: the number to subtract from the minuend
subtractorSubtrahendTip = Odjemnik: liczba do odjęcia od minuendu
#
# base/BaseLibrary.java
#
baseLibrary = Baza
#
# base/Text.java
#
textComponent = Etykieta
textFontAttr = Czcionka
textHorzAlignAttr = Wyrównanie w poziomie
textHorzAlignCenterOpt = Środek
textHorzAlignLeftOpt = Lewy
textHorzAlignRightOpt = Prawo
textTextAttr = Tekst
textVertAlignAttr = Wyrównanie w pionie
textVertAlignBaseOpt = Baza
textVertAlignBottomOpt = Dół
textVertAlignCenterOpt = Środek
textVertAlignTopOpt = Góra
#
# base/VhdlParser.java
#
CannotFindEntityException = Nie można znaleźć deklaracji elementu
emptySourceException = Nie można przetwarzać pustej zawartości
# genericDeclarationException = Illegal generics syntax
genericDeclarationException = Nieprawidłowa składnia generyków
# genericTypeException = Unsupported generics type
genericTypeException = Hieobsługiwany typ generyczny
# genericValueException = Unrecognized generics default value
genericValueException = Nierozpoznana wartość domyślna generyka
invalidTypeException = Nieprawidłowy typ portu
portDeclarationException = Nielegalna składnia portowa
#
# Builtin.java
#
builtinLibrary = Wbudowany
#
# gates/AndGate.java
#
andGateComponent = AND (koniunkcja)
#
# gates/Buffer.java
#
bufferComponent = Bufor
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Bufor sterowany
controlledControlOption = Linia sterująca
controlledInverterComponent = Negator sterowany
controlledLeftHanded = Z lewej strony
controlledRightHanded = Z prawej strony
#
# gates/EvenParityGate.java
#
# evenParityComponent = Even Parity
#evenParityComponent = Parzysty parytet
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/pływające
gateOutputAttr = Wartość wyjściowa
gateOutputZ1 = Pływające/1
gateSizeNormalOpt = Średnia
# xorBehaviorAttr = Multiple-Input Behavior
#xorBehaviorAttr = Zachowanie wielu wejść
xorBehaviorOdd = Kiedy liczba nieparzysta jest włączona
xorBehaviorOne = Gdy jedno wejście jest włączone
#
# gates/GatesLibrary.java
#
gatesLibrary = Bramki
#
# gates/NandGate.java
#
nandGateComponent = NAND (zaprzeczony AND)
#
# gates/NegateAttribute.java
#
gateNegateAttr = Negacja %s
#
# gates/NorGate.java
#
norGateComponent = NOR (zaprzeczony OR)
#
# gates/NotGate.java
#
notGateComponent = NOT (negacja)
#
# gates/OddParityGate.java
#
# oddParityComponent = Odd Parity
#oddParityComponent = Nieparzysty parytet
#
# gates/OrGate.java
#
orGateComponent = OR (alternatywa)
#
# gates/PLA.java
#
plaBitWidthIn = Liczba bitów wejściowych
plaBitWidthOut = Liczba bitów wyjściowych
input = wejście
output = wyjście
PLA = PLA
plaClickToEdit = (kliknij, aby edytować)
plaEditMenuItem = Edytuj program PLA...
plaProgram = Program
#
# gates/PLATable.java
#
plaEditorTitle = Edytor programu PLA
plaFileCreateError = Nie można utworzyć pliku.
plaFileOpenError = Nie można było otworzyć pliku.
plaLoadDialogTitle = Wczytaj program PLA.
plaLoadErrorTitle = Błąd ładowania programu PLA
plaSaveDialogTitle = Zapisz program PLA
plaSaveErrorTitle = Program do zapisywania błędów PLA
#
# gates/XnorGate.java
#
xnorGateComponent = XNOR (zaprzeczony XOR)
#
# gates/XorGate.java
#
xorGateComponent = XOR (alternatywa wykluczająca)
#
# InstanceComponent.java
#
KeywordNameError = Etykieta nie może zawierać słów zastrzeżonych. Proszę podaj inną etykietę.
MatchedLabelNameError = Etykieta i nazwa komponentu nie mogą być takie same (wielkość liter nie ma znaczenia). Proszę podaj etykietę różną od nazwy komponentu.
#
# InstanceTextField.java
#
changeLabelAction = Zmień etykietę
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = Przełącznik DIP
nrOfSwitch = Liczba przełączników
#
# io/LedCluster.java
#
#
# io/DotMatrix.java
#
ioInputColumn = Kolumny
ioInputRow = Rzędy
ioInputSelect = Wybierane rzędy/kolumny
ioMatrixCols = Liczba kolumn
ioMatrixInput = Format wejścia
ioMatrixPersistenceAttr = Długość świecenia
ioMatrixRows = Liczba wierszy
ioMatrixShape = Kształt kropki
ioShapeCircle = Okrągła
ioShapeSquare = Kwadrat
# ioShapePaddedSquare = Padded Square
# ==> ioShapePaddedSquare =
ioLedBarComponent = Listwa LED
ioLedBarSegments = Liczba segmentów
ioLedBarInput = Format wejścia
ioLedBarInputSeparated = Rozdzielone
ioLedBarInputOneWire = Jeden przewód
#
# io/extra/Buzzer.java
#
# buzzerFrequecy = frequency
buzzerFrequecy = częstotliwość
# buzzerVolume = volume
buzzerVolume = objętość
buzzerVolumeBitWidth = liczba bitów głośności
# buzzerUnitDhz = dHz (0.1Hz)
# ==> buzzerUnitDhz =
# buzzerWaveform = Waveform
# ==> buzzerWaveform =
# buzzerSine = Sine
# ==> buzzerSine =
# buzzerSquare = Square
# ==> buzzerSquare =
# buzzerSmoothLevel = Smooth level
# ==> buzzerSmoothLevel =
# buzzerSmoothWidth = Smooth window width
# ==> buzzerSmoothWidth =
# buzzerChannel = Channel
# ==> buzzerChannel =
# buzzerChannelBoth = Both
# ==> buzzerChannelBoth =
# buzzerChannelLeft = Left
# ==> buzzerChannelLeft =
# buzzerChannelRight = Right
# ==> buzzerChannelRight =
# buzzerTriangle = Triangle
# ==> buzzerTriangle =
# buzzerSawtooth = Sawtooth
# ==> buzzerSawtooth =
# buzzerNoise = White noise
# ==> buzzerNoise =
# buzzerDutyCycle = Duty cycle
# ==> buzzerDutyCycle =
# enableSound = Enable sound
enableSound = Włącz dźwięk
# Hz = Hz
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
# BorderColor = Border color
BorderColor = Kolor granicy
# bothOption = both
bothOption = oba
ClearDiagram = Wyczyść wykres
DigitalOscilloscopeClock = zegar
# DrawClockFrontLine = draw clock front line
#DrawClockFrontLine = narysuj linię frontu zegara
noOption = brak
ShowClockAttribute = Pokaż atrybut zegara
stdTriggerFalling = Zbocze opadające
stdTriggerRising = Zbocze narastające
#
# io/extra/ExtraIoLibrary.java
#
buzzerComponent = Brzęczyk
DigitalOscilloscopeComponent = Oscyloskop cyfrowy
PlaRomComponent = PLA
Slider = Suwak
switchComponent = Przełącznik
#
# io/extra/PlaRom.java
#
memCSTip = Chip Select: 0 wyłącza komponent
PlaANDAttr = I
PlaOutputsAttr = Wyjście
# ramCSLabel = sel
#ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
# PlaEditWindowTitel = Pla Rom %s edit window
#PlaEditWindowTitel = okno edycji PlaRom %s
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Liczba stanów
ProgrammableGeneratorComponent = Generator programowalny
ramClearMenuItem = Wyczytść zawartość
ramEditMenuItem = Edytuj zawartość...
romContentsAttr = Zawartość
romContentsValue = (kliknij, aby edytować)
#
# io/extra/Slider.java
#
left_to_rightOption = od lewej do prawej
right_to_leftOption = od prawej do lewej
#
# io/HexDigit.java
#
hexDigitDataTip = Dane: nibble do wyświetlania
hexDigitDPTip = DecimalPoint: zapala kropkę dziesiętną
#
# io/IoLibrary.java
#
buttonComponent = Przycisk
dipswitchComponent = Przełącznik DIP
dotMatrixComponent = Matryca LED
hexDigitComponent = Wyświetlacz szesnastkowy
ioActiveAttr = Aktywne gdy wysoki?
ioBackgroundColor = Kolor tła
ioColorAttr = Kolor
ioLibrary = I/O
ioOffColor = Segment wyłączony
ioOnColor = Segment włączony
joystickComponent = Joystick
ledComponent = LED
pioComponent = Port I/O
# repLBComponent = Reptar Local Bus
#repLBComponent = Reptar Local Bus
RGBledComponent = RGB LED
sevenSegmentComponent = Wyświetlacz 7-segmentowy
ttyComponent = TTY
#
# io/Joystick.java
#
ioBitWidthAttr = Liczba bitów
joystickCoordinateX = Wyjście: Wartość X
joystickCoordinateY = Wyjście: Wartość Y
#
# io/Keyboard.java
#
# keybAvailTip = Available: 1 when buffer contains characters
keybAvailTip = Dostępna: 1 gdy bufor zawiera znaki
keybBufferLengthAttr = Rozmiar bufora
keybClearTip = Wyczyść: 1 czyści bufor
# keybClockTip = Clock: trigger consumes the buffer's front character
keybClockTip = Zegar: używa pierwszego znaku z bufora
keybDesc = klawiatura (wielkość bufora %s)
# keybEnableTip = Read enable: 0 disables clock
keybEnableTip = Read enable: 0 wyłącza zegar
keyboardComponent = Klawiatura
keybOutputTip = Dane: wartość ASCII pierwszego znaku z bufora
#
# io/PortIO.java
#
pioDirection = Typ portu:
pioInput = Tylko wejścia
pioInputs = Wejścia %s
# pioIOMultiple = I/O (per-bit enable)
#pioIOMultiple = I/O (zezwolenie na każdy bit)
# pioIOSingle = I/O (single enable)
#pioIOSingle = I/O (pojedyncze zezwolenie)
pioNumber = Liczba pinów
# pioOutEnable = Output enable
#pioOutEnable = zezwolenie na wyjście
# pioOutEnables = Output enables %s
#pioOutEnables = Wyjście umożliwia %s
pioOutput = Tylko wyjścia
pioOutputs = Wyjścia %s
#
# io/ReptarLocalBus.java
#
# repLBTip = B tip
repLBTip = Końcówka B
#
# io/RGBLed.java
#
BLUE = Wejście B
GREEN = Wejście G
RED = Wejście R
#
# io/SevenSegment.java
#
DecimalPoint = Kropka dziesiętna
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
SevenSegDP = Kropka dziesiętna:
#
# io/Tty.java
#
ttyClearTip = Clear: Jeśli 1, czyści ekran
ttyClockTip = Zegar: wyzwalacz dodaje znak z wejścia
ttyColsAttr = Kolumny
ttyDesc = TTY (%s rzędów, %s kolumn)
ttyDescShort = TTY
ttyEnableTip = Write Enable: 0 wyłącza zegar
ttyInputTip = Dane: Wartość ASCII kolejnego znaku do zapisu
ttyRowsAttr = Wiersze
#
# io/Video.java
#
rgbVideoCLK = Zegar
rgbVideoColor = Model barw
rgbVideoComponent = RGB Video
rgbVideoCursor = Kursor
rgbVideoData = Dane w formacie %s
rgbVideoHeight = Wysokość
rgbVideoReset = Tryb resetowania
rgbVideoRST = Resetowanie
rgbVideoScale = Skala
rgbVideoWE = Write Enable
rgbVideoWidth = Szerokość
rgbVideoX = Współrzędna X
rgbVideoY = Współrzędna Y
#
# bfh/bcd2sevenseg.java
#
BCDValue = Wartość BCD
BCD2SevenSegment = BCD do 7-segmentów
#
# bfh/BfhLibrary.java
#
# BFHMegaFunctions = BFH mega functions
BFHMegaFunctions = Mega funkcje BFH
Bin2BCD = Binarny do BCD
#
# bfh/bin2bcd.java
#
# BinaryDataBits = Binary data bits
#BinaryDataBits = bity danych binarnych
# BinaryInputTip = Binary input
#BinaryInputTip = wejście Binairy
#
# memory/AbstractFlipFlop.java
#
# flipFlopClockTip = Clock: state updates on trigger
#flipFlopClockTip = Clock: aktualizacja stanu wyzwalacza
# flipFlopNotQTip = Complement of current flip-flop state
#flipFlopNotQTip = Uzupełnienie aktualnego stanu klapki
# flipFlopPresetTip = Preset: When 1, pin state to 1 asynchronously
#flipFlopPresetTip = Wstępnie ustawiony: Kiedy 1, stan pinów na 1 asynchronicznie
# flipFlopQTip = Current flip-flop state
flipFlopQTip = Aktualny stan
# flipFlopResetTip = Clear: When 1, pin state to 0 asynchronously
#flipFlopResetTip = Wyczyść: Kiedy 1, stan pinu do 0 asynchronicznie
#
# memory/Counter.java
#
# counterCarryTip = Carry: is 1 when value reaches maximum (minimum if decrementing)
counterCarryTip = Nośność: wynosi 1, gdy wartość osiąga maksimum (minimum w przypadku dekrementowania)
# counterClockTip = Clock: value may update on trigger
counterClockTip = Zegar: wartość może być aktualizowana po wyzwoleniu
# counterComponent = Counter
counterComponent = Licznik
# counterDataTip = Data: value to load into counter
counterDataTip = Dane: wartość do załadowania do licznika
# counterEnableLabel = ct
counterEnableLabel = ct
# counterEnableTip = Enable: when 1, counter increments or decrements
counterEnableTip = Włącz: gdy 1, licznik przyrostów lub dekadencji
# counterGoalAttr = Action On Overflow
counterGoalAttr = Działanie na przelewie
# counterGoalContinue = Continue counting
counterGoalContinue = Kontynuuj liczenie
# counterGoalLoad = Load next value
counterGoalLoad = Załaduj następną wartość
# counterGoalStay = Stay at value
counterGoalStay = Trzymaj się wartości
# counterGoalWrap = Wrap around
counterGoalWrap = Owiń się
# counterLabel = ctr
counterLabel = ctr
# counterLoadTip = Load: when 1, loads from data input
counterLoadTip = Obciążenie: gdy 1, obciążenie z wprowadzania danych
# counterMaxAttr = Maximum Value
counterMaxAttr = Wartość maksymalna
# counterQTip = Output: current value of counter
counterQTip = Wyjście: aktualna wartość licznika
# counterResetTip = Clear: when 1, resets to 0 asynchronously
counterResetTip = Clear: kiedy 1, resetuje się asynchronicznie do 0
# counterUpDownTip = Up Down: when 1, counter increments, when 0, counter decrements
counterUpDownTip = góra-dół: kiedy 1, licznik przyrostów, kiedy 0, licznik dekretacji
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
memAsyncRead = Odczyt asynchroniczny:
# memByte = Use byte enables
#memByte = Użycie bajtu umożliwia
# memDual = Dual
memDual = Dual
# memEnables = Enables:
memEnables = Włącza:
# memLine = Use line enables
#memLine = Linia użytkowa umożliwia
# memLineSize = Line size
memLineSize = Rozmiar linii
# memMisaligned = Allow misaligned?
memMisaligned = Zezwalać nia brak wyrównania?
# memOcto = Octo
#memOcto = Octo
# memQuad = Quad
#memQuad = Quad
memRaw = Odczytaj po zapisie
memReadBehav = Sposób odczytu
memSingle = Pojedynczy
memWar = Zapisz po odczytaniu
ramAddrWidthAttr = Liczba bitów adresu
ramDataWidthAttr = Liczba bitów danych
# ramSelAttr = Select
ramSelAttr = Wybierz
stdTriggerHigh = Wysoki poziom
stdTriggerLow = Niski poziom
#
# memory/MemMenu.java
#
# ramConfirmClearMsg = Are you sure you wish to zero out the memory?
ramConfirmClearMsg = Czy na pewno chcesz wyzerować pamięć?
# ramConfirmClearTitle = Confirm Clear
ramConfirmClearTitle = Potwierdź Wyczyść
# ramLoadMenuItem = Load Image...
ramLoadMenuItem = Załaduj obraz...
# ramSaveMenuItem = Save Image...
ramSaveMenuItem = Zapisz obraz...
#
# memory/MemoryLibrary.java
#
# dFlipFlopComponent = D Flip-Flop
dFlipFlopComponent = D Flip-Flop
# memoryLibrary = Memory
memoryLibrary = Pamięć
# tFlipFlopComponent = T Flip-Flop
tFlipFlopComponent = T Flip-Flop
#
# memory/Ram.java
#
# ramComponent = RAM
ramComponent = RAM
#
# memory/RamAppearance.java
#
# memAddrTip = Address: location accessed in memory
memAddrTip = Adres: lokalizacja dostępna w pamięci
# memDataTip = Data: value loaded from address
memDataTip = Dane: wartość załadowana z adresu
# memDataTip0 = Data: value loaded from address+0
memDataTip0 = Dane: wartość załadowana z adresu+0
# memDataTip1 = Data: value loaded from address+1
memDataTip1 = Dane: wartość załadowana z adresu+1
# memDataTip2 = Data: value loaded from address+2
memDataTip2 = Dane: wartość załadowana z adresu+2
# memDataTip3 = Data: value loaded from address+3
memDataTip3 = Dane: wartość załadowana z adresu+3
# ramByteEnableTip0 = Byte enable for byte 0
ramByteEnableTip0 = Bajt enable dla bajtu 0
# ramByteEnableTip1 = Byte enable for byte 1
ramByteEnableTip1 = Bajt enable dla bajtu 1
# ramByteEnableTip2 = Byte enable for byte 2
ramByteEnableTip2 = Bajt enable dla bajtu 2
# ramByteEnableTip3 = Byte enable for byte 3
ramByteEnableTip3 = Bajt enable dla bajtu 3
# ramClkTip = Clock: memory value updates on rise from 0 to 1
ramClkTip = Zegar: aktualizacja wartości pamięci przy wzroście od 0 do 1
# ramClrPin = Clear: a one sets all memory locations to 0
ramClrPin = Clear: jeden ustawia wszystkie lokalizacje pamięci na 0
# ramInTip = Input: value to be stored at address
ramInTip = Wejście: wartość, która ma być zapisana pod adresem
# ramInTip0 = Input: value to be stored at address+0
ramInTip0 = Wejście: wartość do zapisania pod adresem+0
# ramInTip1 = Input: value to be stored at address+1
ramInTip1 = Wejście: wartość do zapisania pod adresem+1
# ramInTip2 = Input: value to be stored at address+2
ramInTip2 = Wejście: wartość do zapisania pod adresem+2
# ramInTip3 = Input: value to be stored at address+3
ramInTip3 = wejście: wartość, która ma być zapisana pod adresem+3
# ramLETip0 = Line enable for address+0
ramLETip0 = Włączenie linii dla adresu+0
# ramLETip1 = Line enable for address+1
ramLETip1 = zezwolenie na linię dla adresu+1
# ramLETip2 = Line enable for address+2
ramLETip2 = Włączenie linii dla adresu+2
# ramLETip3 = Line enable for address+3
ramLETip3 = Włączenie linii dla adresu+3
# ramOETip = Load: if 1, load memory to output
ramOETip = Obciążenie: jeżeli 1, to pamięć załadunkowa do wyjścia
# ramWETip = Store: if 1, store input to memory
ramWETip = Zapisz: jeśli 1, zapisz wejście do pamięci
#
# memory/RamAttributes.java
#
# ramBidirDataBus = One bidirectional data bus
ramBidirDataBus = jedna dwukierunkowa magistrala danych
# ramByteEnables = Read write control
ramByteEnables = kontrola zapisu odczytu
# RamClearPin = Use clear pin
RamClearPin = Użyj pinu czyszczenia
ramDataAttr = Implementacja szyny danych
ramNoByteEnables = Odczyt/zapis tylko całych słów
ramSeparateDataBus = Oddzielne szyny do odczytu i zapisu
ramTypeAttr = Typ pamięci
ramTypeNonVolatile = Nieulotna
ramTypeVolatile = ulotna
# ramWithByteEnables = Use byte enables
#ramWithByteEnables = Użycie bajtu umożliwia
#
# memory/Random.java
#
# randomClockTip = Clock: value may update on trigger
randomClockTip = Clock: wartość może się aktualizowanć po otrzymaniu sygnału
randomComponent = Generator losowy
randomLabel = losowy
randomNextTip = Enable: przechodzi do nastepnej wartości w sekwencji po otrzymaniu sygnału zegarowego.
randomQTip = Wyjście: bieżąca liczba w sekwencji
randomResetTip = Clear: Kiedy 1, resetuje zegar asynchronicznie do stanu początkowego.
randomSeedAttr = Stan początkowy
randomWidthLabel = Szerokość: %d
#
# memory/Register.java
#
# registerClkTip = Clock: value updates on trigger
#registerClkTip = Clock: aktualizacja wartości przy wyzwalaniu
# registerClrTip = Clear: When 1, pin value to 0 asynchronously
#registerClrTip = Wyczyść: Kiedy 1, wartość pinu do 0 asynchronicznie
registerComponent = Rejestr
# registerDTip = Data: value stored on clock trigger
#registerDTip = Dane: wartość zapisana na wyzwalaczu zegarowym
# registerEnableTip = Enable: When 0, clock triggers are ineffective
#registerEnableTip = Enable: Gdy 0, wyzwalacze zegara są nieskuteczne
# registerLabel = reg
#registerLabel = reg
#registerQTip = Wyjście: aktualna wartość rejestru
registerShowInTab = Pokaż w zakładce "Rejestry"
# registerWidthLabel = (%sb)
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = Edytuj zawartość ROMu
#
# memory/ShiftRegister.java
#
# shiftRegClearTip = Clear: when 1, resets all to 0 asynchronously
shiftRegClearTip = Clear: kiedy 1, resetuje wszystko do 0 asynchronicznie
# shiftRegClockTip = Clock: values may update on trigger
shiftRegClockTip = Clock: wartości mogą być aktualizowane przy wyzwalaniu
# shiftRegInTip = Input: value to be shifted into first stage
shiftRegInTip = Wejście: wartość, która ma być przeniesiona do pierwszego etapu
shiftRegisterComponent = Rejestr przesuwny
shiftRegisterLabel1 = rejestr przesuwny
# shiftRegisterLabel2 = %sx%s
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = liczba etapów
# shiftRegLoadTip = Load: when 1 (with shift = 0), all stages load from inputs
shiftRegLoadTip = LOAD: kiedy 1 (z przesunięciem równym 0), obciążenie wszystkich etapów z wejść
# shiftRegOutTip = Output: is content of last stage
shiftRegOutTip = Wyjście: zawartość ostatniego etapu
shiftRegParallelAttr = Ładowanie równoległe
# shiftRegShiftTip = Shift: shift is disabled when 0
shiftRegShiftTip = Shift: zmiana jest wyłączona, gdy 0
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Selektor bitów
bitSelectorDataTip = Dane
bitSelectorGroupAttr = Bity wyjściowe
bitSelectorOutputTip = Wyjście: wartość wybranej grupy bitów z danych
bitSelectorSelectTip = Wybierz: określa która grupa danych jest wybrana.
#
# plexers/Decoder.java
#
decoderEnableTip = Enable: gdy nie ma wartości 0, wybrane wyjście ma wartość 1
decoderOutTip = Wyjście %s
decoderSelectTip = Select: określa na którym wyjściu pojawi się 1
#
# plexers/Demultiplexer.java
#
# demultiplexerEnableTip = Enable: when not 0, selected output is input
demultiplexerEnableTip = Enable: gdy nie ma wartości 0, wybrane wyjście jest wejściem.
demultiplexerInTip = Wejście
demultiplexerOutTip = Wyjście %s
demultiplexerSelectTip = Select: określa, na którym wyjściu pojawi się sygnał wejściowy
#
# plexers/Multiplexer.java
#
multiplexerEnableTip = Enable: jeśli nie 0, wyjście jest wybranym wejściem.
multiplexerInTip = Wejście %s
multiplexerOutTip = Wyjście
multiplexerSelectTip = Select: określa, które wejście stanie się wyjściem.
#
# plexers/PlexersLibrary.java
#
decoderComponent = Dekoder
demultiplexerComponent = Demultiplekser
gateSizeAttr = Rozmiar bramki
gateSizeNarrowOpt = Wąska
gateSizeWideOpt = Szeroka
multiplexerComponent = Multiplekser
plexerDisabledAttr = Wyłączone wyjście
# plexerDisabledFloating = Floating
plexerDisabledFloating = pływające
plexerDisabledZero = Zero
plexerEnableAttr = Dołączyć Enable?
plexerLibrary = Pleksery
# plexerSelectBitsAttr = Select Bits
plexerSelectBitsAttr = Bitów wyboru
plexerThreeStateAttr = Trzystanowe?
# priorityEncoderComponent = Priority Encoder
#priorityEncoderComponent = Priorytetowy koder
#
# plexers/PriorityEncoder.java
#
# priorityEncoderEnableInTip = Enable Input: 0 disables the component
priorityEncoderEnableInTip = Włącz wejście: 0 wyłącza komponent
# priorityEncoderEnableOutTip = Enable Output: 1 if enabled and no inputs are 1
priorityEncoderEnableOutTip = Włącz wyjście: 1 jeśli włączone, a żadne z wejść nie jest 1
# priorityEncoderGroupSignalTip = Group Select: 1 if enabled and any input is 1
priorityEncoderGroupSignalTip = Wybierz grupę: 1 jeśli jest włączony, a dowolne wejście ma wartość 1
priorityEncoderInTip = Wejście %s
# priorityEncoderOutTip = Output: address of highest-indexed 1 input
priorityEncoderOutTip = Wyjście: adres najwyżej indeksowanego 1 wejścia
#
# StdAttr.java
#
ioLabelColorAttr = Kolor etykiety
stdClassicAppearance = Klasyczny Logisim
stdEvolutionAppearance = Logisim-HolyCross
stdLogisimEvolutionAppearance = Logisim-Evolution
stdDataWidthAttr = Bity danych
stdFacingAttr = Kierunek
stdFPDataWidthAttr = Liczba bitów liczby
stdLabelAttr = Etykieta
stdLabelCenter = Na środku
stdLabelFontAttr = Czcionka etykiety
stdLabelLocAttr = Lokalizacja etykiety
stdLabelVisibility = Etykieta widoczna
stdTriggerAttr = Trigger
stdSelectLocAttr = Wybierz lokalizację
stdSelectBottomLeftOption = Dół/Lewo
stdSelectTopRightOption = Góra/Prawo
#
# tcl/TclLibrary.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = Plik z zawartością TCL
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = Konsola TCL REDS
#
# tcl/TclGeneric.java
#
# tclGeneric = TCL generic
#tclGeneric = TCL generic
# tclInterfaceDefinition = TCL interface VHDL entity
#tclInterfaceDefinition = interfejs TCL Podmiot VHDL
tclInterfaceDefinitionValue = (kliknij, aby edytować)
#
# ttl/AbstractTtlGate.java
#
GNDPin = Pin uziemiający %s
VCCPin = Pin VCC %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Wygaszenie
DisplayDecoderComponent = Dekoder wyświetlacza
DisplayDecoderInTip = Wejście
DisplayDecoderOutTip = Wyjście
# ioMultiBit = multi bit
ioMultiBit = multi bit
# LampTestInTip = Lamp test input
#LampTestInTip = wejście do testu lampy
LT = LT
memEnableLabel = pl
RBI = RBI
# RippleBlankingInputInTip = Ripple blanking input
RippleBlankingInputInTip = Wejście wygaszające tętnienia
#
# ttl/TtlLibrary.java
#
ShowInternalStructure = Pokaż wewnętrze
# TTL7400 = 7400: quad 2-input NAND gate
TTL7400 = 7400: poczwórna bramka 2-wejściowa NAND
# TTL7402 = 7402: quad 2-input NOR gate
TTL7402 = 7402: poczwórna bramka 2-wejściowa NOR
# TTL7404 = 7404: hex inverter
TTL7404 = 7404: falownik sześciokątny
# TTL7408 = 7408: quad 2-input AND gate
TTL7408 = 7408: quad 2-wejściowy I bramka
# TTL7410 = 7410: triple 3-input NAND gate
TTL7410 = 7410: potrójna bramka 3-wejściowa NAND
# TTL7411 = 7411: triple 3-input AND gate
TTL7411 = 7411: potrójne 3 wejścia i bramka
# TTL74125 = 74125: quad bus buffer, three-state outputs, negative enable
TTL74125 = 74125: bufor czterobusowy, wyjścia trójstanowe, ujemne zezwolenie
# TTL74157 = 74157: quad 2-line to 1 line data selector
# ==> TTL74157 =
# TTL74158 = 74158: quad 2-line to 1 line data selector, inverted output
# ==> TTL74158 =
# TTL74139 = 74139: Dual 2-line to 4-line decoder
# ==> TTL74139 =
# TTL7413 = 7413: dual 4-input NAND gate(schmitt-trigger)
TTL7413 = 7413: podwójna 4-wejściowa bramka NAND (schmitt-trigger)
# TTL7414 = 7414: hex inverter (schmitt-trigger)
TTL7414 = 7414: falownik sześciokątny (schmitt-trigger)
# TTL74161 = 74161: 4-bit sync counter with clear
# ==> TTL74161 =
# TTL74165 = 74165: 8-bit parallel-to-serial shift register
TTL74165 = 74165: 8-bitowy rejestr przesunięcia równoległego do szeregowego
# TTL74175 = 74175: quad D-flipflop, asynchronous reset
TTL74175 = 74175: quad D-flipflop, reset asynchroniczny
# TTL7418 = 7418: dual 4-input NAND gate(schmitt-trigger)
TTL7418 = 7418: podwójna 4-wejściowa bramka NAND (schmitt-trigger)
# TTL7419 = 7419: hex inverter (schmitt-trigger)
TTL7419 = 7419: falownik sześciokątny (schmitt-trigger)
# TTL7420 = 7420: dual 4-input NAND gate
TTL7420 = 7420: podwójna 4-wejściowa bramka NAND
# TTL7421 = 7421: dual 4-input AND gate
TTL7421 = 7421: podwójne 4 wejścia i brama
# TTL7424 = 7424: quad 2-input NAND gate (schmitt-trigger)
TTL7424 = 7424: poczwórna 2-wejściowa bramka NAND (schmitt-trigger)
# TTL74266 = 74266: quad 2-input XNOR gate
TTL74266 = 74266: quad 2-wejściowa bramka XNOR
# TTL7427 = 7427: triple 3-input NOR gate
TTL7427 = 7427: potrójna bramka 3-wejściowa NOR
# TTL74273 = 74273: octal D-Flipflop with clear
TTL74273 = 74273: ośmiokrotny D-Flipflop z przezroczystą klapką
# TTL74283 = 74283: 4-bit binary full adder
TTL74283 = 74283: 4-bitowa binarna pełna adder
# TTL7430 = 7430: single 8-input NAND gate
TTL7430 = 7430: pojedyncza 8-wejściowa bramka NAND
# TTL7432 = 7432: quad 2-input OR gate
TTL7432 = 7432: poczwórna bramka 2-wejściowa OR
# TTL7434 = 7434: hex buffer gate
# ==> TTL7434 =
# TTL7436 = 7436: quad 2-input NOR gate
TTL7436 = 7436: poczwórna bramka 2-wejściowa NOR
# TTL74377 = 74377: octal D-Flipflop with enable
TTL74377 = 74377: ośmiokątny D-Flipflop z zezwoleniem
# TTL7442 = 7442: BCD to decimal decoder
TTL7442 = 7442: BCD do dekodera dziesiętnego
# TTL7443 = 7443: Excess-3 to decimal decoder
TTL7443 = 7443: Nadmiar-3 do dekodera dziesiętnego
# TTL7444 = 7444: Gray to decimal decoder
TTL7444 = 7444: Dekoder szary do dekodera dziesiętnego
# TTL7447 = 7447: BCD to 7-segment decoder
TTL7447 = 7447: dekoder BCD na 7-segmentowy
# TTL7451 = 7451: dual AND-OR-INVERT gate
TTL7451 = 7451: podwójna brama AND-OR-INVERT
# TTL7454 = 7454: Four wide AND-OR-INVERT gate
TTL7454 = 7454: Cztery szerokie bramy AND-OR-INVERT
# TTL7458 = 7458: dual AND-OR gate
TTL7458 = 7458: podwójna bramka AND-OR
# TTL7464 = 7464: 4-2-3-2 AND-OR-INVERT gate
TTL7464 = 7464: 4-2-3-2 bramka AND-OR-INVERT
# TTL7474 = 7474: dual D-Flipflops with preset and clear
TTL7474 = 7474: podwójne klapki D z ustawieniem wstępnym i przezroczystością
# TTL7485 = 7485: 4-bit magnitude comparator
TTL7485 = 7485: 4-bitowy komparator wielkości
# TTL7486 = 7486: quad 2-input XOR gate
TTL7486 = 7486: quad 2-wejściowa bramka XOR
# VccGndPorts = Enable Vcc and Gnd ports
VccGndPorts = włączenie portów Vcc i Gnd
#
# wiring/BitExtender.java
#
extenderInAttr = Bitów wejściowych
extenderInputLabel = wejście
extenderInputType = Wejście
extenderMainLabel = rozsz.
extenderOneLabel = 1
extenderOneType = Jeden
extenderOutAttr = Bitów wyjściowych
extenderSignLabel = znak
extenderSignType = Znak
extenderTypeAttr = Typ rozszerzania
extenderZeroLabel = 0
extenderZeroType = Zero
#
# wiring/Clock.java
#
clockComponent = Zegar
# clockHighAttr = High Duration
#clockHighAttr = Wysoki czas trwania
# clockLowAttr = Low Duration
#clockLowAttr = Niski czas trwania
# clockPhaseAttr = Phase Offset
clockPhaseAttr = Przesunięcie fazowe
#
# wiring/Constant.java
#
constantComponent = Stała
constantValueAttr = Wartość
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 tyknięcie
clockDurationValue = %s tyknięć
durationLargeMessage = Wartość musi być %s lub mniejsza.
durationSmallMessage = Wartość musi wynosić co najmniej %s.
freqInvalidMessage = Wartość nie jest poprawną liczbą całkowitą.
PORDurationOneValue = 1 sekunda
PORDurationValue = %s sekund
#
# wiring/Pin.java
#
PinCancel = Anuluj
pinComponent = Pin
PinEnterDecimal = Wprowadź wartości dziesiętne
PinEnterFloat = Wprowadz wartości zmiennoprzecinkowe
# pinFrozenQuestion = The pin is tied to the super circuit's state. Create a new circuit state?
pinFrozenQuestion = Pin jest przypisany do stanu superobwodu. Czy stworzyć nowy stan obwodu?
pinFrozenTitle = Pin przypisany do super obwodu.
pinInputName = Wejście
pinInputToolTip = Dodaj pin wejściowy
PinOkay = OK
pinOutputAttr = Wyjście?
pinOutputName = Wyjście
pinOutputToolTip = Dodaj pin wyjściowy
pinPullAttr = Rodzaj ściągania
pinPullDownOption = Ściągnij w dół
pinPullNoneOption = Bez zmian
pinPullUpOption = Podciągnij do góry
pinThreeStateAttr = Trzystanowe?
#
# wiring/PowerOnReset.java
#
# porHighAttr = POR-time
porHighAttr = Czas POR
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Sonda
#
# wiring/ProbeAttributes.java
#
probeNewPin = Kształty strzałek
stdAppearanceAttr = Wygląd
#
# wiring/PullResistor.java
#
pullComponent = Rezystor ściągający
pullTypeAttr = Ściąganie
pullErrorType = Błąd
pullOneType = Do jedynki
pullZeroType = Do zera
#
# wiring/Transistor.java
#
# transistorNDrain = drain: a low source will pull drain low (only when gate is high)
transistorNDrain = odpływ: niskie źródło pociągnie za sobą niski odpływ (tylko gdy brama jest wysoka)
# transistorNGate = gate: when high, allows current to flow through transistor
transistorNGate = bramka: gdy jest wysoki, pozwala na przepływ prądu przez tranzystor
# transistorNSource = source: a low source will pull drain low (only when gate is high)
transistorNSource = źródło: niskie źródło pociągnie za sobą niski odpływ (tylko gdy brama jest wysoka)
# transistorPDrain = drain: a high source will pull drain high (only when gate is low)
transistorPDrain = odpływ: wysokie źródło będzie wyciągać odpływ wysoko (tylko przy niskiej bramie)
# transistorPGate = gate: when low, allows current to flow through transistor
transistorPGate = bramka: gdy jest niski, pozwala na przepływ prądu przez tranzystor
# transistorPSource = source: a high source will pull drain high (only when gate is low)
transistorPSource = źródło: wysokie źródło pociągnie za sobą wysoki odpływ (tylko gdy brama jest niska)
# transistorTypeAttr = Type
transistorTypeAttr = Typ
# transistorTypeN = N-Type
transistorTypeN = N-TypeN
# transistorTypeP = P-Type
transistorTypeP = P-TypeP
#
# wiring/TransmissionGate.java
#
transmissionGateDrain = Odpływ: sterowany przez źródło, w zależności od p-gate i n-gate
transmissionGateNGate = Bramka N: gdy ma niski stan, pozwala na przejście niskiego sygnału ze źródła do odpływu
transmissionGatePGate = Bramka P: gdy ma stan wysoki, pozwala na przejście wysokiego sygnału ze źródła do odpływu
transmissionGateSource = Żródło: steruje odpływem w zależności od stanu bramki P i N
#
# wiring/Tunnel.java
#
tunnelComponent = Tunel
#
# wiring/WiringLibrary.java
#
# extenderComponent = Bit Extender
extenderComponent = Extender bitów
groundComponent = Masa
noConnectionComponent = Nie podłączaj
powerComponent = Zasilanie
transistorComponent = Tranzystor
# transmissionGateComponent = Transmission Gate
#transmissionGateComponent = Brama transmisyjna
wiringLibrary = Przewody
input.output.extra = I/O Extra
