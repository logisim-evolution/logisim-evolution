#
# arith/Adder.java
#
adderCarryInTip = Carry In: jeśli 1, do wyjścia dodana jest dodatkowa 1
adderCarryOutTip = Carry Out: 1 jeśli suma przekracza dostępne bity
adderComponent = Dodawanie
adderInputTip = Wejście: jedna z liczb do dodania
adderOutputTip = Wyjście: suma wejść (plus carry in)
#
# arith/ArithmeticLibrary.java
#
arithmeticLibrary = Arytmetyka
#
# arith/BitAdder.java
#
bitAdderComponent = Dodawanie bitów
bitAdderInputTip = Wejście: bity do policzenia
bitAdderOutputManyTip = Wyjście: ile bitów wejściowych jest równa 1
gateInputsAttr = liczba wejść
#
# arith/BitFinder.java
#
bitFinderComponent = Wyszukiwarka bitów
bitFinderFindLabel = znajdź
bitFinderHighLabel = wysoki
bitFinderHighOption = Najwyższa kolejność %s
bitFinderIndexHighTip = indeks: indeks najwyższego rzędu wejścia %s
bitFinderIndexLowTip = Indeks: indeks najniższego rzędu wejścia %s
bitFinderInputTip = Wejście: bity do przeszukania
bitFinderLowLabel = niski
bitFinderLowOption = Najniższa kolejność %s
bitFinderPresentTip = Obecne: 1 jeśli wejście zawiera %s
bitFinderTypeAttr = Typ
#
# arith/Comparator.java
#
comparatorComponent = Porównywanie
comparatorEqualTip = Równe: 1 jeśli A jest równe B
comparatorGreaterTip = Większe: 1 jeśli A jest większe niż B
comparatorInputATip = A: liczba poprzedzająca operację porównywania
comparatorInputBTip = B: numer następujący po operacji porównania
comparatorLessTip = Mniejsze: 1 jeżeli A jest mniejsze od B
comparatorType = Typ numeryczny
twosComplementOption = Uzupełnienie 2
unsignedOption = Bez znaku
#
# arith/Divider.java
#
dividerComponent = Dzielenie
dividerDividendLowerTip = Dolna dzielna: dolna połowa liczby do podzielenia
dividerDividendUpperTip = Górna dzielna: górna połowa liczby do podzielenia
dividerDivisorTip = Dzielnik: liczba, przez którą należy podzielić
dividerOutputTip = Wyjście: wynik dzielenia dzielnej przez dzielnik
dividerRemainderOutput = reszta
dividerRemainderTip = Reszta: reszta (dzielna - wyjście * dzielnik)
dividerUpperInput = górna
#
# arith/FPAdder.java
#
fpAdderComponent = Dodawanie zmiennoprzecinkowe
fpAdderOutputTip = Wyjście: suma danych wejściowych
fpErrorTip = Błąd: 1 jeśli wejście lub wyjście nie jest liczbą
#
# arith/FPComparator.java
#
fpComparatorComponent = Porównywanie zmiennoprzecinkowe
#
# arith/FPDivider.java
#
fpDividerDividendTip = Dzielna: liczba od podzielenia
fpDividerComponent = Dzielenie zmiennoprzecinkowe
#
# arith/FPMultiplier.java
#
fpMultiplierComponent = Mnożenie zmiennoprzecinkowe
fpMultiplierOutputTip = Wyjście: iloczyn danych wejściowych
#
# arith/FPNegator.java
#
fpNegatorComponent = Inwersja zmiennoprzecinkowa
fpNegatorOutputTip = Wyjście: zanegowane dane wejściowe
#
# arith/FPSubtractor.java
#
fpSubtractorComponent = Odejmowanie zmiennoprzecinkowe
#
# arith/FPToInt.java
#
ceilOption = Zaokrąglaj w górę
floorOption = Zaokrąglaj w dół
fpToIntComponent = Liczba zmiennoprzecinkowa do całkowitej
fpToIntInputTip = Wejście: liczba zmiennoprzecinkowa do skonwertowania na całkowitą
fpToIntOutputTip = Output: signed output containing the rounded floating point value
fpToIntType = Sposób zaokrąglania
roundOption = Do najbliższej wartości
truncateOption = Obcinanie
#
# arith/IntToFP.java
#
intToFPComponent = Liczba całkowita do zmiennoprzecinkowej
# ==> intToFPInputTip =
# ==> intToFPOutputTip =
#
# arith/Multiplier.java
#
multiplierCarryInTip = Carry In: kwota, którą należy dodać do wyjścia
multiplierCarryOutTip = Carry Out: górne bity produktu
multiplierComponent = Mnożenie
multiplierInputTip = Wejście: jedna z liczb do pomnożenia
multiplierOutputTip = Wyjście: iloczyn wejść i przeniesienia
#
# arith/Negator.java
#
negatorComponent = Negator
negatorInputTip = Wejście: liczba do zanegowania
negatorOutputTip = Wyjście: negacja obustronnego uzupełniania wejścia
#
# arith/Shifter.java
#
shiftArithmeticRight = Artmetyczne w prawo
shifterComponent = Przesuwnik
shifterDistanceTip = Odległość: o ile przesunąć dane wejściowe
shifterInputTip = Wejście: bity do przesunięcia
shifterOutputTip = Wyjście: wynik przesunięcia danych wejściowych
shifterShiftAttr = Rodzaj przesuwania
shiftLogicalLeft = Logiczne w lewo
shiftLogicalRight = Logiczne w prawo
shiftRollLeft = Rotacja w lewo
shiftRollRight = Rotacja w prawo
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Borrow In: jeżeli 1, produkcja jest zmniejszona o 1
subtractorBorrowOutTip = Borrow Out: 1 jeśli różnica daje wartość ujemną
subtractorComponent = Odejmowanie
subtractorMinuendTip = Odjemna: liczba, od której należy odjąć
subtractorOutputTip = Wyjście: różnica pomiędzy minuend a subtrahendem
subtractorSubtrahendTip = Odjemnik: liczba do odjęcia od minuendu
#
# base/BaseLibrary.java
#
baseLibrary = Baza
#
# base/Text.java
#
textComponent = Etykieta
textFontAttr = Czcionka
textColorAttr = Kolor
textHorzAlignAttr = Wyrównanie w poziomie
textHorzAlignCenterOpt = Środek
textHorzAlignLeftOpt = Lewy
textHorzAlignRightOpt = Prawo
textTextAttr = Tekst
textVertAlignAttr = Wyrównanie w pionie
textVertAlignBaseOpt = Baza
textVertAlignBottomOpt = Dół
textVertAlignCenterOpt = Środek
textVertAlignTopOpt = Góra
#
# base/VhdlParser.java
#
CannotFindEntityException = Nie można znaleźć deklaracji elementu
emptySourceException = Nie można przetwarzać pustej zawartości
genericDeclarationException = Nieprawidłowa składnia generyków
genericTypeException = Hieobsługiwany typ generyczny
genericValueException = Nierozpoznana wartość domyślna generyka
invalidTypeException = Nieprawidłowy typ portu
portDeclarationException = Nielegalna składnia portowa
portTypeException = Niebsługiwany typ portu: "%s". Proszę używaj tylko "std_logic" i "std_logic_vector".
#
# Builtin.java
#
builtinLibrary = Wbudowany
#
# gates/AndGate.java
#
andGateComponent = AND (koniunkcja)
#
# gates/Buffer.java
#
bufferComponent = Bufor
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Bufor sterowany
controlledControlOption = Linia sterująca
controlledInverterComponent = Negator sterowany
controlledLeftHanded = Z lewej strony
controlledRightHanded = Z prawej strony
#
# gates/EvenParityGate.java
#
evenParityComponent = Parzysty parytet
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/pływające
gateOutputAttr = Wartość wyjściowa
gateOutputZ1 = Pływające/1
gateSizeNormalOpt = Średnia
xorBehaviorAttr = Zachowanie wielu wejść
xorBehaviorOdd = Kiedy liczba nieparzysta jest włączona
xorBehaviorOne = Gdy jedno wejście jest włączone
#
# gates/GatesLibrary.java
#
gatesLibrary = Bramki
#
# gates/NandGate.java
#
nandGateComponent = NAND (zaprzeczony AND)
#
# gates/NegateAttribute.java
#
gateNegateAttr = Negacja %s
#
# gates/NorGate.java
#
norGateComponent = NOR (zaprzeczony OR)
#
# gates/NotGate.java
#
notGateComponent = NOT (negacja)
#
# gates/OddParityGate.java
#
oddParityComponent = Nieparzysty parytet
#
# gates/OrGate.java
#
orGateComponent = OR (alternatywa)
#
# gates/PLA.java
#
plaBitWidthIn = Liczba bitów wejściowych
plaBitWidthOut = Liczba bitów wyjściowych
input = wejście
output = wyjście
PLA = PLA
plaClickToEdit = (kliknij, aby edytować)
plaEditMenuItem = Edytuj program PLA...
plaProgram = Program
#
# gates/PLATable.java
#
plaEditorTitle = Edytor programu PLA
plaFileCreateError = Nie można utworzyć pliku.
plaFileOpenError = Nie można było otworzyć pliku.
plaLoadDialogTitle = Wczytaj program PLA.
plaLoadErrorTitle = Błąd ładowania programu PLA
plaSaveDialogTitle = Zapisz program PLA
plaSaveErrorTitle = Program do zapisywania błędów PLA
# ==> plaExportButton =
# ==> plaImportButton =
# ==> plaOKButton =
# ==> plaCancelButton =
# ==> plaRemoveButton =
# ==> plaAddRowButton =
# ==> plaCommentsLabel =
# ==> plaInputLabel =
# ==> plaOutputLabel =
# ==> plaFileIoException =
# ==> plaInvalideInputBitError =
# ==> plaInvalideOutputBitError =
# ==> plaRowExactOutBitError =
# ==> plaRowExactInBitError =
# ==> plaRowMissingOutputError =
# ==> plaTableError =
#
# gates/XnorGate.java
#
xnorGateComponent = XNOR (zaprzeczony XOR)
#
# gates/XorGate.java
#
xorGateComponent = XOR (alternatywa wykluczająca)
#
# InstanceComponent.java
#
KeywordNameError = Etykieta nie może zawierać słów zastrzeżonych. Proszę podaj inną etykietę.
MatchedLabelNameError = Etykieta i nazwa komponentu nie mogą być takie same (wielkość liter nie ma znaczenia). Proszę podaj etykietę różną od nazwy komponentu.
#
# InstanceTextField.java
#
changeLabelAction = Zmień etykietę
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = Przełącznik DIP
nrOfSwitch = Liczba przełączników
#
# io/LedCluster.java
#
#
# io/DotMatrix.java
#
ioInputColumn = Kolumny
ioInputRow = Rzędy
ioInputSelect = Wybierane rzędy/kolumny
ioMatrixCols = Liczba kolumn
ioMatrixInput = Format wejścia
ioMatrixPersistenceAttr = Długość świecenia
ioMatrixRows = Liczba wierszy
ioMatrixShape = Kształt kropki
ioShapeCircle = Okrągła
ioShapeSquare = Kwadrat
# ==> ioShapePaddedSquare =
ioLedBarComponent = Listwa LED
ioLedBarSegments = Liczba segmentów
ioLedBarInput = Format wejścia
ioLedBarInputSeparated = Rozdzielone
ioLedBarInputOneWire = Jeden przewód
#
# io/extra/Buzzer.java
#
buzzerFrequecy = częstotliwość
buzzerVolume = objętość
buzzerVolumeBitWidth = liczba bitów głośności
# ==> buzzerUnitDhz =
# ==> buzzerWaveform =
# ==> buzzerSine =
# ==> buzzerSquare =
# ==> buzzerSmoothLevel =
# ==> buzzerSmoothWidth =
# ==> buzzerChannel =
# ==> buzzerChannelBoth =
# ==> buzzerChannelLeft =
# ==> buzzerChannelRight =
# ==> buzzerTriangle =
# ==> buzzerSawtooth =
# ==> buzzerNoise =
# ==> buzzerDutyCycle =
enableSound = Włącz dźwięk
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Kolor granicy
bothOption = oba
ClearDiagram = Wyczyść wykres
DigitalOscilloscopeClock = zegar
DrawClockFrontLine = narysuj linię frontu zegara
noOption = brak
ShowClockAttribute = Pokaż atrybut zegara
stdTriggerFalling = Zbocze opadające
stdTriggerRising = Zbocze narastające
#
# io/extra/ExtraIoLibrary.java
#
buzzerComponent = Brzęczyk
DigitalOscilloscopeComponent = Oscyloskop cyfrowy
PlaRomComponent = PLA
Slider = Suwak
switchComponent = Przełącznik
#
# io/extra/PlaRom.java
#
memCSTip = Chip Select: 0 wyłącza komponent
PlaANDAttr = I
# ==> ramCSLabel =
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = okno edycji PlaRom %s
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Liczba stanów
ProgrammableGeneratorComponent = Generator programowalny
ramClearMenuItem = Wyczytść zawartość
ramEditMenuItem = Edytuj zawartość...
romContentsAttr = Zawartość
romContentsValue = (kliknij, aby edytować)
#
# io/extra/Slider.java
#
left_to_rightOption = od lewej do prawej
right_to_leftOption = od prawej do lewej
#
# io/HexDigit.java
#
hexDigitDataTip = Dane: nibble do wyświetlania
hexDigitDPTip = DecimalPoint: zapala kropkę dziesiętną
#
# io/IoLibrary.java
#
buttonComponent = Przycisk
dipswitchComponent = Przełącznik DIP
dotMatrixComponent = Matryca LED
hexDigitComponent = Wyświetlacz szesnastkowy
ioActiveAttr = Aktywne gdy wysoki?
ioBackgroundColor = Kolor tła
ioColorAttr = Kolor
ioLibrary = I/O
ioOffColor = Segment wyłączony
ioOnColor = Segment włączony
joystickComponent = Joystick
ledComponent = LED
pioComponent = Port I/O
# ==> repLBComponent =
RGBledComponent = RGB LED
sevenSegmentComponent = Wyświetlacz 7-segmentowy
ttyComponent = TTY
#
# io/Button.java
#
# ==> buttonPressAttr =
# ==> buttonPressActive =
# ==> buttonPressPassive =
#
# io/Joystick.java
#
ioBitWidthAttr = Liczba bitów
joystickCoordinateX = Wyjście: Wartość X
joystickCoordinateY = Wyjście: Wartość Y
#
# io/Keyboard.java
#
keybAvailTip = Dostępna: 1 gdy bufor zawiera znaki
keybBufferLengthAttr = Rozmiar bufora
keybClearTip = Wyczyść: 1 czyści bufor
keybClockTip = Zegar: używa pierwszego znaku z bufora
keybDesc = klawiatura (wielkość bufora %s)
keybEnableTip = Read enable: 0 wyłącza zegar
keyboardComponent = Klawiatura
keybOutputTip = Dane: wartość ASCII pierwszego znaku z bufora
#
# io/PortIO.java
#
pioDirection = Typ portu:
pioInput = Tylko wejścia
pioInputs = Wejścia %s
pioIOMultiple = I/O (zezwolenie na każdy bit)
pioIOSingle = I/O (pojedyncze zezwolenie)
pioNumber = Liczba pinów
pioOutEnable = zezwolenie na wyjście
pioOutEnables = Wyjście umożliwia %s
pioOutput = Tylko wyjścia
pioOutputs = Wyjścia %s
#
# io/ReptarLocalBus.java
#
repLBTip = Końcówka B
#
# io/RgbLed.java
#
BLUE = Wejście B
GREEN = Wejście G
RED = Wejście R
#
# io/SevenSegment.java
#
DecimalPoint = Kropka dziesiętna
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
SevenSegDP = Kropka dziesiętna:
#
# io/Telnet.java
#
# ==> telnetComponent =
# ==> telnetModeAttr =
# ==> telnetPortAttr =
# ==> telnetInTip =
# ==> telnetOutTip =
# ==> telnetClkTip =
# ==> telnetWriteTip =
# ==> telnetReadTip =
# ==> telnetAvailableTip =
#
# io/Tty.java
#
ttyClearTip = Clear: Jeśli 1, czyści ekran
ttyClockTip = Zegar: wyzwalacz dodaje znak z wejścia
ttyColsAttr = Kolumny
ttyDesc = TTY (%s rzędów, %s kolumn)
ttyDescShort = TTY
ttyEnableTip = Write Enable: 0 wyłącza zegar
ttyInputTip = Dane: Wartość ASCII kolejnego znaku do zapisu
ttyRowsAttr = Wiersze
#
# io/Video.java
#
rgbVideoCLK = Zegar
rgbVideoColor = Model barw
rgbVideoComponent = RGB Video
rgbVideoCursor = Kursor
rgbVideoData = Dane w formacie %s
rgbVideoHeight = Wysokość
rgbVideoReset = Tryb resetowania
rgbVideoRST = Resetowanie
rgbVideoScale = Skala
rgbVideoWE = Write Enable
rgbVideoWidth = Szerokość
rgbVideoX = Współrzędna X
rgbVideoY = Współrzędna Y
#
# bfh/bcd2sevenseg.java
#
BCDValue = Wartość BCD
BCD2SevenSegment = BCD do 7-segmentów
#
# bfh/BfhLibrary.java
#
BFHMegaFunctions = Mega funkcje BFH
Bin2BCD = Binarny do BCD
#
# bfh/bin2bcd.java
#
BinaryDataBits = bity danych binarnych
BinaryInputTip = wejście Binairy
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Clock: aktualizacja stanu wyzwalacza
flipFlopNotQTip = Uzupełnienie aktualnego stanu klapki
flipFlopPresetTip = Wstępnie ustawiony: Kiedy 1, stan pinów na 1 asynchronicznie
flipFlopQTip = Aktualny stan
flipFlopResetTip = Wyczyść: Kiedy 1, stan pinu do 0 asynchronicznie
#
# memory/Counter.java
#
counterCarryTip = Nośność: wynosi 1, gdy wartość osiąga maksimum (minimum w przypadku dekrementowania)
counterClockTip = Zegar: wartość może być aktualizowana po wyzwoleniu
counterComponent = Licznik
counterDataTip = Dane: wartość do załadowania do licznika
counterEnableLabel = ct
counterEnableTip = Włącz: gdy 1, licznik przyrostów lub dekadencji
counterGoalAttr = Działanie na przelewie
counterGoalContinue = Kontynuuj liczenie
counterGoalLoad = Załaduj następną wartość
counterGoalStay = Trzymaj się wartości
counterGoalWrap = Owiń się
counterLabel = ctr
counterLoadTip = Obciążenie: gdy 1, obciążenie z wprowadzania danych
counterMaxAttr = Wartość maksymalna
counterQTip = Wyjście: aktualna wartość licznika
counterResetTip = Clear: kiedy 1, resetuje się asynchronicznie do 0
counterUpDownTip = góra-dół: kiedy 1, licznik przyrostów, kiedy 0, licznik dekretacji
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
memAsyncRead = Odczyt asynchroniczny:
memByte = Użycie bajtu umożliwia
memDual = Dual
memEnables = Włącza:
memLine = Linia użytkowa umożliwia
memLineSize = Rozmiar linii
memMisaligned = Zezwalać nia brak wyrównania?
# ==> memOcto =
# ==> memQuad =
memRaw = Odczytaj po zapisie
memReadBehav = Sposób odczytu
memSingle = Pojedynczy
memWar = Zapisz po odczytaniu
ramAddrWidthAttr = Liczba bitów adresu
ramDataWidthAttr = Liczba bitów danych
ramSelAttr = Wybierz
stdTriggerHigh = Wysoki poziom
stdTriggerLow = Niski poziom
#
# memory/MemMenu.java
#
ramConfirmClearMsg = Czy na pewno chcesz wyzerować pamięć?
ramConfirmClearTitle = Potwierdź Wyczyść
ramLoadMenuItem = Załaduj obraz...
ramSaveMenuItem = Zapisz obraz...
#
# memory/MemoryLibrary.java
#
dFlipFlopComponent = D Flip-Flop
memoryLibrary = Pamięć
tFlipFlopComponent = T Flip-Flop
#
# memory/Ram.java
#
ramComponent = RAM
#
# memory/RamAppearance.java
#
memAddrTip = Adres: lokalizacja dostępna w pamięci
memDataTip = Dane: wartość załadowana z adresu
memDataTip0 = Dane: wartość załadowana z adresu+0
memDataTip1 = Dane: wartość załadowana z adresu+1
memDataTip2 = Dane: wartość załadowana z adresu+2
memDataTip3 = Dane: wartość załadowana z adresu+3
ramByteEnableTip0 = Bajt enable dla bajtu 0
ramByteEnableTip1 = Bajt enable dla bajtu 1
ramByteEnableTip2 = Bajt enable dla bajtu 2
ramByteEnableTip3 = Bajt enable dla bajtu 3
ramClkTip = Zegar: aktualizacja wartości pamięci przy wzroście od 0 do 1
ramClrPin = Clear: jeden ustawia wszystkie lokalizacje pamięci na 0
ramInTip = Wejście: wartość, która ma być zapisana pod adresem
ramInTip0 = Wejście: wartość do zapisania pod adresem+0
ramInTip1 = Wejście: wartość do zapisania pod adresem+1
ramInTip2 = Wejście: wartość do zapisania pod adresem+2
ramInTip3 = wejście: wartość, która ma być zapisana pod adresem+3
ramLETip0 = Włączenie linii dla adresu+0
ramLETip1 = zezwolenie na linię dla adresu+1
ramLETip2 = Włączenie linii dla adresu+2
ramLETip3 = Włączenie linii dla adresu+3
ramOETip = Obciążenie: jeżeli 1, to pamięć załadunkowa do wyjścia
ramWETip = Zapisz: jeśli 1, zapisz wejście do pamięci
#
# memory/RamAttributes.java
#
ramBidirDataBus = jedna dwukierunkowa magistrala danych
ramByteEnables = kontrola zapisu odczytu
RamClearPin = Użyj pinu czyszczenia
ramDataAttr = Implementacja szyny danych
ramNoByteEnables = Odczyt/zapis tylko całych słów
ramSeparateDataBus = Oddzielne szyny do odczytu i zapisu
ramTypeAttr = Typ pamięci
ramTypeNonVolatile = Nieulotna
ramTypeVolatile = ulotna
ramWithByteEnables = Użycie bajtu umożliwia
#
# memory/Random.java
#
randomClockTip = Clock: wartość może się aktualizowanć po otrzymaniu sygnału
randomComponent = Generator losowy
randomLabel = losowy
randomNextTip = Enable: przechodzi do nastepnej wartości w sekwencji po otrzymaniu sygnału zegarowego.
randomQTip = Wyjście: bieżąca liczba w sekwencji
randomResetTip = Clear: Kiedy 1, resetuje zegar asynchronicznie do stanu początkowego.
randomSeedAttr = Stan początkowy
randomWidthLabel = Szerokość: %d
#
# memory/Register.java
#
registerClkTip = Clock: aktualizacja wartości przy wyzwalaniu
registerClrTip = Clear: Kiedy 1, wartość pinu do 0 asynchronicznie
registerComponent = Rejestr
registerDTip = Data: wartość zapisana na wyzwalaczu zegarowym
registerEnableTip = Enable: Gdy 0, wyzwalacze zegara są nieskuteczne
# ==> registerLabel =
registerQTip = Wyjście: aktualna wartość rejestru
registerShowInTab = Pokaż w zakładce "Rejestry"
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = Edytuj zawartość ROMu
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Clear: kiedy 1, resetuje wszystko do 0 asynchronicznie
shiftRegClockTip = Clock: wartości mogą być aktualizowane przy wyzwalaniu
shiftRegInTip = Wejście: wartość, która ma być przeniesiona do pierwszego etapu
shiftRegisterComponent = Rejestr przesuwny
shiftRegisterLabel1 = rejestr przesuwny
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = liczba etapów
shiftRegLoadTip = LOAD: kiedy 1 (z przesunięciem równym 0), obciążenie wszystkich etapów z wejść
shiftRegOutTip = Wyjście: zawartość ostatniego etapu
shiftRegParallelAttr = Ładowanie równoległe
shiftRegShiftTip = Shift: zmiana jest wyłączona, gdy 0
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Selektor bitów
bitSelectorDataTip = Dane
bitSelectorGroupAttr = Bity wyjściowe
bitSelectorOutputTip = Wyjście: wartość wybranej grupy bitów z danych
bitSelectorSelectTip = Wybierz: określa która grupa danych jest wybrana.
#
# plexers/Decoder.java
#
decoderEnableTip = Enable: gdy nie ma wartości 0, wybrane wyjście ma wartość 1
decoderOutTip = Wyjście %s
decoderSelectTip = Select: określa na którym wyjściu pojawi się 1
#
# plexers/Demultiplexer.java
#
demultiplexerEnableTip = Enable: gdy nie ma wartości 0, wybrane wyjście jest wejściem.
demultiplexerInTip = Wejście
demultiplexerOutTip = Wyjście %s
demultiplexerSelectTip = Select: określa, na którym wyjściu pojawi się sygnał wejściowy
#
# plexers/Multiplexer.java
#
multiplexerEnableTip = Enable: jeśli nie 0, wyjście jest wybranym wejściem.
multiplexerInTip = Wejście %s
multiplexerOutTip = Wyjście
multiplexerSelectTip = Select: określa, które wejście stanie się wyjściem.
#
# plexers/PlexersLibrary.java
#
decoderComponent = Dekoder
demultiplexerComponent = Demultiplekser
gateSizeAttr = Rozmiar bramki
gateSizeNarrowOpt = Wąska
gateSizeWideOpt = Szeroka
multiplexerComponent = Multiplekser
plexerDisabledAttr = Wyłączone wyjście
plexerDisabledFloating = pływające
plexerDisabledZero = Zero
plexerEnableAttr = Dołączyć Enable?
plexerLibrary = Pleksery
plexerSelectBitsAttr = Bitów wyboru
plexerThreeStateAttr = Trzystanowe?
priorityEncoderComponent = Priorytetowy koder
#
# plexers/PriorityEncoder.java
#
priorityEncoderEnableInTip = Włącz wejście: 0 wyłącza komponent
priorityEncoderEnableOutTip = Włącz wyjście: 1 jeśli włączone, a żadne z wejść nie jest 1
priorityEncoderGroupSignalTip = Wybierz grupę: 1 jeśli jest włączony, a dowolne wejście ma wartość 1
priorityEncoderInTip = Wejście %s
priorityEncoderOutTip = Wyjście: adres najwyżej indeksowanego 1 wejścia
#
# StdAttr.java
#
ioLabelColorAttr = Kolor etykiety
stdClassicAppearance = Klasyczny Logisim
stdDataWidthAttr = Bity danych
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Kierunek
stdFPDataWidthAttr = Liczba bitów liczby
stdLabelAttr = Etykieta
stdLabelCenter = Na środku
stdLabelFontAttr = Czcionka etykiety
stdLabelLocAttr = Lokalizacja etykiety
stdLabelVisibility = Etykieta widoczna
stdLogisimEvolutionAppearance = Logisim-Evolution
stdTriggerAttr = Trigger
stdSelectLocAttr = Wybierz lokalizację
stdSelectBottomLeftOption = Dół/Lewo
stdSelectTopRightOption = Góra/Prawo
#
# tcl/TclLibrary.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = Plik z zawartością TCL
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = Konsola TCL REDS
#
# tcl/TclGeneric.java
#
# ==> tclGeneric =
tclInterfaceDefinition = interfejs TCL Podmiot VHDL
tclInterfaceDefinitionValue = (kliknij, aby edytować)
#
# ttl/AbstractTtlGate.java
#
GNDPin = Pin uziemiający %s
VCCPin = Pin VCC %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Wygaszenie
DisplayDecoderComponent = Dekoder wyświetlacza
DisplayDecoderInTip = Wejście
DisplayDecoderOutTip = Wyjście
ioMultiBit = multi bit
LampTestInTip = wejście do testu lampy
LT = LT
memEnableLabel = pl
RBI = RBI
RippleBlankingInputInTip = Wejście wygaszające tętnienia
#
# ttl/TtlLibrary.java
#
ShowInternalStructure = Pokaż wewnętrze
TTL7400 = 7400: poczwórna bramka 2-wejściowa NAND
TTL7402 = 7402: poczwórna bramka 2-wejściowa NOR
TTL7404 = 7404: falownik sześciokątny
TTL7408 = 7408: quad 2-wejściowy I bramka
TTL7410 = 7410: potrójna bramka 3-wejściowa NAND
TTL7411 = 7411: potrójne 3 wejścia i bramka
TTL74125 = 74125: bufor czterobusowy, wyjścia trójstanowe, ujemne zezwolenie
# ==> TTL74151 =
# ==> TTL74153 =
# ==> TTL74157 =
# ==> TTL74158 =
TTL74138 = Dekoder 3 linie do 8 linii
# ==> TTL74139 =
TTL7413 = 7413: podwójna 4-wejściowa bramka NAND (schmitt-trigger)
TTL7414 = 7414: falownik sześciokątny (schmitt-trigger)
# ==> TTL74161 =
# ==> TTL74163 =
# ==> TTL74164 =
# ==> TTL74165 =
TTL74166 = 74166: 8-bitowy rejestr przesunięcia równoległego do szeregowego z kasowaniem asynchronicznym
TTL74175 = 74175: quad D-flipflop, reset asynchroniczny
TTL7418 = 7418: podwójna 4-wejściowa bramka NAND (schmitt-trigger)
# ==> TTL74181 =
# ==> TTL74182 =
TTL7419 = 7419: falownik sześciokątny (schmitt-trigger)
# ==> TTL74192 =
# ==> TTL74193 =
# ==> TTL74194 =
TTL7420 = 7420: podwójna 4-wejściowa bramka NAND
TTL7421 = 7421: podwójne 4 wejścia i brama
TTL7424 = 7424: poczwórna 2-wejściowa bramka NAND (schmitt-trigger)
# ==> TTL74240 =
# ==> TTL74241 =
# ==> TTL74244 =
# ==> TTL74245 =
# ==> TTL74266 =
TTL7427 = 7427: potrójna bramka 3-wejściowa NOR
TTL74273 = 74273: ośmiokrotny D-Flipflop z przezroczystą klapką
TTL74283 = 74283: 4-bitowa binarna pełna adder
# ==> TTL74299 =
TTL7430 = 7430: pojedyncza 8-wejściowa bramka NAND
TTL7432 = 7432: poczwórna bramka 2-wejściowa OR
# ==> TTL7434 =
TTL7436 = 7436: poczwórna bramka 2-wejściowa NOR
TTL74377 = 74377: ośmiokątny D-Flipflop z zezwoleniem
TTL74381 = 74381: Jednostka arytmetyczno-logiczna (ALU)
TTL7442 = 7442: BCD do dekodera dziesiętnego
TTL7443 = 7443: Nadmiar-3 do dekodera dziesiętnego
TTL7444 = 7444: Dekoder szary do dekodera dziesiętnego
TTL7447 = 7447: dekoder BCD na 7-segmentowy
TTL7451 = 7451: podwójna brama AND-OR-INVERT
TTL7454 = 7454: Cztery szerokie bramy AND-OR-INVERT
# ==> TTL74541 =
TTL7458 = 7458: podwójna bramka AND-OR
TTL7464 = 7464: 4-2-3-2 bramka AND-OR-INVERT
# ==> TTL74670 =
TTL747266 = 747266: quad 2-wejściowa bramka XNOR
TTL7474 = 7474: podwójne klapki D z ustawieniem wstępnym i przezroczystością
TTL7485 = 7485: 4-bitowy komparator wielkości
TTL7486 = 7486: quad 2-wejściowa bramka XOR
# ==> TTL7487 =
VccGndPorts = włączenie portów Vcc i Gnd
#
# wiring/BitExtender.java
#
extenderInAttr = Bitów wejściowych
extenderInputLabel = wejście
extenderInputType = Wejście
extenderMainLabel = rozsz.
extenderOneLabel = 1
extenderOneType = Jeden
extenderOutAttr = Bitów wyjściowych
extenderSignLabel = znak
extenderSignType = Znak
extenderTypeAttr = Typ rozszerzania
extenderZeroLabel = 0
extenderZeroType = Zero
#
# wiring/Clock.java
#
clockComponent = Zegar
clockHighAttr = Wysoki czas trwania
clockLowAttr = Niski czas trwania
clockPhaseAttr = Przesunięcie fazowe
#
# wiring/Constant.java
#
constantComponent = Stała
constantValueAttr = Wartość
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 tyknięcie
clockDurationValue = %s tyknięć
durationLargeMessage = Wartość musi być %s lub mniejsza.
durationSmallMessage = Wartość musi wynosić co najmniej %s.
freqInvalidMessage = Wartość nie jest poprawną liczbą całkowitą.
PORDurationOneValue = 1 sekunda
PORDurationValue = %s sekund
#
# wiring/Pin.java
#
# ==> pinBehaviorAttr =
PinCancel = Anuluj
pinComponent = Pin
PinEnterDecimal = Wprowadź wartości dziesiętne
PinEnterFloat = Wprowadz wartości zmiennoprzecinkowe
pinFrozenQuestion = Pin jest przypisany do stanu superobwodu. Czy stworzyć nowy stan obwodu?
pinFrozenTitle = Pin przypisany do super obwodu.
pinInputName = Wejście
# ==> pinInputOption =
pinInputToolTip = Dodaj pin wejściowy
PinOkay = OK
pinOutputName = Wyjście
# ==> pinOutputOption =
pinOutputToolTip = Dodaj pin wyjściowy
pinPullDownOption = Ściągnij w dół
pinPullUpOption = Podciągnij do góry
# ==> pinResetValue =
# ==> pinSimpleOption =
# ==> pinTristateOption =
# ==> pinTypeAttr =
#
# wiring/PowerOnReset.java
#
PowerOnResetComponent = POR
# ==> porLongName =
porHighAttr = Czas POR
# ==> PorSize =
# ==> porSizeMedium =
# ==> porSizeNarrow =
# ==> porSizeWide =
# ==> porTransition =
# ==> porHighToLow =
# ==> porLowToHigh =
#
# wiring/Probe.java
#
probeComponent = Sonda
#
# wiring/ProbeAttributes.java
#
probeNewPin = Kształty strzałek
stdAppearanceAttr = Wygląd
#
# wiring/PullResistor.java
#
pullComponent = Rezystor ściągający
pullErrorType = Błąd
pullOneType = Do jedynki
pullTypeAttr = Ściąganie
pullZeroType = Do zera
#
# wiring/Transistor.java
#
transistorNDrain = odpływ: niskie źródło pociągnie za sobą niski odpływ (tylko gdy brama jest wysoka)
transistorNGate = bramka: gdy jest wysoki, pozwala na przepływ prądu przez tranzystor
transistorNSource = źródło: niskie źródło pociągnie za sobą niski odpływ (tylko gdy brama jest wysoka)
transistorPDrain = odpływ: wysokie źródło będzie wyciągać odpływ wysoko (tylko przy niskiej bramie)
transistorPGate = bramka: gdy jest niski, pozwala na przepływ prądu przez tranzystor
transistorPSource = źródło: wysokie źródło pociągnie za sobą wysoki odpływ (tylko gdy brama jest niska)
transistorTypeAttr = Typ
transistorTypeN = N-TypeN
transistorTypeP = P-TypeP
#
# wiring/TransmissionGate.java
#
transmissionGateDrain = Odpływ: sterowany przez źródło, w zależności od p-gate i n-gate
transmissionGateNGate = Bramka N: gdy ma niski stan, pozwala na przejście niskiego sygnału ze źródła do odpływu
transmissionGatePGate = Bramka P: gdy ma stan wysoki, pozwala na przejście wysokiego sygnału ze źródła do odpływu
transmissionGateSource = Żródło: steruje odpływem w zależności od stanu bramki P i N
#
# wiring/Tunnel.java
#
tunnelComponent = Tunel
#
# wiring/WiringLibrary.java
#
extenderComponent = Extender bitów
groundComponent = Masa
noConnectionComponent = Nie podłączaj
powerComponent = Zasilanie
transistorComponent = Tranzystor
transmissionGateComponent = Brama transmisyjna
wiringLibrary = Przewody
input.output.extra = I/O Extra
