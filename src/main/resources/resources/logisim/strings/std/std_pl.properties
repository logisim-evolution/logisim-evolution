#
# Reviewed MOR: 2021-07-05 (WiP)
#
#
# arith/Adder.java
#
adderCarryInTip = Carry In: jeśli 1, do wyjścia dodana jest dodatkowa 1
adderCarryOutTip = Carry Out: 1 jeśli suma przekracza dostępne bity
adderComponent = Sumator
adderInputTip = Wejście: jedna z liczb do dodania
adderOutputTip = Wyjście: suma wejść (plus carry in)
#
# arith/ArithmeticLibrary.java
#
arithmeticLibrary = Arytmetyka
#
# arith/BitAdder.java
#
bitAdderComponent = Sumator bitów
bitAdderInputTip = Wejście: bity do policzenia
bitAdderOutputManyTip = Wyjście: ile bitów wejściowych jest równa 1
gateInputsAttr = liczba wejść
#
# arith/BitFinder.java
#
bitFinderComponent = Wyszukiwarka bitów
bitFinderFindLabel = znajdź
bitFinderHighLabel = wysoki
# bitFinderHighOption = Highest-order %s
#bitFinderHighOption = Najwyższa kolejność %s
# bitFinderIndexHighTip = Index: index of input's highest-order %s
#bitFinderIndexHighTip = indeks: indeks najwyższego rzędu wejścia %s
# bitFinderIndexLowTip = Index: index of input's lowest-order %s
#bitFinderIndexLowTip = Indeks: indeks najniższego rzędu wejścia %s
bitFinderInputTip = Wejście: bity do przeszukania
bitFinderLowLabel = niski
# bitFinderLowOption = Lowest-order %s
#bitFinderLowOption = Najniższa kolejność %s
bitFinderPresentTip = Obecne: 1 jeśli wejście zawiera %s
bitFinderTypeAttr = Typ
#
# arith/Comparator.java
#
comparatorComponent = Komparator
comparatorEqualTip = Równe: 1 jeśli A jest równe B
comparatorGreaterTip = Większe: 1 jeśli A jest większe niż B
comparatorInputATip = A: liczba poprzedzająca operację porównywania
comparatorInputBTip = B: numer następujący po operacji porównania
comparatorLessTip = Mniejsze: 1 jeżeli A jest mniejsze od B
comparatorType = Typ numeryczny
# twosComplementOption = 2's Complement
twosComplementOption = Uzupełnienie 2
# unsignedOption = Unsigned
unsignedOption = Bez znaku
#
# arith/Divider.java
#
dividerComponent = Dzielnik
dividerDividendLowerTip = Dolna dzielna: dolna połowa liczby do podzielenia
dividerDividendUpperTip = Górna dzielna: górna połowa liczby do podzielenia
dividerDivisorTip = Dzielnik: liczba, przez którą należy podzielić
dividerOutputTip = Wyjście: wynik dzielenia dzielnej przez dzielnik
# dividerRemainderOutput = rem
dividerRemainderOutput = reszta
dividerRemainderTip = Reszta: reszta (dzielna - wyjście * dzielnik)
dividerUpperInput = górna
#
# arith/FPAdder.java
#
# fpAdderComponent = Floating Point Adder
# fpAdderOutputTip = Output: the sum of the inputs
fpAdderOutputTip = Wyjście: suma danych wejściowych
fpErrorTip = Błąd: 1 jeśli wejście lub wyjście nie jest liczbą
# ==> fpErrorTip =
#
# arith/FPComparator.java
#
# fpComparatorComponent = Floating Point Comparator
# ==> fpComparatorComponent =
#
# arith/FPDivider.java
#
fpDividerDividendTip = Dzielna: liczba od podzielenia
fpDividerComponent = Floating Point Divider
#
# arith/FPMultiplier.java
#
fpMultiplierComponent = Floating Point Multiplier
fpMultiplierOutputTip = Wyjście: iloczyn danych wejściowych
#
# arith/FPNegator.java
#
fpNegatorComponent = Floating Point Negator
fpNegatorOutputTip = Wyjście: zanegowane dane wejściowe
#
# arith/FPSubtractor.java
#
# fpSubtractorComponent = Floating Point Subtractor
# ==> fpSubtractorComponent =
#
# arith/FPToInt.java
#
ceilOption = Zaokrąglaj w górę
floorOption = Zaokrąglaj w dół
# fpToIntComponent = Floating Point to Integer
# ==> fpToIntComponent
fpToIntInputTip = Wejście: liczba zmiennoprzecinkowa do skonwertowania na całkowitą
fpToIntOutputTip = Output: signed output containing the rounded floating point value
fpToIntType = Sposób zaokrąglania
roundOption = Do najbliższej wartości
truncateOption = Obcinanie
#
# arith/IntToFP.java
#
# intToFPComponent = Integer to Floating Point
# ==> intToFPComponent =
# intToFPInputTip = Input: the integer to convert to floating point
# ==> intToFPInputTip =
# intToFPOutputTip = Output: the floating point form of the input
# ==> intToFPOutputTip =
#
# arith/Multiplier.java
#
# multiplierCarryInTip = Carry In: an amount to be added into the output
multiplierCarryInTip = Carry In: kwota, którą należy dodać do wyjścia
# multiplierCarryOutTip = Carry Out: the upper bits of the product
multiplierCarryOutTip = Carry Out: górne bity produktu
# multiplierComponent = Multiplier
multiplierComponent = Mnożnik
# multiplierInputTip = Input: one of the numbers to multiply
multiplierInputTip = Wejście: jedna z liczb do pomnożenia
# multiplierOutputTip = Output: the product of the inputs, plus the carry in
multiplierOutputTip = Wyjście: iloczyn wejść i przeniesienia
#
# arith/Negator.java
#
# negatorComponent = Negator
negatorComponent = Negator
# negatorInputTip = Input: the number to be negated
negatorInputTip = Wejście: liczba do zanegowania
# negatorOutputTip = Output: the two's-complement negation of the input
negatorOutputTip = Wyjście: negacja obustronnego uzupełniania wejścia
#
# arith/Shifter.java
#
# shiftArithmeticRight = Arithmetic Right
shiftArithmeticRight = Artmetyczna Racja
# shifterComponent = Shifter
shifterComponent = Przesuwnik
# shifterDistanceTip = Distance: how far to shift the input
shifterDistanceTip = Odległość: jak daleko przesunąć wejście
# shifterInputTip = Input: bits to be shifted
shifterInputTip = wejście: bity do przesunięcia
# shifterOutputTip = Output: result of shifting the input
shifterOutputTip = Wyjście: wynik przesunięcia wejścia
# shifterShiftAttr = Shift Type
# ==> shifterShiftAttr =
# shiftLogicalLeft = Logical Left
shiftLogicalLeft = Logiczne Lewo
# shiftLogicalRight = Logical Right
shiftLogicalRight = Logiczne Prawo
# shiftRollLeft = Rotate Left
shiftRollLeft = Obróć w lewo
# shiftRollRight = Rotate Right
shiftRollRight = Obróć w prawo
#
# arith/Subtractor.java
#
# subtractorBorrowInTip = Borrow In: if 1, output is decreased by 1
subtractorBorrowInTip = Borrow In: jeżeli 1, produkcja jest zmniejszona o 1
# subtractorBorrowOutTip = Borrow Out: 1 if the difference yields a negative value
subtractorBorrowOutTip = Borrow Out: 1 jeśli różnica daje wartość ujemną
# subtractorComponent = Subtractor
subtractorComponent = Odejmowanie
# subtractorMinuendTip = Minuend: the number from which to subtract
subtractorMinuendTip = Odjemna: liczba, od której należy odjąć
# subtractorOutputTip = Output: the difference of the minuend and the subtrahend
subtractorOutputTip = Wyjście: różnica pomiędzy minuend a subtrahendem
# subtractorSubtrahendTip = Subtrahend: the number to subtract from the minuend
subtractorSubtrahendTip = Odjemnik: liczba do odjęcia od minuendu
#
# base/BaseLibrary.java
#
# baseLibrary = Base
baseLibrary = Baza
#
# base/Text.java
#
textComponent = Etykieta
textFontAttr = Czcionka
textHorzAlignAttr = Wyrównanie w poziomie
textHorzAlignCenterOpt = Środek
textHorzAlignLeftOpt = Lewy
textHorzAlignRightOpt = Prawo
textTextAttr = Tekst
textVertAlignAttr = Wyrównanie w pionie
textVertAlignBaseOpt = Baza
textVertAlignBottomOpt = Dół
textVertAlignCenterOpt = Środek
textVertAlignTopOpt = Góra
#
# base/VhdlParser.java
#
# CannotFindEntityException = The entity declaration cannot be found
CannotFindEntityException = Nie można znaleźć deklaracji podmiotu
# emptySourceException = Cannot parse empty content
emptySourceException = Nie można analizować pustej zawartości
# genericDeclarationException = Illegal generics syntax
genericDeclarationException = Nielegalna składnia generyków
# genericTypeException = Unsupported generics type
genericTypeException = nieobsługiwany typ leków generycznych
# genericValueException = Unrecognized generics default value
genericValueException = Nierozpoznane leki generyczne wartość domyślna
# invalidTypeException = Invalid port type
invalidTypeException = Nieprawidłowy typ portu
# portDeclarationException = Illegal port syntax
portDeclarationException = Nielegalna składnia portowa
#
# Builtin.java
#
builtinLibrary = Wbudowany
#
# gates/AndGate.java
#
andGateComponent = AND (koniunkcja)
#
# gates/Buffer.java
#
bufferComponent = Bufor
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Bufor sterowany
controlledControlOption = Linia sterująca
controlledInverterComponent = Negator sterowany
controlledLeftHanded = Z lewej strony
controlledRightHanded = Z prawej strony
#
# gates/EvenParityGate.java
#
# evenParityComponent = Even Parity
#evenParityComponent = Parzysty parytet
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/pływające
gateOutputAttr = Wartość wyjściowa
gateOutputZ1 = Pływające/1
gateSizeNormalOpt = Średnia
# xorBehaviorAttr = Multiple-Input Behavior
#xorBehaviorAttr = Zachowanie wielu wejść
xorBehaviorOdd = Kiedy liczba nieparzysta jest włączona
xorBehaviorOne = Gdy jedno wejście jest włączone
#
# gates/GatesLibrary.java
#
gatesLibrary = Bramki
#
# gates/NandGate.java
#
nandGateComponent = NAND (zaprzeczony AND)
#
# gates/NegateAttribute.java
#
gateNegateAttr = Negacja %s
#
# gates/NorGate.java
#
norGateComponent = NOR (zaprzeczony OR)
#
# gates/NotGate.java
#
notGateComponent = NOT (negacja)
#
# gates/OddParityGate.java
#
# oddParityComponent = Odd Parity
#oddParityComponent = Nieparzysty parytet
#
# gates/OrGate.java
#
orGateComponent = OR (alternatywa)
#
# gates/PLA.java
#
plaBitWidthIn = Liczba bitów wejściowych
plaBitWidthOut = Liczba bitów wyjściowych
input = wejście
output = wyjście
PLA = PLA
plaClickToEdit = (kliknij, aby edytować)
plaEditMenuItem = Edytuj program PLA...
plaProgram = Program
#
# gates/PLATable.java
#
plaEditorTitle = Edytor programu PLA
plaFileCreateError = Nie można utworzyć pliku.
plaFileOpenError = Nie można było otworzyć pliku.
plaLoadDialogTitle = Wczytaj program PLA.
plaLoadErrorTitle = Błąd ładowania programu PLA
plaSaveDialogTitle = Zapisz program PLA
plaSaveErrorTitle = Program do zapisywania błędów PLA
#
# gates/XnorGate.java
#
xnorGateComponent = XNOR (zaprzeczony XOR)
#
# gates/XorGate.java
#
xorGateComponent = XOR (alternatywa wykluczająca)
#
# InstanceComponent.java
#
KeywordNameError = Etykieta nie może zawierać słów zastrzeżonych. Proszę podaj inną etykietę.
MatchedLabelNameError = Etykieta i nazwa komponentu nie mogą być takie same (wielkość liter nie ma znaczenia). Proszę podaj etykietę różną od nazwy komponentu.
#
# InstanceTextField.java
#
changeLabelAction = Zmień etykietę
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = Przełącznik DIP
nrOfSwitch = Liczba przełączników
#
# io/LedCluster.java
#
#
# io/DotMatrix.java
#
ioInputColumn = Kolumny
ioInputRow = Rzędy
ioInputSelect = Wybierane rzędy/kolumny
ioMatrixCols = Liczba kolumn
ioMatrixInput = Format wejścia
ioMatrixPersistenceAttr = Długość świecenia
ioMatrixRows = Liczba wierszy
ioMatrixShape = Kształt kropki
ioShapeCircle = Okrągła
ioShapeSquare = Kwadrat
# ioShapePaddedSquare = Padded Square
# ==> ioShapePaddedSquare =
ioLedBarComponent = Listwa LED
ioLedBarSegments = Liczba segmentów
ioLedBarInput = Format wejścia
ioLedBarInputSeparated = Rozdzielone
ioLedBarInputOneWire = Jeden przewód
#
# io/extra/Buzzer.java
#
# buzzerFrequecy = frequency
buzzerFrequecy = częstotliwość
# buzzerVolume = volume
buzzerVolume = objętość
buzzerVolumeBitWidth = liczba bitów głośności
# buzzerUnitDhz = dHz (0.1Hz)
# ==> buzzerUnitDhz =
# buzzerWaveform = Waveform
# ==> buzzerWaveform =
# buzzerSine = Sine
# ==> buzzerSine =
# buzzerSquare = Square
# ==> buzzerSquare =
# buzzerSmoothLevel = Smooth level
# ==> buzzerSmoothLevel =
# buzzerSmoothWidth = Smooth window width
# ==> buzzerSmoothWidth =
# buzzerChannel = Channel
# ==> buzzerChannel =
# buzzerChannelBoth = Both
# ==> buzzerChannelBoth =
# buzzerChannelLeft = Left
# ==> buzzerChannelLeft =
# buzzerChannelRight = Right
# ==> buzzerChannelRight =
# buzzerTriangle = Triangle
# ==> buzzerTriangle =
# buzzerSawtooth = Sawtooth
# ==> buzzerSawtooth =
# buzzerNoise = White noise
# ==> buzzerNoise =
# buzzerDutyCycle = Duty cycle
# ==> buzzerDutyCycle =
# enableSound = Enable sound
enableSound = Włącz dźwięk
# Hz = Hz
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
# BorderColor = Border color
BorderColor = Kolor granicy
# bothOption = both
bothOption = oba
ClearDiagram = Wyczyść wykres
# DigitalOscilloscopeClock = clock
DigitalOscilloscopeClock = zegar
# DrawClockFrontLine = draw clock front line
#DrawClockFrontLine = narysuj linię frontu zegara
noOption = brak
# ShowClockAttribute = Show clock attribute
ShowClockAttribute = Pokaż atrybut zegara
stdTriggerFalling = Zbocze opadające
stdTriggerRising = Zbocze narastające
#
# io/extra/ExtraIoLibrary.java
#
buzzerComponent = Brzęczyk
DigitalOscilloscopeComponent = Oscyloskop cyfrowy
PlaRomComponent = PLA
Slider = Suwak
switchComponent = Przełącznik
#
# io/extra/PlaRom.java
#
# memCSTip = Chip select: 0 disables component
memCSTip = Chip Select: 0 wyłącza komponent
# PlaANDAttr = And
PlaANDAttr = I
PlaOutputsAttr = Wyjście
# ramCSLabel = sel
#ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
# PlaEditWindowTitel = Pla Rom %s edit window
#PlaEditWindowTitel = okno edycji PlaRom %s
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Liczba stanów
ProgrammableGeneratorComponent = Generator programowalny
ramClearMenuItem = Wyczytść zawartość
ramEditMenuItem = Edytuj zawartość...
romContentsAttr = Zawartość
romContentsValue = (kliknij, aby edytować)
#
# io/extra/Slider.java
#
left_to_rightOption = od lewej do prawej
right_to_leftOption = od prawej do lewej
#
# io/HexDigit.java
#
hexDigitDataTip = Dane: nibble do wyświetlania
hexDigitDPTip = DecimalPoint: zapala kropkę dziesiętną
#
# io/IoLibrary.java
#
buttonComponent = Przycisk
dipswitchComponent = Przełącznik DIP
dotMatrixComponent = Matryca LED
hexDigitComponent = Wyświetlacz szesnastkowy
ioActiveAttr = Aktywne gdy wysoki?
ioBackgroundColor = Kolor tła
ioColorAttr = Kolor
ioLibrary = Wejście/Wyjście
ioOffColor = Segment wyłączony
ioOnColor = Segment włączony
joystickComponent = Joystick
ledComponent = LED
pioComponent = Port I/O
# repLBComponent = Reptar Local Bus
#repLBComponent = Reptar Local Bus
RGBledComponent = RGB LED
sevenSegmentComponent = Wyświetlacz 7-segmentowy
ttyComponent = TTY
#
# io/Joystick.java
#
ioBitWidthAttr = Liczba bitów
joystickCoordinateX = Wyjście: Wartość X
joystickCoordinateY = Wyjście: Wartość Y
#
# io/Keyboard.java
#
# keybAvailTip = Available: 1 when buffer contains characters
keybAvailTip = Dostępna: 1 gdy bufor zawiera znaki
keybBufferLengthAttr = Rozmiar bufora
keybClearTip = Wyczyść: 1 czyści bufor
# keybClockTip = Clock: trigger consumes the buffer's front character
keybClockTip = Zegar: używa pierwszego znaku z bufora
keybDesc = klawiatura (wielkość bufora %s)
# keybEnableTip = Read enable: 0 disables clock
keybEnableTip = Read enable: 0 wyłącza zegar
keyboardComponent = Klawiatura
keybOutputTip = Dane: wartość ASCII pierwszego znaku z bufora
#
# io/PortIO.java
#
pioDirection = Typ portu:
pioInput = Tylko wejścia
pioInputs = Wejścia %s
# pioIOMultiple = I/O (per-bit enable)
#pioIOMultiple = I/O (zezwolenie na każdy bit)
# pioIOSingle = I/O (single enable)
#pioIOSingle = I/O (pojedyncze zezwolenie)
pioNumber = Liczba pinów
# pioOutEnable = Output enable
#pioOutEnable = zezwolenie na wyjście
# pioOutEnables = Output enables %s
#pioOutEnables = Wyjście umożliwia %s
pioOutput = Tylko wyjścia
pioOutputs = Wyjścia %s
#
# io/ReptarLocalBus.java
#
# repLBTip = B tip
repLBTip = końcówka B
#
# io/RGBLed.java
#
BLUE = Wejście B
GREEN = Wejście G
RED = Wejście R
#
# io/SevenSegment.java
#
DecimalPoint = Kropka dziesiętna
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
SevenSegDP = Kropka dziesiętna:
#
# io/Tty.java
#
# ttyClearTip = Clear: 1 clears screen
ttyClearTip = Clear: 1 Clears screen
# ttyClockTip = Clock: trigger adds character on input
ttyClockTip = Zegar: wyzwalacz dodaje znak na wejściu
# ttyColsAttr = Columns
ttyColsAttr = Kolumny
# ttyDesc = TTY (%s rows, %s cols)
ttyDesc = TTY (%s rzędów, %s cols)
# ttyDescShort = TTY
ttyDescShort = TTY
# ttyEnableTip = Write enable: 0 disables clock
ttyEnableTip = Aktywacja zapisu: 0 wyłącza zegar
# ttyInputTip = Data: ASCII value of next character to write
ttyInputTip = Dane: Wartość ASCII kolejnego znaku do zapisu
# ttyRowsAttr = Rows
ttyRowsAttr = Rows
#
# io/Video.java
#
# rgbVideoCLK = Clock
rgbVideoCLK = Zegar
# rgbVideoColor = Color Model
rgbVideoColor = Model kolorowy
# rgbVideoComponent = RGB Video
rgbVideoComponent = RGB Video
# rgbVideoCursor = Cursor
rgbVideoCursor = Kursor
# rgbVideoData = Data in %s format
rgbVideoData = Dane w formacie %s
# rgbVideoHeight = Height
rgbVideoHeight = Wysokość
# rgbVideoReset = Reset Behavior
rgbVideoReset = Resetuj zachowanie
# rgbVideoRST = Reset
rgbVideoRST = Resetowanie
# rgbVideoScale = Scale
rgbVideoScale = Skala
# rgbVideoWE = Write Enable
rgbVideoWE = Write Enable
# rgbVideoWidth = Width
rgbVideoWidth = Szerokość
# rgbVideoX = X Coordinate
rgbVideoX = Współrzędna X
# rgbVideoY = Y Coordinate
rgbVideoY = Y Współrzędna
#
# bfh/bcd2sevenseg.java
#
# BCDValue = BCD value
# ==> BCDValue =
# BCD2SevenSegment = BCD to seven segment
BCD2SevenSegment = BCD do siedmiu segmentów
#
# bfh/BfhLibrary.java
#
# BFHMegaFunctions = BFH mega functions
BFHMegaFunctions = BFH mega funkcje
# Bin2BCD = Binary to BCD
Bin2BCD = Binairy do BCD
#
# bfh/bin2bcd.java
#
# BinaryDataBits = Binary data bits
BinaryDataBits = bity danych binarnych
# BinaryInputTip = Binary input
BinaryInputTip = wejście Binairy
#
# memory/AbstractFlipFlop.java
#
# flipFlopClockTip = Clock: state updates on trigger
flipFlopClockTip = Clock: aktualizacja stanu wyzwalacza
# flipFlopNotQTip = Complement of current flip-flop state
flipFlopNotQTip = Uzupełnienie aktualnego stanu klapki
# flipFlopPresetTip = Preset: When 1, pin state to 1 asynchronously
flipFlopPresetTip = Wstępnie ustawiony: Kiedy 1, stan pinów na 1 asynchronicznie
# flipFlopQTip = Current flip-flop state
flipFlopQTip = aktualny stan klapki
# flipFlopResetTip = Clear: When 1, pin state to 0 asynchronously
flipFlopResetTip = Wyczyść: Kiedy 1, stan pinu do 0 asynchronicznie
#
# memory/Counter.java
#
# counterCarryTip = Carry: is 1 when value reaches maximum (minimum if decrementing)
counterCarryTip = Nośność: wynosi 1, gdy wartość osiąga maksimum (minimum w przypadku dekrementowania)
# counterClockTip = Clock: value may update on trigger
counterClockTip = Zegar: wartość może być aktualizowana po wyzwoleniu
# counterComponent = Counter
counterComponent = Licznik
# counterDataTip = Data: value to load into counter
counterDataTip = Dane: wartość do załadowania do licznika
# counterEnableLabel = ct
counterEnableLabel = ct
# counterEnableTip = Enable: when 1, counter increments or decrements
counterEnableTip = Włącz: gdy 1, licznik przyrostów lub dekadencji
# counterGoalAttr = Action On Overflow
counterGoalAttr = Działanie na przelewie
# counterGoalContinue = Continue counting
counterGoalContinue = Kontynuuj liczenie
# counterGoalLoad = Load next value
counterGoalLoad = Załaduj następną wartość
# counterGoalStay = Stay at value
counterGoalStay = Trzymaj się wartości
# counterGoalWrap = Wrap around
counterGoalWrap = Owiń się
# counterLabel = ctr
counterLabel = ctr
# counterLoadTip = Load: when 1, loads from data input
counterLoadTip = Obciążenie: gdy 1, obciążenie z wprowadzania danych
# counterMaxAttr = Maximum Value
counterMaxAttr = Wartość maksymalna
# counterQTip = Output: current value of counter
counterQTip = Wyjście: aktualna wartość licznika
# counterResetTip = Clear: when 1, resets to 0 asynchronously
counterResetTip = Clear: kiedy 1, resetuje się asynchronicznie do 0
# counterUpDownTip = Up Down: when 1, counter increments, when 0, counter decrements
counterUpDownTip = góra-dół: kiedy 1, licznik przyrostów, kiedy 0, licznik dekretacji
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
memAsyncRead = Odczyt asynchroniczny:
# memByte = Use byte enables
#memByte = Użycie bajtu umożliwia
# memDual = Dual
memDual = Dual
# memEnables = Enables:
memEnables = Włącza:
# memLine = Use line enables
#memLine = Linia użytkowa umożliwia
# memLineSize = Line size
#memLineSize = Rozmiar linii
# memMisaligned = Allow misaligned?
memMisaligned = Zezwalać nia brak wyrównania?
# memOcto = Octo
#memOcto = Octo
# memQuad = Quad
#memQuad = Quad
memRaw = Odczytaj po zapisie
memReadBehav = Sposób odczytu
memSingle = Pojedynczy
memWar = Zapisz po odczytaniu
ramAddrWidthAttr = Liczba bitów adresu
ramDataWidthAttr = Liczba bitów danych
# ramSelAttr = Select
ramSelAttr = Wybierz
stdTriggerHigh = Wysoki poziom
stdTriggerLow = Niski poziom
#
# memory/MemMenu.java
#
# ramConfirmClearMsg = Are you sure you wish to zero out the memory?
ramConfirmClearMsg = Czy na pewno chcesz wyzerować pamięć?
# ramConfirmClearTitle = Confirm Clear
ramConfirmClearTitle = Potwierdź Wyczyść
# ramLoadMenuItem = Load Image...
ramLoadMenuItem = Załaduj obraz...
# ramSaveMenuItem = Save Image...
ramSaveMenuItem = Zapisz obraz...
#
# memory/MemoryLibrary.java
#
# dFlipFlopComponent = D Flip-Flop
dFlipFlopComponent = D Flip-Flop
# memoryLibrary = Memory
memoryLibrary = Pamięć
# tFlipFlopComponent = T Flip-Flop
tFlipFlopComponent = T Flip-Flop
#
# memory/Ram.java
#
# ramComponent = RAM
ramComponent = RAM
#
# memory/RamAppearance.java
#
# memAddrTip = Address: location accessed in memory
memAddrTip = Adres: lokalizacja dostępna w pamięci
# memDataTip = Data: value loaded from address
memDataTip = Dane: wartość załadowana z adresu
# memDataTip0 = Data: value loaded from address+0
memDataTip0 = Dane: wartość załadowana z adresu+0
# memDataTip1 = Data: value loaded from address+1
memDataTip1 = Dane: wartość załadowana z adresu+1
# memDataTip2 = Data: value loaded from address+2
memDataTip2 = Dane: wartość załadowana z adresu+2
# memDataTip3 = Data: value loaded from address+3
memDataTip3 = Dane: wartość załadowana z adresu+3
# ramByteEnableTip0 = Byte enable for byte 0
ramByteEnableTip0 = Bajt enable dla bajtu 0
# ramByteEnableTip1 = Byte enable for byte 1
ramByteEnableTip1 = Bajt enable dla bajtu 1
# ramByteEnableTip2 = Byte enable for byte 2
ramByteEnableTip2 = Bajt enable dla bajtu 2
# ramByteEnableTip3 = Byte enable for byte 3
ramByteEnableTip3 = Bajt enable dla bajtu 3
# ramClkTip = Clock: memory value updates on rise from 0 to 1
ramClkTip = Zegar: aktualizacja wartości pamięci przy wzroście od 0 do 1
# ramClrPin = Clear: a one sets all memory locations to 0
ramClrPin = Clear: jeden ustawia wszystkie lokalizacje pamięci na 0
# ramInTip = Input: value to be stored at address
ramInTip = Wejście: wartość, która ma być zapisana pod adresem
# ramInTip0 = Input: value to be stored at address+0
ramInTip0 = Wejście: wartość do zapisania pod adresem+0
# ramInTip1 = Input: value to be stored at address+1
ramInTip1 = Wejście: wartość do zapisania pod adresem+1
# ramInTip2 = Input: value to be stored at address+2
ramInTip2 = Wejście: wartość do zapisania pod adresem+2
# ramInTip3 = Input: value to be stored at address+3
ramInTip3 = wejście: wartość, która ma być zapisana pod adresem+3
# ramLETip0 = Line enable for address+0
ramLETip0 = Włączenie linii dla adresu+0
# ramLETip1 = Line enable for address+1
ramLETip1 = zezwolenie na linię dla adresu+1
# ramLETip2 = Line enable for address+2
ramLETip2 = Włączenie linii dla adresu+2
# ramLETip3 = Line enable for address+3
ramLETip3 = Włączenie linii dla adresu+3
# ramOETip = Load: if 1, load memory to output
ramOETip = Obciążenie: jeżeli 1, to pamięć załadunkowa do wyjścia
# ramWETip = Store: if 1, store input to memory
ramWETip = Zapisz: jeśli 1, zapisz wejście do pamięci
#
# memory/RamAttributes.java
#
# ramBidirDataBus = One bidirectional data bus
ramBidirDataBus = jedna dwukierunkowa magistrala danych
# ramByteEnables = Read write control
ramByteEnables = kontrola zapisu odczytu
# RamClearPin = Use clear pin
RamClearPin = Użyj przezroczystej szpilki
# ramDataAttr = Data bus implementation
ramDataAttr = implementacja magistrali danych
# ramNoByteEnables = Whole word read/write only
ramNoByteEnables = Całe słowo tylko do odczytu/zapisu
# ramSeparateDataBus = Separate data bus for read and write
ramSeparateDataBus = Oddzielna magistrala danych do odczytu i zapisu
# ramTypeAttr = Ram type
ramTypeAttr = typ Ram
# ramTypeNonVolatile = non volatile
# ==> ramTypeNonVolatile =
# ramTypeVolatile = volatile
# ==> ramTypeVolatile =
# ramWithByteEnables = Use byte enables
ramWithByteEnables = Użycie bajtu umożliwia
#
# memory/Random.java
#
# randomClockTip = Clock: value may update on trigger
randomClockTip = CLK: wartość może się aktualizowanć po otrzymaniu sygnału
randomComponent = Generator losowy
randomLabel = losowy
randomNextTip = Enable: przechodzi do nastepnej wartości w sekwencji po otrzymaniu sygnału zegarowego.
randomQTip = Wyjście: bieżąca liczba w sekwencji
randomResetTip = Clear: Kiedy 1, resetuje zegar asynchronicznie do stanu początkowego.
randomSeedAttr = Stan początkowy
randomWidthLabel = Szerokość: %d
#
# memory/Register.java
#
# registerClkTip = Clock: value updates on trigger
#registerClkTip = Clock: aktualizacja wartości przy wyzwalaniu
# registerClrTip = Clear: When 1, pin value to 0 asynchronously
#registerClrTip = Wyczyść: Kiedy 1, wartość pinu do 0 asynchronicznie
registerComponent = Rejestr
# registerDTip = Data: value stored on clock trigger
#registerDTip = Dane: wartość zapisana na wyzwalaczu zegarowym
# registerEnableTip = Enable: When 0, clock triggers are ineffective
#registerEnableTip = Enable: Gdy 0, wyzwalacze zegara są nieskuteczne
# registerLabel = reg
#registerLabel = reg
#registerQTip = Wyjście: aktualna wartość rejestru
registerShowInTab = Pokaż w zakładce "Rejestry"
# registerWidthLabel = (%sb)
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = Edytuj zawartość ROMu
#
# memory/ShiftRegister.java
#
# shiftRegClearTip = Clear: when 1, resets all to 0 asynchronously
shiftRegClearTip = Clear: kiedy 1, resetuje wszystko do 0 asynchronicznie
# shiftRegClockTip = Clock: values may update on trigger
shiftRegClockTip = Clock: wartości mogą być aktualizowane przy wyzwalaniu
# shiftRegInTip = Input: value to be shifted into first stage
shiftRegInTip = Wejście: wartość, która ma być przeniesiona do pierwszego etapu
shiftRegisterComponent = Rejestr przesuwny
shiftRegisterLabel1 = rejestr przesuwny
# shiftRegisterLabel2 = %sx%s
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = liczba etapów
# shiftRegLoadTip = Load: when 1 (with shift = 0), all stages load from inputs
shiftRegLoadTip = LOAD: kiedy 1 (z przesunięciem równym 0), obciążenie wszystkich etapów z wejść
# shiftRegOutTip = Output: is content of last stage
shiftRegOutTip = Wyjście: zawartość ostatniego etapu
shiftRegParallelAttr = Ładowanie równoległe
# shiftRegShiftTip = Shift: shift is disabled when 0
shiftRegShiftTip = Shift: zmiana jest wyłączona, gdy 0
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Selektor bitów
bitSelectorDataTip = Dane
bitSelectorGroupAttr = Bity wyjściowe
bitSelectorOutputTip = Wyjście: wartość wybranej grupy bitów z danych
bitSelectorSelectTip = Wybierz: określa która grupa danych jest wybrana.
#
# plexers/Decoder.java
#
# decoderEnableTip = Enable: when not 0, selected output is 1
# ==> decoderEnableTip =
# decoderOutTip = Output %s
# ==> decoderOutTip =
# decoderSelectTip = Select: identifies which output is 1
# ==> decoderSelectTip =
#
# plexers/Demultiplexer.java
#
# demultiplexerEnableTip = Enable: when not 0, selected output is input
demultiplexerEnableTip = Enable: gdy nie ma wartości 0, wybrane wyjście jest wejściem.
# demultiplexerInTip = Input
demultiplexerInTip = wejście
# demultiplexerOutTip = Output %s
demultiplexerOutTip = wyjście %s
# demultiplexerSelectTip = Select: identifies which output receives input
demultiplexerSelectTip = Wybierz: określa, które wyjście odbiera sygnał wejściowy
#
# plexers/Multiplexer.java
#
# multiplexerEnableTip = Enable: when not 0, output is the selected input
multiplexerEnableTip = Enable: jeśli nie 0, wyjście jest wybranym wejściem.
# multiplexerInTip = Input %s
multiplexerInTip = wejście %s
# multiplexerOutTip = Output
multiplexerOutTip = wyjście
# multiplexerSelectTip = Select: identifies which input becomes output
multiplexerSelectTip = Wybierz: określa, które wejście stanie się wyjściem.
#
# plexers/PlexersLibrary.java
#
decoderComponent = Dekoder
demultiplexerComponent = Demultiplekser
gateSizeAttr = Rozmiar bramki
gateSizeNarrowOpt = Wąska
gateSizeWideOpt = Szeroka
multiplexerComponent = Multiplekser
# plexerDisabledAttr = Disabled Output
plexerDisabledAttr = Wyłączone wyjście
# plexerDisabledFloating = Floating
plexerDisabledFloating = pływające
# plexerDisabledZero = Zero
plexerDisabledZero = Zero
# plexerEnableAttr = Include Enable?
#plexerEnableAttr = Dołączyć Enable?
# plexerLibrary = Plexers
plexerLibrary = Pleksery
# plexerSelectBitsAttr = Select Bits
plexerSelectBitsAttr = Wybór bitów
# plexerThreeStateAttr = Three-state?
plexerThreeStateAttr = Trzy-Stany?
# priorityEncoderComponent = Priority Encoder
priorityEncoderComponent = Priorytetowy koder
#
# plexers/PriorityEncoder.java
#
# priorityEncoderEnableInTip = Enable Input: 0 disables the component
priorityEncoderEnableInTip = Włącz wejście: 0 wyłącza komponent
# priorityEncoderEnableOutTip = Enable Output: 1 if enabled and no inputs are 1
priorityEncoderEnableOutTip = Włącz wyjście: 1 jeśli włączone, a żadne z wejść nie jest 1
# priorityEncoderGroupSignalTip = Group Select: 1 if enabled and any input is 1
priorityEncoderGroupSignalTip = Wybierz grupę: 1 jeśli jest włączony, a dowolne wejście ma wartość 1
# priorityEncoderInTip = Input %s
priorityEncoderInTip = wejście %s
# priorityEncoderOutTip = Output: address of highest-indexed 1 input
priorityEncoderOutTip = Wyjście: adres najwyżej indeksowanego 1 wejścia
#
# StdAttr.java
#
ioLabelColorAttr = Kolor etykiety
stdClassicAppearance = Klasyczny Logisim
stdEvolutionAppearance = Logisim-HolyCross
stdLogisimEvolutionAppearance = Logisim-Evolution
stdDataWidthAttr = Bity danych
stdFacingAttr = Kierunek
# stdFPDataWidthAttr = Float size
# ==> stdFPDataWidthAttr =
stdLabelAttr = Etykieta
stdLabelCenter = Na środku
stdLabelFontAttr = Czcionka etykiety
stdLabelLocAttr = Lokalizacja etykiety
stdLabelVisibility = Etykieta widoczna
stdTriggerAttr = Trigger
stdSelectLocAttr = Wybierz lokalizację
stdSelectBottomLeftOption = Dół/Lewo
stdSelectTopRightOption = Góra/Prawo
#
# tcl/TclLibrary.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = Plik z zawartością TCL
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = Konsola TCL REDS
#
# tcl/TclGeneric.java
#
# tclGeneric = TCL generic
#tclGeneric = TCL generic
# tclInterfaceDefinition = TCL interface VHDL entity
#tclInterfaceDefinition = interfejs TCL Podmiot VHDL
tclInterfaceDefinitionValue = (kliknij, aby edytować)
#
# ttl/AbstractTtlGate.java
#
GNDPin = Pin uziemiający %s
VCCPin = Pin VCC %s
#
# ttl/DisplayDecoder.java
#
# BI = BI
BI = BI
BlankingInputInTip = Wygaszenie
DisplayDecoderComponent = Dekoder wyświetlacza
DisplayDecoderInTip = Wejście
DisplayDecoderOutTip = Wyjście
# ioMultiBit = multi bit
ioMultiBit = multi bit
# LampTestInTip = Lamp test input
#LampTestInTip = wejście do testu lampy
LT = LT
memEnableLabel = pl
RBI = RBI
# RippleBlankingInputInTip = Ripple blanking input
RippleBlankingInputInTip = Wejście wygaszające tętnienia
#
# ttl/TtlLibrary.java
#
ShowInternalStructure = Pokaż wewnętrze
# TTL7400 = 7400: quad 2-input NAND gate
TTL7400 = 7400: poczwórna bramka 2-wejściowa NAND
# TTL7402 = 7402: quad 2-input NOR gate
TTL7402 = 7402: poczwórna bramka 2-wejściowa NOR
# TTL7404 = 7404: hex inverter
TTL7404 = 7404: falownik sześciokątny
# TTL7408 = 7408: quad 2-input AND gate
TTL7408 = 7408: quad 2-wejściowy I bramka
# TTL7410 = 7410: triple 3-input NAND gate
TTL7410 = 7410: potrójna bramka 3-wejściowa NAND
# TTL7411 = 7411: triple 3-input AND gate
TTL7411 = 7411: potrójne 3 wejścia i bramka
# TTL74125 = 74125: quad bus buffer, three-state outputs, negative enable
TTL74125 = 74125: bufor czterobusowy, wyjścia trójstanowe, ujemne zezwolenie
# TTL74157 = 74157: quad 2-line to 1 line data selector
# ==> TTL74157 =
# TTL74158 = 74158: quad 2-line to 1 line data selector, inverted output
# ==> TTL74158 =
# TTL74139 = 74139: Dual 2-line to 4-line decoder
# ==> TTL74139 =
# TTL7413 = 7413: dual 4-input NAND gate(schmitt-trigger)
TTL7413 = 7413: podwójna 4-wejściowa bramka NAND (schmitt-trigger)
# TTL7414 = 7414: hex inverter (schmitt-trigger)
TTL7414 = 7414: falownik sześciokątny (schmitt-trigger)
# TTL74161 = 74161: 4-bit sync counter with clear
# ==> TTL74161 =
# TTL74165 = 74165: 8-bit parallel-to-serial shift register
TTL74165 = 74165: 8-bitowy rejestr przesunięcia równoległego do szeregowego
# TTL74175 = 74175: quad D-flipflop, asynchronous reset
TTL74175 = 74175: quad D-flipflop, reset asynchroniczny
# TTL7418 = 7418: dual 4-input NAND gate(schmitt-trigger)
TTL7418 = 7418: podwójna 4-wejściowa bramka NAND (schmitt-trigger)
# TTL7419 = 7419: hex inverter (schmitt-trigger)
TTL7419 = 7419: falownik sześciokątny (schmitt-trigger)
# TTL7420 = 7420: dual 4-input NAND gate
TTL7420 = 7420: podwójna 4-wejściowa bramka NAND
# TTL7421 = 7421: dual 4-input AND gate
TTL7421 = 7421: podwójne 4 wejścia i brama
# TTL7424 = 7424: quad 2-input NAND gate (schmitt-trigger)
TTL7424 = 7424: poczwórna 2-wejściowa bramka NAND (schmitt-trigger)
# TTL74266 = 74266: quad 2-input XNOR gate
TTL74266 = 74266: quad 2-wejściowa bramka XNOR
# TTL7427 = 7427: triple 3-input NOR gate
TTL7427 = 7427: potrójna bramka 3-wejściowa NOR
# TTL74273 = 74273: octal D-Flipflop with clear
TTL74273 = 74273: ośmiokrotny D-Flipflop z przezroczystą klapką
# TTL74283 = 74283: 4-bit binary full adder
TTL74283 = 74283: 4-bitowa binarna pełna adder
# TTL7430 = 7430: single 8-input NAND gate
TTL7430 = 7430: pojedyncza 8-wejściowa bramka NAND
# TTL7432 = 7432: quad 2-input OR gate
TTL7432 = 7432: poczwórna bramka 2-wejściowa OR
# TTL7434 = 7434: hex buffer gate
# ==> TTL7434 =
# TTL7436 = 7436: quad 2-input NOR gate
TTL7436 = 7436: poczwórna bramka 2-wejściowa NOR
# TTL74377 = 74377: octal D-Flipflop with enable
TTL74377 = 74377: ośmiokątny D-Flipflop z zezwoleniem
# TTL7442 = 7442: BCD to decimal decoder
TTL7442 = 7442: BCD do dekodera dziesiętnego
# TTL7443 = 7443: Excess-3 to decimal decoder
TTL7443 = 7443: Nadmiar-3 do dekodera dziesiętnego
# TTL7444 = 7444: Gray to decimal decoder
TTL7444 = 7444: Dekoder szary do dekodera dziesiętnego
# TTL7447 = 7447: BCD to 7-segment decoder
TTL7447 = 7447: dekoder BCD na 7-segmentowy
# TTL7451 = 7451: dual AND-OR-INVERT gate
TTL7451 = 7451: podwójna brama AND-OR-INVERT
# TTL7454 = 7454: Four wide AND-OR-INVERT gate
TTL7454 = 7454: Cztery szerokie bramy AND-OR-INVERT
# TTL7458 = 7458: dual AND-OR gate
TTL7458 = 7458: podwójna bramka AND-OR
# TTL7464 = 7464: 4-2-3-2 AND-OR-INVERT gate
TTL7464 = 7464: 4-2-3-2 bramka AND-OR-INVERT
# TTL7474 = 7474: dual D-Flipflops with preset and clear
TTL7474 = 7474: podwójne klapki D z ustawieniem wstępnym i przezroczystością
# TTL7485 = 7485: 4-bit magnitude comparator
TTL7485 = 7485: 4-bitowy komparator wielkości
# TTL7486 = 7486: quad 2-input XOR gate
TTL7486 = 7486: quad 2-wejściowa bramka XOR
# VccGndPorts = Enable Vcc and Gnd ports
VccGndPorts = włączenie portów Vcc i Gnd
#
# wiring/BitExtender.java
#
# extenderInAttr = Bit Width In
extenderInAttr = Bitów wejściowych
extenderInputLabel = wejście
extenderInputType = Wejście
# extenderMainLabel = extend
#extenderMainLabel = rozszerzyć
# extenderOneLabel = 1
extenderOneLabel = 1
extenderOneType = Jeden
# extenderOutAttr = Bit Width Out
extenderOutAttr = Bitów wyjściowych
extenderSignLabel = znak
extenderSignType = Znak
# extenderTypeAttr = Extension Type
extenderTypeAttr = Typ rozszerzenia
# extenderZeroLabel = 0
extenderZeroLabel = 0
# extenderZeroType = Zero
extenderZeroType = Zero
#
# wiring/Clock.java
#
clockComponent = Zegar
# clockHighAttr = High Duration
#clockHighAttr = Wysoki czas trwania
# clockLowAttr = Low Duration
#clockLowAttr = Niski czas trwania
# clockPhaseAttr = Phase Offset
clockPhaseAttr = Przesunięcie fazowe
#
# wiring/Constant.java
#
constantComponent = Stała
constantValueAttr = Wartość
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 tyknięcie
clockDurationValue = %s tyknięć
durationLargeMessage = Wartość musi być %s lub mniejsza.
durationSmallMessage = Wartość musi wynosić co najmniej %s.
freqInvalidMessage = Wartość nie jest poprawną liczbą całkowitą.
PORDurationOneValue = 1 sekunda
PORDurationValue = %s sekund
#
# wiring/Pin.java
#
PinCancel = Anuluj
pinComponent = Pin
PinEnterDecimal = Wprowadź wartości dziesiętne
PinEnterFloat = Wprowadz wartości zmiennoprzecinkowe
# pinFrozenQuestion = The pin is tied to the super circuit's state. Create a new circuit state?
pinFrozenQuestion = Pin jest przypisany do stanu superobwodu. Czy stworzyć nowy stan obwodu?
pinFrozenTitle = Pin przypisany do super obwodu.
pinInputName = Wejście
pinInputToolTip = Dodaj pin wejściowy
PinOkay = OK
pinOutputAttr = Wyjście?
pinOutputName = Wyjście
pinOutputToolTip = Dodaj pin wyjściowy
pinPullAttr = Rodzaj ściągania
pinPullDownOption = Ściągnij w dół
pinPullNoneOption = Bez zmian
pinPullUpOption = Podciągnij do góry
pinThreeStateAttr = Trzy-stany?
#
# wiring/PowerOnReset.java
#
# porHighAttr = POR-time
porHighAttr = Czas POR
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Sonda
#
# wiring/ProbeAttributes.java
#
probeNewPin = Kształty strzałek
stdAppearanceAttr = Wygląd
#
# wiring/PullResistor.java
#
pullComponent = Rezystor ściągający
pullTypeAttr = Ściąganie
pullErrorType = Błąd
pullOneType = Do jedynki
pullZeroType = Do zera
#
# wiring/Transistor.java
#
# transistorNDrain = drain: a low source will pull drain low (only when gate is high)
transistorNDrain = odpływ: niskie źródło pociągnie za sobą niski odpływ (tylko gdy brama jest wysoka)
# transistorNGate = gate: when high, allows current to flow through transistor
transistorNGate = bramka: gdy jest wysoki, pozwala na przepływ prądu przez tranzystor
# transistorNSource = source: a low source will pull drain low (only when gate is high)
transistorNSource = źródło: niskie źródło pociągnie za sobą niski odpływ (tylko gdy brama jest wysoka)
# transistorPDrain = drain: a high source will pull drain high (only when gate is low)
transistorPDrain = odpływ: wysokie źródło będzie wyciągać odpływ wysoko (tylko przy niskiej bramie)
# transistorPGate = gate: when low, allows current to flow through transistor
transistorPGate = bramka: gdy jest niski, pozwala na przepływ prądu przez tranzystor
# transistorPSource = source: a high source will pull drain high (only when gate is low)
transistorPSource = źródło: wysokie źródło pociągnie za sobą wysoki odpływ (tylko gdy brama jest niska)
# transistorTypeAttr = Type
transistorTypeAttr = Typ
# transistorTypeN = N-Type
transistorTypeN = N-TypeN
# transistorTypeP = P-Type
transistorTypeP = P-TypeP
#
# wiring/TransmissionGate.java
#
# transmissionGateDrain = drain: controlled by source, depending on p-gate and n-gate
transmissionGateDrain = odpływ: sterowany przez źródło, w zależności od p-gate i n-gate
# transmissionGateNGate = n-gate: when low, allows low source to pass through to drain
transmissionGateNGate = n-gate: gdy jest niski, pozwala na przejście niskiego źródła do odpływu wody
# transmissionGatePGate = p-gate: when high, allows high source to pass through to drain
transmissionGatePGate = p-gate: gdy jest wysoki, pozwala na przejście wysokiego źródła do odpływu wody
# transmissionGateSource = source: controls drain, depending on p-gate and n-gate
transmissionGateSource = źródło: steruje odpływem w zależności od p-gate i n-gate
#
# wiring/Tunnel.java
#
# tunnelComponent = Tunnel
tunnelComponent = Tunel
#
# wiring/WiringLibrary.java
#
# extenderComponent = Bit Extender
extenderComponent = Extender bitów
# groundComponent = Ground
groundComponent = Masa
# noConnectionComponent = Do not connect
noConnectionComponent = Nie podłączaj
# powerComponent = Power
powerComponent = Zasilanie
# transistorComponent = Transistor
transistorComponent = Tranzystor
# transmissionGateComponent = Transmission Gate
transmissionGateComponent = Brama transmisyjna
# wiringLibrary = Wiring
wiringLibrary = Przewody
# input.output.extra = Input/Output Extra
# ==> input.output.extra =
