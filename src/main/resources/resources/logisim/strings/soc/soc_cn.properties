#
# bus/SocBusAttributes.java
#
SocBusTraceSize =总线位宽：
SocBusTraceVisible =可见性：
#
# bus/SocBusMenuProvider.java
#
insertTrans =插入总线事务
SocBusMemMap =显示内存映射
SocBusTraceWindow =显示总线事务跟踪
SocInsertTransWindowTitle =将事务插入总线：
TraceWindowTitleDoubleClickOnTraceToRemoveTrace =总线跟踪窗口(双击跟踪可将其删除)
#
# data/SocBusInfo.java
#
SocBusNotConnected =未连接到总线
#
# data/SocBusStateInfo.java
#
SocBusNoTrace =没有任何痕迹
SocMemMapWindowTitle =总线内存映射：
SocMemoryMapOk =关
SocMemoryMapTitle =内存映射(红色表示重叠的内存区域)：
#
# data/SocBusTransaction.java
#
SocBusStateMaster =启动器：
SocBusStateNoDataMax10chars =无数据
SocBusStateSlave =应答者：
SocBusStateTraceIndex =交易编号：
SocTransactionByteAccesNoSupport =从机不支持字节访问。
SocTransactionByteAccesNoSupportShort =无字节访问
SocTransactionHalfWordAccesNoSupport =从机不支持半字访问。
SocTransactionHalfWordAccesNoSupportShort =无硬件访问
SocTransactionMisalignedAddress =从设备检测到地址未对齐。
SocTransactionMisalignedAddressShort =米萨尔。地址。
SocTransactionMultipleSlaveAnswers =多个从属服务器响应一个事务。请检查一下您的奴隶的内存映射。
SocTransactionMultipleSlaveAnswersShort =多个奴隶
SocTransactionNoBusConnected =主部件没有连接到任何SoC总线。请将主机连接到总线组件。
SocTransactionNoBusConnectedShort =没有公交车
SocTransactionNoneAtomicRW =请求非原子读/写操作。这是不允许的。
SocTransactionNoneAtomicRWShort =无原子RW
SocTransactionNoRespons =没有从属组件响应该请求。请检查请求的内存地址和系统的内存映射。
SocTransactionNoResponsShort =无响应
SocTransactionNoSlavesAttached =连接到主机的总线没有连接从机。请把一些奴隶绑在公共汽车上。
SocTransactionNoSlavesAttachedShort =没有从机
SocTransactionReadOnlyAccessError =从机仅支持对此地址的读取访问
SocTransactionReadOnlyAccessErrorShort =只读
SocTransactionRegisterDoesNotExist =从设备不支持对此地址的任何访问
SocTransactionRegisterDoesNotExistShort =禁止访问
SocTransactionSuccessfull =未发生错误，交易成功。
SocTransactionSuccessfullShort =成功
SocTransactionUnknownError =奇怪的是，此错误消息永远不会出现，它代表logisim中的错误。
SocTransactionUnknownErrorShort =Bug！
SocTransactionWordAccesNoSupport =Slave不支持字访问。
SocTransactionWordAccesNoSupportShort =无法访问Word
SocTransactionWriteOnlyAccessError =从机不支持对此地址执行读取操作。
SocTransactionWriteOnlyAccessErrorShort =只写
#
# data/SocMemMapModel.java
#
SocMemMapEmpty =空(没有从机)
SocMemMapEndAddress =结束地址：
SocMemMapSlaveName =组件名称：
SocMemMapStartAddress =起始地址：
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus =请选择要连接的总线
SocBusSelectAttr =连接的总线
SocBusSelectAttrClick =单击以选择
SocManagerNoBusses =没有可用的总线，请将SoC总线添加到您的逻辑示意图
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet =已成功将ELF文件加载到内存中。\n已将可执行文件的入口点设置为处理器。\n\n重要信息：\n由于ELF文件没有关于异常向量的信息，\n您必须自己控制它们！
SocUpMenuAsmWindow =开放式汇编程序
SocUpMenuCpuAsmWindowTitle =CPU汇编器：
SocUpMenuCpuProgramWindowTitle =CPU反汇编程序：
SocUpMenuCpuStateWindowTitle =CPU的处理器状态：
SocUpMenuErrorReadingElfTitle =读取ELF文件时出错
SocUpMenuReadElf =读取ELF文件
SocUpMenuSelectElfFile =选择要导入的ELF文件
SocUpMenuShowProgram =显示加载的程序
SocUpMenuShowState =显示CPU状态
#
# data/SocUpSimulationState.java
#
SocUpSimHalt =已停止
SocUpSimHaltBreak =断点
SocUpSimHaltError =错误
SocUpSimRunning =正在运行
SocUpSimStateLabel =SIM卡状态：
SocUpSimstateStart =开始
SocUpSimstateStop =暂停
SocUpUnknown =未知
#
# file/ElfHeader.java
#
ElfHeaderEIClassError =不是32位或64位ELF文件
ElfHeaderEIDataError =不是小端或大端的编码文件
ElfHeaderIncorrectEISize =EI部分的大小不正确
ElfHeaderIncorrectESize =E部分的大小不正确
ElfHeaderIncorrectMagic =该文件不包含正确的精灵魔法；可能不是精灵文件
ElfHeaderNoErrors =标题正确
ElfHeaderReadingFileError =读取文件时出错
ElfHeaderUnknownArchitecture =未知架构
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound =找不到程序头。
ProgHeaderReadError =读取程序标题时出错。
ProgHeaderSizeError =程序头中的大小不匹配。
ProgHeaderSuccess =成功
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError =找到多个字符串表，暂时不支持。
ElfSectHeadMultiSymtabError =发现多个符号表，暂时不支持；
ElfSectHeadNotFound =找不到节标题。
ElfSectHeadReadError =读取节标题时出错。
ElfSectHeadSizeError =节标题中的大小不匹配。
ElfSectHeadStingIdxError =错误字符串索引。
ElfSectHeadStingNotFound =找不到节名。
ElfSectHeadStingReadError =读取字符串表时出错。
ElfSectHeadStingTypeError =字符串类型错误。
ElfSectHeadSuccess =成功
ElfSymTableNotFound =找不到符号表。
ElfSymTableReadError =无法读取符号表。
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet =Logisim尚不支持64位ELF文件。
ProcReadElfArchError =ELF文件用于\“%s\”处理器，而它应该用于\“%s\”处理器。
ProcReadElfEndianMismatch =字节顺序不匹配，ELF文件是\“%s\”，而处理器请求的是\“%s\”。
ProcReadElfErrorOpeningFile =无法打开精灵文件
ProcReadElfLoadableSectionNotFound =在ELF文件中找不到可加载节。
ProcReadElfLoadableSectionReadError =读取可加载节时出错。
ProcReadElfLoadableSectionSizeError =可加载段中的大小不匹配。
ProcReadElfLoadableSectionTooBig =Logisim支持的大小越大，可加载段的大小越大。
ProcReadElfMemoryError =将可加载节写入内存时出错。\n请确保您有可用于内存区域的SoC内存组件：\n%s.%s
ProcReadElfNotExecutable =ELF文件不是可执行文件
ProcReadElfSuccess =成功
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention =部件文件(.asm、.S)
AsmPanAssemble =汇编代码(Alt-A)
AsmPanDocumentChangedSave =您的文档中有更改，是否保存？
AsmPanErrorCreateFile =无法创建程序集文件。
AsmPanErrorReadingFile =无法读取该文件
AsmPanNextError =跳至下一个错误(CTRL-N)
AsmPanOpenFile =读取文件(CTRL-L)
AsmPanPreviousError =跳到上一个错误(CTRL-P)
AsmPanReadAsmFile =选择要读取的文件
AsmPanRun =运行代码(Alt-R)
AsmPanSaveAsmFile =选择要保存的文件
AsmPanSaveFile =保存文件(CTRL-S)
AsmPanSaveFileAs =将文件另存为
AsmPanSaveFirstBeforeOpen =您的文档中有更改\n是否要在打开新文件之前保存这些更改？
AssemblerAssembleSuccess =成功！\n在您的代码中没有发现错误。
AssemblerRunSuccess =已成功将程序加载到内存。\n若要运行该程序，请确保：\n-启用滴答\n-将CPU设置为运行模式。
AssemblerUnableToDownload =无法将程序存储到内存，\n请确保正确的内存位置\n有足够的内存可用。
RV32imAsmLineIndicator =第%d行，共%d行
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint =删除断点
RV32imSetBreakpoint =添加断点
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress =总线地址：0x
SocTransInsAtomicRequest =原子事务
SocTransInsByteAccess =字节事务
SocTransInsHalfWordAccess =半字事务(2字节)
SocTransInsInputData =要写入的数据：0x
SocTransInsInsertTransaction =将事务插入总线
SocTransInsManual =手动插入
SocTransInsReadData =返回的数据：
SocTransInsReadRequest =总线读取请求
SocTransInsTransResultTitle =插入的事务的结果：
SocTransInsWordAccess =字处理(4字节)
SocTransInsWriteRequest =总线写入请求
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction =组件：
Rv32imBinInstruction =操作码：
Rv32imEmptyTrace =没有可用的执行跟踪
Rv32imExecutionTrace =执行跟踪(上次在顶部执行)：
Rv32imRegisterFile =寄存器文件：
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl =仿真控制
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb =清除键盘
JtagUartKeybAvailable =可用的键盘数据
JtagUartKeybData =键盘数据
JtagUartKeybReadEnable =键盘读取启用
JtagUartTtyClear =TTY清除
JtagUartTtyData =TTY数据
JtagUartTtyWrite =TTY写入数据
SocJtagUartComponent =JTAG UART
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold =读取IRQ阈值
JtagUartWriteIrqThreshold =写入IRQ阈值
UartJtagREADFifoSize =读取FIFO大小：
UartJtagWriteFifoSize =写入FIFO大小：
#
# memory/SocMemory.java
#
SocMemBase =底座：
SocMemoryComponent =存储器模拟器
SocMemSizeStr =大小：
#
# memory/SocMemoryAttributes.java
#
SocMemSize =字节地址宽度：
SocMemStartAddress =起始地址：
#
# nios2/Nios2.java
#
Nios2A =一个
Nios2B =B类
Nios2C =C
Nios2Component =Nios2S模拟器
Nios2Dataa =数据A
Nios2Datab =数据B
Nios2Done =完成
Nios2N =n
Nios2ReadRa =读取范围
Nios2ReadRb =读取RB
Nios2Result =结果
Nios2Start =开始
Nios2WriteRc =写入RC
Rv32imClockInput =时钟输入
Rv32imIrqInput =IRQ输入%s
Rv32imResetInput =重置输入
#
# nios2/Nios2Attributes.java
#
nios2BreakVector =中断向量
rv32ExceptionVector =异常向量
rv32imIrqWidth =IRQ线路数
rv32ResetVector =重置向量
rv32StateVisible =状态可见：
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments =需要四个参数
Nios2DonePinError =未定义完成引脚或处于错误状态，无法继续。\n请检查完成引脚。
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction =执行从内存系统加载时出错：
LoadStoreErrorInWriteTransaction =执行存储到内存系统时出错：
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue =需要立即值
AssemblerExpectedNoArguments =不需要任何参数
AssemblerExpectedOneArgument =需要一个参数
AssemblerExpectedTwoArguments =需要两个参数
AssemblerExpectedZeroOrOneArgument =应为无参数或只有一个参数
AssemblerImmediateOutOfRange =立即值超出范围
AssemblerUnknownRegister =未知寄存器
Nios2AssemblerExpectedBracketedRegister =需要带括号的寄存器，例如(R1)
Nios2AssemblerExpectedImmediateIndexedRegister =应为立即索引寄存器，例如5(R1)
Nios2CannotUseControlRegister =无法在此上下文中使用控制寄存器
Nios2CannotUseCustomRegister =无法在此上下文中使用自定义寄存器
Nios2ExpectedControlRegister =需要控制寄存器(例如CTL4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments =需要三个参数
AssemblerExpextedImmediateOrLabel =应为立即值或标签
#
# nios2/Nios2State.java
#
Nios2Bstatus =B状态
Nios2Estatus =E状态
Nios2Status =状态
RV32imBreakPointReached =由于在当前指令处设置了断点，因此暂停执行。
RV32imFetchExecutionError =执行取数指令时出错
RV32imFetchInvalidInstruction =获取的指令无效
RV32imFetchInvInstrAsm =无效指令！
RV32imFetchTransaction =->获取交易错误。
Rv32imProgramCounter =PC：
SocHiddenForFasterSimulation =隐藏内容以加快模拟速度
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister =需要寄存器
#
# pio/PioAttributes.java
#
SicPioIrqType =IRQ类型：
SocPioAnyEdge =任何边
SocPioBidir =双向(三态)端口
SocPioCaptureEdge =捕获类型：
SocPioDirection =方向：
SocPioFallingEdge =下降沿
SocPioGenIRQ =IRQ已启用：
SocPioInout =输入和输出端口都有
SocPioInputCaptureBit =捕获位清除：
SocPioInputOnly =仅限输入端口
SocPioInputsSyncCapture =同步捕获：
SocPioIrQEdge =边缘
SocPioIrqLevel =级别
SocPioOutputIndividualBits =输出位设置/清除：
SocPioOutputOnly =仅限输出端口
SocPioOutputResetValue =输出复位值：
SocPioRisingEdge =上升沿
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile =无法创建头文件和/或c文件！
ExportC =导出C模板
PioMenuBidirFunctionsRemark =/*使用以下功能可以设置或读取双向寄存器。\n*1表示尊重。位是输出，0表示它是输入\n*注意：只使用较低的%s位。\n*/
PioMenuCaptureAll =独立于参数“VALUE”的值清除捕获寄存器中的所有位
PioMenuCaptureAny =至少从0更改为1或从1更改为0
PioMenuCaptureBit =清除捕获寄存器中参数“VALUE”中为1的位
PioMenuCaptureFalling =至少一个从1到0的更改
PioMenuCaptureRising =至少一个从0到1的更改
PioMenuEdgeCaptureRemark =/*使用以下功能可以清除或读出边沿捕获寄存器\n*如果读出边沿寄存器，\n*如果读出边沿寄存器，则相应的输入\n*具有HAT%s，\n*否则相应的输入没有更改。\n*\n*写入此寄存器将为%s。\n*注意：仅使用较低的%s位。\n*/
PioMenuInputDataFunctionRemark =/*使用以下函数可以\n*读出PIO的输入值。\n*此函数返回各自的值\n*注意：只有较低的%s位有效\n*/
PioMenuIrqEdge =捕获寄存器中的相应位
PioMenuIrqLevel =相应的输入
PioMenuMaskFunctionsRemark =/*使用以下函数可以设置或读出中断屏蔽寄存器。\n*特定位置上的1表示如果%s等于1，\n*将生成中断。\n*注意：仅使用较低的%s位。\n*/
PioMenuOutClearRemark =/*使用以下函数，参数“value”中为1的位将强制\n*相应的输出为0\n*注意：仅使用较低的%s位。\n*/
PioMenuOutputDataFunctionRemark =/*使用以下函数可以设置\n*PIO的输出值。\n*此函数将新的输出值作为参数“value”\n*注意：只有提供的参数“value”的低%s位才有效\n*/
PioMenuOutSetRemark =/*使用以下函数，参数“value”中为1的位将强制\n*相应的输出为1\n*注意：仅使用较低的%s位。\n*/
SelectDirectoryToStoreC =设置存储C模板的目录
SuccesCreatingHeaderAndCFile =已成功创建文件：\n%s\n和\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx =双目录位%s
SocPioBidirs =双向销
SocPioComponent =并行输入/输出扩展器
SocPioInputPinx =输入位%s
SocPioInputs =输入引脚
SocPioIrqOutput =IRQ输出
SocPioOutputPinx =输出位%s
SocPioOutputs =输出引脚
SocPioResetInput =重置输入
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent =RISC V IM模拟器
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments =需要一个或两个参数
Rv32imAssemblerExpectedTwoOrThreeArguments =需要两个或三个参数
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented =目前未实现环境调用和断点
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG =Bug！
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister =需要带括号的寄存器，例如(X1)
RV32imAssemblerExpectedImmediateIndexedRegister =需要立即索引寄存器，例如5(X1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet =不支持的ASM操作码
Rv32imMOINotImplmented =目前没有实现存储器排序指令
#
# Soc.java
#
SocBusComponent =SoC总线模拟器
socLibrary =SOC
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode =未知操作码
UnknownInstruction =未知指令
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint =假定最低地址以指令为入口点。\n为确保CPU在正确的地址开始执行，\n请在CPU应开始执行程序的位置\n添加名为‘_start’的标签。
AssemblerCannotUseInsideMacro =此构造不能在宏定义内使用
AssemblerEndOfMacroNotFound =找不到宏定义的结尾
AssemblerExpectedMacroName =需要宏的名称
AssemblerExpectedMacroNrOfParameters =预期的宏参数数量
AssemblerExpectingLabelIdentifier =需要标签
AssemblerMissingLabelBefore =对于此运算符，应该是一个标签
AssemblerNoExecutableSection =找不到可以执行的指令。
AssemblerReguiresNumberAfterMath =在数学运算之后应该跟一个数字
AssemblerUnknowCharacter =未知字符
AssemblerWrongClosingBracket =不支持此右括号
AssemblerWrongOpeningBracket =不支持此左方括号
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel =无法确定此标签的地址
AssemblerCouldNotFindValueForDefine =找不到此参数的定义
AssemblerDivZero =除以零误差
AssemblerExpectedImmediateValueAfterMath =数学运算后需要立即值
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported =标签名称必须唯一，找到此标签的多个定义
AssemblerDuplicatedName =.eque和标签不能使用相同的名称
AssemblerDuplicatedSectionError =节名称必须唯一，找到多个具有此名称的节
AssemblerExpectedLabel =需要标签
AssemblerExpectedLabelAndNumber =应为标签后跟立即值
AssemblerExpectedParameter =此位置需要一个参数
AssemblerExpectingNumber =需要一个数字
AssemblerExpectingPositiveNumber =应为正数
AssemblerExpectingSectionName =需要此节的名称
AssemblerExpectingString =应为字符串
AssemblerMacroIncorrectNumberOfParameters =指定的宏参数数目不正确
AssemblerOverlappingSections =此部分与另一个部分重叠
AssemblerUnknownIdentifier =我不知道这个标识符
AssemblerUnknownLabel =此标签尚未定义，因此我无法使用它
AssemblerUnsupportedAssemblerInstruction =此汇编指令未知
AssemblerValueOutOfRange =值超出范围
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock =宏相互调用导致死锁情况
AssemblerMacroCannotUseRecurency =宏正在调用自身，导致死锁情况
AssemblerMacroParameterNotDefined =未定义此宏参数，请检查宏定义中的参数数量
#
# vga/SocVgaShape.java
#
SocVgaComponent =VGA屏幕
#
# vga/VgaAttributes.java
#
VgaBufferAddress =像素缓冲区地址：
VgaInitialDisplayMode =显示模式：
VgaSoftMode =软件%s：
VgaStartAddress =基址：
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions =/*使用以下函数可以操作VGA模式。\n*读取VGA模式将返回支持的模式(请参阅上面对可能模式的定义)\n*写入支持的模式将更改VGA显示器的显示模式\n*/
