#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Leiterbahngröße:
SocBusTraceVisable = Spuren sichtbar:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Einfügen einer Bustransaktion
SocBusMemMap = Speicherkarte anzeigen
SocBusTraceWindow = Bustransaktion(en) Trace anzeigen
SocInsertTransWindowTitle = Fügen Sie eine Transaktion auf dem Bus ein:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Bus-Trace-Fenster (Doppelklick auf eine Trace, um sie zu entfernen)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Nicht an einen Bus angeschlossen
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Keine Spuren vorhanden
SocMemMapWindowTitle = Speicherabbildung für den Bus:
SocMemoryMapOk = Schließen
SocMemoryMapTitle = Memory Map (rot zeigt überlappende Speicherbereiche an):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Initiator:
SocBusStateNoDataMax10chars = keine Daten
SocBusStateSlave = Responder:
SocBusStateTraceIndex = Transaktion Nr....:
SocTransactionByteAccesNoSupport = Der Slave unterstützt keine Bytezugriffe.
SocTransactionByteAccesNoSupportShort = Kein Bytezugriff
SocTransactionHalfWordAccesNoSupport = Der Slave unterstützt keine Halbwortzugriffe.
SocTransactionHalfWordAccesNoSupportShort = Kein HW-Zugang
SocTransactionMisallignedAddress = Der Slave hat eine falsch ausgerichtete Adresse erkannt.
SocTransactionMisallignedAddressShort = Misal. Adressat
SocTransactionMultipleSlaveAnswers = Mehrere Slaves antworteten auf eine Transaktion. Bitte überprüfen Sie die Speicherkarte Ihrer Slaves.
SocTransactionMultipleSlaveAnswersShort = Mehrere Slaves
SocTransactionNoBusConnected = Die Master-Komponente ist nicht an einen Soc-Bus angeschlossen. Bitte verbinden Sie den Master mit einer Buskomponente.
SocTransactionNoBusConnectedShort = Kein Bus
SocTransactionNoneAtomicRW = Eine atomare Lese-/Schreibaktion wird nicht angefordert. Dies ist nicht erlaubt.
SocTransactionNoneAtomicRWShort = Kein Atom RW
SocTransactionNoRespons = Keine Slave-Komponente antwortete auf die Anfrage. Bitte überprüfen Sie die Speicheradresse der Anforderung und die Speicherkarte Ihres Systems.
SocTransactionNoResponsShort = Keine Antwort
SocTransactionNoSlavesAttached = Der Bus, der mit dem Master verbunden ist, hat keine Slaves angeschlossen. Bitte verbinden Sie einige Slaves mit dem Bus.
SocTransactionNoSlavesAttachedShort = Keine Sklaven
SocTransactionReadOnlyAccessError = Der Slave unterstützt nur Lesezugriffe auf diese Adresse.
SocTransactionReadOnlyAccessErrorShort = Nur Lesen
SocTransactionRegisterDoesNotExist = Der Slave unterstützt keinen Zugriff auf diese Adresse.
SocTransactionRegisterDoesNotExistShort = Kein Zugriff
SocTransactionSuccessfull = Es ist kein Fehler aufgetreten, die Transaktion ist erfolgreich.
SocTransactionSuccessfullShort = Erfolg
SocTransactionUnknownError = Seltsam, diese Fehlermeldung sollte nie auftreten und stellt einen Fehler in logisim dar.
SocTransactionUnknownErrorShort = BUG!
SocTransactionWordAccesNoSupport = Der Slave unterstützt keine Wortzugriffe.
SocTransactionWordAccesNoSupportShort = Kein Wortzugriff
SocTransactionWriteOnlyAccessError = Der Slave unterstützt keine Lesevorgang an dieser Adresse.
SocTransactionWriteOnlyAccessErrorShort = Nur Schreiben
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Leer (keine Slaves)
SocMemMapEndAddress = Endadresse:
SocMemMapSlaveName = Name der Komponente:
SocMemMapStartAddress = Startadresse:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Bitte wählen Sie einen Bus aus, mit dem Sie sich verbinden möchten.
SocBusSelectAttr = Angeschlossener Bus
SocBusSelectAttrClick = Klicken Sie hier, um auszuwählen
SocManagerNoBusses = Keine Busse verfügbar, bitte fügen Sie einen SOC-Bus zu Ihrem Schaltplan hinzu.
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Die Elf-Datei wurde erfolgreich in den Speicher geladen.\nDer Einstiegspunkt der ausführbaren Datei wurde auf den Prozessor gesetzt.\n\nWichtig:\n   Da die Elf-Datei keine Informationen über die Ausnahmevektoren hat.\n   Du musst sie selbst kontrollieren!
SocUpMenuAsmWindow = Assembler öffnen
SocUpMenuCpuAsmWindowTitle = Assembler für CPU :
SocUpMenuCpuProgramWindowTitle = disassembler für cpu :
SocUpMenuCpuStateWindowTitle = prozessorzustand für cpu :
SocUpMenuErrorReadingElfTitle = Fehler beim Lesen der Elf-Datei
SocUpMenuReadElf = Elf-Datei lesen
SocUpMenuSelectElfFile = Elf-Datei zum Importieren auswählen
SocUpMenuShowProgram = Geladenes Programm anzeigen
SocUpMenuShowState = CPU-Status anzeigen
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Angehalten
SocUpSimHaltBreak = Haltepunkt
SocUpSimHaltError = Fehler
SocUpSimRunning = Laufen
SocUpSimStateLabel = Sim-Zustand:
SocUpSimstateStart = Start
SocUpSimstateStop = Pause
SocUpUnknown = Unbekannt
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Keine 32- oder 64-Bit-Elf-Datei
ElfHeaderEIDataError = Nicht eine kleine oder große endianisch kodierte Datei.
ElfHeaderIncorrectEISize = Die Größe für den EI-Abschnitt ist falsch.
ElfHeaderIncorrectESize = Die Größe für den E-Profil ist falsch.
ElfHeaderIncorrectMagic = Die Datei enthält nicht die richtige elf-magic; wahrscheinlich keine elf-Datei.
ElfHeaderNoErrors = Kopf ist korrekt
ElfHeaderReadingFileError = Fehler beim Lesen der Datei
ElfHeaderUnknownArchitecture = Unbekannte Architektur
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Programmkopf nicht gefunden.
ProgHeaderReadError = Fehler beim Lesen des Programmkopfes.
ProgHeaderSizeError = Größenabweichung im Programmkopf.
ProgHeaderSuccess = Erfolg
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Es wurden mehrere Stringtabellen gefunden, die im Moment nicht unterstützt werden.
ElfSectHeadMultiSymtabError = Es wurden mehrere Symboltabellen gefunden, die im Moment nicht unterstützt werden;
ElfSectHeadNotFound = Abschnittsüberschrift nicht gefunden.
ElfSectHeadReadError = Fehler beim Lesen der Abschnittsüberschrift.
ElfSectHeadSizeError = Größenabweichung in der Abschnittsüberschrift.
ElfSectHeadStingIdxError = Fehler Zeichenkettenindex.
ElfSectHeadStingNotFound = Abschnittsname nicht gefunden.
ElfSectHeadStingReadError = Fehler beim Lesen der Stringtabelle.
ElfSectHeadStingTypeError = Zeichenkettentypfehler.
ElfSectHeadSuccess = Erfolg
ElfSymTableNotFound = Die Symboltabelle konnte nicht gefunden werden.
ElfSymTableReadError = Die Symboltabelle konnte nicht gelesen werden.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim unterstützt noch keine 64-Bit-Elf-Dateien.
ProcReadElfArchError = Die Elf-Datei ist für einen "%s" Prozessor, während sie für einen "%s" Prozessor sein sollte.
ProcReadElfEndianMismatch = Endianische Diskrepanz, die Elfendatei ist "%s", während der Prozessor nach"%s" gefragt hat.
ProcReadElfErrorOpeningFile = Elf-Datei kann nicht geöffnet werden
ProcReadElfLoadableSectionNotFound = Ladbarer Abschnitt nicht in der Elf-Datei gefunden.
ProcReadElfLoadableSectionReadError = Fehler beim Lesen des ladbaren Abschnitts.
ProcReadElfLoadableSectionSizeError = Größenabweichung im belastbaren Abschnitt.
ProcReadElfLoadableSectionTooBig = Die Größe des ladbaren Abschnitts ist größer als die von logisim unterstützte Größe.
ProcReadElfMemoryError = Es ist ein Fehler beim Schreiben eines ladbaren Abschnitts in den Speicher aufgetreten.\nStellen Sie sicher, dass Sie eine SOC-Speicherkomponente für den Speicherbereich zur Verfügung haben:\n%s....%s
ProcReadElfNotExecutable = Die elf-Datei ist keine ausführbare Datei.
ProcReadElfSuccess = Erfolg
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Assembly-Dateien (.asm,.S)
AsmPanAssemble = Den Code zusammensetzen (ALT-A)
AsmPanDocumentChangedSave = Es gibt Änderungen in Ihrem Dokument, speichern Sie sie?
AsmPanErrorCreateFile = Es ist nicht möglich, die Assembly-Datei zu erstellen.
AsmPanErrorReadingFile = Die Datei konnte nicht gelesen werden.
AsmPanNextError = Zum nächsten Fehler springen (STRG-N)
AsmPanOpenFile = Eine Datei lesen (STRG-L)
AsmPanPreviousError = Zum vorherigen Fehler springen (STRG-P)
AsmPanReadAsmFile = Wählen Sie eine Datei zum Lesen aus
AsmPanRun = Den Code ausführen (ALT-R)
AsmPanSaveAsmFile = Wählen Sie eine Datei zum Speichern aus
AsmPanSaveFile = Datei speichern (STRG-S)
AsmPanSaveFileAs = Datei speichern unter
AsmPanSaveFirstBeforeOpen = Es gibt Änderungen in Ihrem Dokument.\nMöchten Sie sie speichern, bevor Sie eine neue Datei öffnen?
AssemblerAssembleSuccess = Erfolgreich!\nEs wurden keine Fehler in Ihrem Code gefunden.
AssemblerRunSuccess = Das Programm wurde erfolgreich in den Speicher geladen.\nUm das Programm auszuführen, stellen Sie bitte sicher, dass es funktioniert:\na) du aktivierst die Ticks\nb) Sie stellen die CPU in den Betriebsmodus.
AssemblerUnableToDownload = Das Programm kann nicht im Speicher gespeichert werden,\nBitte stellen Sie sicher, dass Sie genügend Speicherplatz zur Verfügung haben.\nan den richtigen Speicherplätzen.
RV32imAsmLineIndicator = Zeile %d von %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Haltepunkt entfernen
RV32imSetBreakpoint = Haltepunkt hinzufügen
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Busadresse: 0x
SocTransInsAtomicRequest = Atomare Transaktion
SocTransInsByteAccess = Byte-Transaktion
SocTransInsHalfWordAccess = Halbworttransaktion (2 Bytes)
SocTransInsInputData = Daten zum Schreiben: 0x
SocTransInsInsertTransaction = Fügen Sie die Transaktion in den Bus ein.
SocTransInsManual = Manuell eingelegt
SocTransInsReadData = Daten wurden zurückgegeben:
SocTransInsReadRequest = Bus-Leseanforderung
SocTransInsTransResultTitle = Ergebnis der eingefügten Transaktion:
SocTransInsWordAccess = Word-Transaktion (4 Bytes)
SocTransInsWriteRequest = Bus-Schreibanforderung
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Montage:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = Keine Ausführungsspuren verfügbar
Rv32imExecutionTrace = Ausführungs-Trace (zuletzt oben ausgeführt):
Rv32imRegisterFile = Datei registrieren:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Simulationssteuerung
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Tastatur löschen
JtagUartKeybAvailable = Tastaturdaten verfügbar
JtagUartKeybData = Keyboard-Daten
JtagUartKeybReadEnable = Lesefreigabe der Tastatur
JtagUartTtyClear = TTY klar
JtagUartTtyData = TTY-Daten
JtagUartTtyWrite = TTY schreibt Daten
SocJtagUartComponent = Jtag Uart Komponente
#
# jtaguart/JtagUartAttributes.java
#
JtagSize1024 = 1k
JtagSize128 = 128
JtagSize16 = 16
JtagSize16384 = 16k
JtagSize2048 = 2k
JtagSize256 = 256
JtagSize32 = 32
JtagSize32768 = 32k
JtagSize4096 = 4k
JtagSize512 = 512
JtagSize64 = 64
JtagSize8 = 8
JtagSize8192 = 8k
JtagUartReadIrqThreshold = IRQ-Schwellenwert lesen
JtagUartWriteIrqThreshold = Schreiben des IRQ-Schwellenwerts
UartJtagREADFifoSize = FIFO-Größe lesen:
UartJtagWriteFifoSize = Schreiben Sie die FIFO-Größe:
#
# memory/SocMemory.java
#
SocMemBase = Basis:
SocMemoryComponent = Speichersimulator
SocMemSizeStr = Größe:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Breite der Byte-Adresse:
SocMemStartAddress = Startadresse:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Nios2s Simulator
Nios2Dataa = Daten A
Nios2Datab = Daten B
Nios2Done = Erledigt
Nios2N = N
Nios2ReadRa = Lesen Sie Ra
Nios2ReadRb = Rb lesen
Nios2Result = Ergebnis
Nios2Start = Start
Nios2WriteRc = Schreiben Sie Rc
Rv32imClockInput = Takteingang
Rv32imIrqInput = IRQ-Eingang %s
Rv32imResetInput = Reset-Eingang
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Bruchvektor
rv32ExceptionVector = Ausnahmevektor
rv32imIrqWidth = Anzahl der IRQ-Leitungen
rv32ResetVector = Vektor zurücksetzen
rv32StateVisable = Zustand sichtbar:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Erwartete vier Argumente
Nios2DonePinError = Ein nicht definierter oder im Fehlerzustand befindlicher Pin kann nicht fortgesetzt werden.\n Bitte überprüfen Sie den fertigen Pin.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Fehler beim Laden aus dem Speichersystem:
LoadStoreErrorInWriteTransaction = Fehler bei der Ausführung eines Speichers für das Speichersystem:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Erwarteter Sofortwert
AssemblerExpectedNoArguments = Erwartet keine Argumente
AssemblerExpectedOneArgument = Erwartet ein Argument
AssemblerExpectedTwoArguments = Erwartete zwei Argumente
AssemblerExpectedZeroOrOneArgument = Erwartet kein oder ein Argument
AssemblerImmediateOutOfRange = Der Sofortwert liegt außerhalb des Bereichs.
AssemblerUnknownRegister = Unbekanntes Register
Nios2AssemblerExpectedBracketedRegister = Erwartet ein eingeklammertes Register, z.B. (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Erwartet ein sofort indiziertes Register, z.B. 5(r1)
Nios2CannotUseControlRegister = Ein Steuerregister kann in diesem Zusammenhang nicht verwendet werden.
Nios2CannotUseCustomRegister = In diesem Zusammenhang kann kein benutzerdefiniertes Register verwendet werden.
Nios2ExpectedControlRegister = Erwartet ein Steuerregister (z.B. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Erwartete drei Argumente
AssemblerExpextedImmediateOrLabel = Erwarteter Sofortwert oder ein Label
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = Status
RV32imBreakPointReached = Die Ausführung wird aufgrund eines an der aktuellen Anweisung gesetzten Haltepunktes unterbrochen.
RV32imFetchExecutionError = Fehler bei der Ausführung des geholten Befehls
RV32imFetchInvalidInstruction = Ungültige Anweisung geholt
RV32imFetchInvInstrAsm = Ungültige Anweisung!
RV32imFetchTransaction = -> Fetch Transaktionsfehler.
Rv32imProgramCounter = Stück
SocHiddenForFasterSimulation = Versteckte Inhalte für eine schnellere Simulation
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Erwartet ein Register
#
# pio/PioAttributes.java
#
SicPioIrqType = Irq-Typ:
SocPioAnyEdge = Jede Kante
SocPioBidir = Bidirektionale (tristate) Anschlüsse
SocPioCaptureEdge = Aufnahmeart:
SocPioDirection = Richtung:
SocPioFallingEdge = Fallende Kante
SocPioGenIRQ = IRQ aktiviert:
SocPioInout = Sowohl Eingangs- als auch Ausgangsports
SocPioInputCaptureBit = Erfassen Sie Bit-Reinigungen:
SocPioInputOnly = Nur Eingangsports
SocPioInputsSyncCapture = Synchronisierung. Erfassung:
SocPioIrQEdge = Kante
SocPioIrqLevel = Level
SocPioOutputIndividualBits = Ausgangsbit gesetzt/gelöscht:
SocPioOutputOnly = Nur Ausgangsports
SocPioOutputResetValue = Ausgang Rücksetzwert:
SocPioRisingEdge = Steigende Kante
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Es konnte keine Kopf- und/oder C-Datei erstellt werden!
ExportC = C-Vorlagen exportieren
PioMenuBidirFunctionsRemark = /* Mit folgenden Funktionen kann das bidirektionale Register eingestellt oder ausgelesen werden\n * a 1 bedeutet, dass das Respekt-Bit ein Ausgang ist, a 0 bedeutet, dass es ein Eingang ist.\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
PioMenuCaptureAll = Löschen aller Bits im Capture-Register unabhängig vom Wert des Parameters "value".
PioMenuCaptureAny = mindestens eine Änderung von 0 auf 1 oder von 1 auf 0
PioMenuCaptureBit = Löschen der Bits im Capture-Register, die 1 sind, im Parameter "value".
PioMenuCaptureFalling = mindestens eine Änderung von 1 auf 0
PioMenuCaptureRising = mindestens eine Änderung von 0 auf 1
PioMenuEdgeCaptureRemark = /* Mit folgenden Funktionen kann das Kantenerfassungsregister gelöscht oder ausgelesen werden\n * Falls das Kantenregister ausgelesen wird, zeigt eine 1 an einer Position an, dass die\n * Die jeweilige Eingabe hat Hut %s,\n * ansonsten hat sich der jeweilige Eingang nicht geändert.\n *\n * Das Schreiben in dieses Register wird %s.\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
PioMenuInputDataFunctionRemark = /* Mit der folgenden Funktion können die Eingangswerte der PIO wie folgt eingestellt werden\n * vorlesen.\n * Diese Funktion gibt den entsprechenden Wert zurück.\n * Hinweis: Nur die unteren %s-Bits sind gültig.\n */
PioMenuIrqEdge = entsprechendes Bit im Capture-Register
PioMenuIrqLevel = entsprechende Eingabe
PioMenuMaskFunctionsRemark = /* Mit den folgenden Funktionen kann das Interruptmaskenregister eingestellt oder ausgelesen werden.\n * Eine 1 an einer bestimmten Stelle zeigt an, dass ein Interrupt ausgelöst wird.\n * wenn %s gleich 1 ist.\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
PioMenuOutClearRemark = /* Mit der folgenden Funktion erzwingen die Bits, die im Parameter "value" 1 sind, eine Kraftwirkung.\n * die entsprechende Ausgabe auf 0\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
PioMenuOutputDataFunctionRemark = /* Mit der folgenden Funktion können die Ausgangswerte der PIO wie folgt eingestellt werden\n * gesetzt.\n * Diese Funktion übernimmt den neuen Ausgabewert als Parameter "Wert".\n * Hinweis: Nur die unteren %s-Bits des angegebenen Parameters "value" sind gültig.\n */
PioMenuOutSetRemark = /* Mit der folgenden Funktion erzwingen die Bits, die im Parameter "value" 1 sind, eine Kraftwirkung.\n * der entsprechende Ausgang zu 1\n * Hinweis: Es werden nur die unteren %s-Bits verwendet.\n */
SelectDirectoryToStoreC = Verzeichnis zum Speichern der C-Templates festlegen
SuccesCreatingHeaderAndCFile = Die Dateien wurden erfolgreich erstellt:\n%s\nund\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir-Bit %s
SocPioBidirs = Bidirektionale Pins
SocPioComponent = Parallele Ein-/Ausgangserweiterung
SocPioInputPinx = Eingangsbit %s
SocPioInputs = Eingangspins
SocPioIrqOutput = Irq-Ausgang
SocPioOutputPinx = Ausgabebit %s
SocPioOutputs = Ausgangspins
SocPioResetInput = Reset-Eingang
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Risc V IM Simulator
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = Erwartete ein oder zwei Argumente
Rv32imAssemblerExpectedTwoOrThreeArguments = Erwartete zwei oder drei Argumente
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Derzeit sind die Umweltaufrufe und Haltepunkte nicht implementiert.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Erwartet ein eingeklammertes Register, z.B. (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Erwartet ein sofort indiziertes Register, z.B. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Nicht unterstützter ASM-Operationscode
Rv32imMOINotImplmented = Derzeit sind die Anweisungen zur Speicherbestellung nicht implementiert.
#
# Soc.java
#
SocBusComponent = SOC-Bus-Simulator
socLibrary = System On Chip Komponenten
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Unbekannter Opcode
UnknownInstruction = Unbekannter Befehl
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Unter der Annahme der niedrigsten Adresse mit einem Befehl als Einstiegspunkt.\nUm sicherzustellen, dass Ihr CPU an der richtigen Adresse ausgeführt wird.\nBitte fügen Sie ein Label namens'_start' an der Stelle hinzu.\nwo Ihre CPU mit der Ausführung des Programms beginnen soll.
AssemblerCannotUseInsideMacro = Dieses Konstrukt kann nicht innerhalb einer Makrodefinition verwendet werden.
AssemblerEndOfMacroNotFound = Das Ende der Makrodefinition konnte nicht gefunden werden.
AssemblerExpectedMacroName = Erwarteter Name des Makros
AssemblerExpectedMacroNrOfParameters = Erwartete Anzahl der Makroparameter
AssemblerExpectingLabelIdentifier = Erwarten eines Labels
AssemblerMissingLabelBefore = Für diesen Bediener sollte ein Etikett sein.
AssemblerNoExecutableSection = Es wurden keine Anweisungen gefunden, die ausgeführt werden können.
AssemblerReguiresNumberAfterMath = Nach einer mathematischen Operation sollte eine Zahl folgen.
AssemblerUnknowCharacter = Unbekannter Charakter
AssemblerWrongClosingBracket = Diese Verschlusshalterung wird nicht unterstützt.
AssemblerWrongOpeningBracket = Diese Öffnungswinkel wird nicht unterstützt.
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Es konnte keine Adresse für dieses Label ermittelt werden.
AssemblerCouldNotFindValueForDefine = Es konnte keine Definition dieses Parameters gefunden werden.
AssemblerDivZero = Teilen durch Nullpunktfehler
AssemblerExpectedImmediateValueAfterMath = Erwarteter Sofortwert nach einer mathematischen Operation
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Labelnamen müssen eindeutig sein, es wurden mehrere Definitionen dieses Labels gefunden.
AssemblerDuplicatedName = Kann nicht den gleichen Namen für ein .equ und ein Label verwenden.
AssemblerDuplicatedSectionError = Abschnittsnamen müssen eindeutig sein, mehrere Abschnitte mit diesem Namen gefunden werden.
AssemblerExpectedLabel = Erwartet ein Label
AssemblerExpectedLabelAndNumber = Erwartet ein Label, gefolgt von einem sofortigen Wert.
AssemblerExpectedParameter = Erwartete einen Parameter an dieser Stelle
AssemblerExpectingNumber = Erwartete eine Zahl
AssemblerExpectingPositiveNumber = Erwartet eine positive Zahl
AssemblerExpectingSectionName = Erwarten eines Namens für diesen Abschnitt
AssemblerExpectingString = Erwartete Zeichenkette
AssemblerMacroIncorrectNumberOfParameters = Falsche Anzahl der angegebenen Makroparameter
AssemblerOverlappingSections = Dieser Abschnitt überlappt mit einem anderen Abschnitt.
AssemblerUnknownIdentifier = Ich kenne diesen Identifikator nicht.
AssemblerUnknownLabel = Dieses Label wurde nicht definiert, daher kann ich es nicht verwenden.
AssemblerUnsupportedAssemblerInstruction = Dieser Assemblerbefehl ist nicht bekannt.
AssemblerValueOutOfRange = Wert liegt außerhalb des Bereichs
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Makros rufen sich gegenseitig an und verursachen eine Deadlock-Situation.
AssemblerMacroCannotUseRecurency = Macro nennt sich selbst und verursacht eine Deadlock-Situation.
AssemblerMacroParameterNotDefined = Dieser Makroparameter ist nicht definiert, überprüfen Sie die Anzahl der Parameter in Ihrer Makrodefinition.
#
# vga/SocVgaShape.java
#
SocVgaComponent = VGA-Bildschirm
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Pixelpuffer Adresse:
VgaInitialDisplayMode = Anfangsmodus:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Software 1024x768:
VgaSoft160x120 = Software 160x120:
VgaSoft320x240 = Software 320x240:
VgaSoft640x480 = Software 640x480:
VgaSoft800x600 = Software 800x600:
VgaStartAddress = Basisadresse:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* Mit den folgenden Funktionen kann der VGA-Modus manipuliert werden.\n * Das Lesen des VGA-Modus gibt die unterstützten Modi zurück (siehe oben, definiert die möglichen Modi).\n * Das Schreiben eines unterstützten Modus ändert den Anzeigemodus des VGA-Displays.\n */


