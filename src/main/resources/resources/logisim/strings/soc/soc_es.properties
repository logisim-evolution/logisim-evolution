#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Tamaño del rastro:
SocBusTraceVisible = Rastros visibles:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Insertar una transacción de bus
SocBusMemMap = Mostrar mapa de memoria
SocBusTraceWindow = Mostrar el rastreo de transacción(es) de bus
SocInsertTransWindowTitle = Insertar una transacción en el bus:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Ventana de rastreo de bus (haga doble clic en un rastreo para eliminarlo)
#
# data/SocBusInfo.java
#
SocBusNotConnected = No conectado a un bus
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = No hay rastros presentes
SocMemMapWindowTitle = Mapa de memoria para el bus:
SocMemoryMapOk = Cerrar
SocMemoryMapTitle = Mapa de memoria (el rojo indica regiones de memoria superpuestas):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Iniciador:
SocBusStateNoDataMax10chars = ningún dato
SocBusStateSlave = Respondedor:
SocBusStateTraceIndex = Número de operación:
SocTransactionByteAccesNoSupport = Slave no soporta accesos byte.
SocTransactionByteAccesNoSupportShort = Sin acceso a bytes
SocTransactionHalfWordAccesNoSupport = Slave no soporta accesos de media palabra.
SocTransactionHalfWordAccesNoSupportShort = Sin acceso a HW
SocTransactionMisalignedAddress = El esclavo detectó una dirección desalineada.
SocTransactionMisalignedAddressShort = Misal. Addr.
SocTransactionMultipleSlaveAnswers = Varios esclavos respondieron a una transacción. Compruebe el mapa de memoria de sus esclavos.
SocTransactionMultipleSlaveAnswersShort = Múltiples esclavos
SocTransactionNoBusConnected = El componente maestro no está conectado a ningún bus SoC. Conecte el máster a un componente de bus.
SocTransactionNoBusConnectedShort = No hay autobús
SocTransactionNoneAtomicRW = Se solicita una acción de lectura/escritura no atómica. Esto no está permitido.
SocTransactionNoneAtomicRWShort = Ninguno atómico RW
SocTransactionNoRespons = Ningún componente esclavo respondió a la petición. Compruebe la dirección de memoria de la solicitud y el mapa de memoria de su sistema.
SocTransactionNoResponsShort = No hay respuesta
SocTransactionNoSlavesAttached = El bus que está conectado al maestro no tiene esclavos conectados. Por favor, conecte algunos esclavos al autobús.
SocTransactionNoSlavesAttachedShort = No hay esclavos
SocTransactionReadOnlyAccessError = Slave soporta sólo accesos de lectura en esta dirección
SocTransactionReadOnlyAccessErrorShort = Sólo lectura
SocTransactionRegisterDoesNotExist = Slave no soporta ningún acceso en esta dirección
SocTransactionRegisterDoesNotExistShort = Sin acceso
SocTransactionSuccessfull = No se ha producido ningún error, la operación es correcta.
SocTransactionSuccessfullShort = Éxito
SocTransactionUnknownError = Bizarre, este mensaje de error nunca debería ocurrir y representa un error en logisim.
SocTransactionUnknownErrorShort = ¡BUG!
SocTransactionWordAccesNoSupport = El esclavo no soporta accesos de palabra.
SocTransactionWordAccesNoSupportShort = No hay acceso de palabras
SocTransactionWriteOnlyAccessError = Slave no soporta una acción de lectura en esta dirección.
SocTransactionWriteOnlyAccessErrorShort = Escribir sólo
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Vacío (sin esclavos)
SocMemMapEndAddress = Dirección de destino:
SocMemMapSlaveName = Nombre del componente:
SocMemMapStartAddress = Dirección de inicio:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Por favor, seleccione el autobús al que desea conectarse
SocBusSelectAttr = Autobús conectado
SocBusSelectAttrClick = Haga clic para seleccionar
SocManagerNoBusses = No hay autobuses disponibles, por favor añada un SoC-bus a su esquema.
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Ha cargado con éxito el archivo ELF en la memoria.\nEl punto de entrada del ejecutable se ha establecido en el procesador.\n\nImportante:\n   Como el archivo ELF no tiene información sobre los vectores de excepción\n   tienes que controlarlos tú mismo!
SocUpMenuAsmWindow = Ensamblador abierto
SocUpMenuCpuAsmWindowTitle = ensamblador para cpu:
SocUpMenuCpuProgramWindowTitle = desensamblador para cpu:
SocUpMenuCpuStateWindowTitle = estado del procesador para cpu:
SocUpMenuErrorReadingElfTitle = Error en la lectura del archivo ELF
SocUpMenuReadElf = Leer el archivo ELF
SocUpMenuSelectElfFile = Seleccione el archivo ELF para importar
SocUpMenuShowProgram = Mostrar programa cargado
SocUpMenuShowState = Mostrar el estado de la CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Detenido
SocUpSimHaltBreak = Punto de ruptura
SocUpSimHaltError = Error
SocUpSimRunning = Correr
SocUpSimStateLabel = Estado de simulación:
SocUpSimstateStart = Inicio
SocUpSimstateStop = Pausa
SocUpUnknown = Desconocido
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = No es un archivo ELF de 32 o 64 bits
ElfHeaderEIDataError = No es un pequeño o gran archivo codificado endian
ElfHeaderIncorrectEISize = El tamaño de la sección EI es incorrecto
ElfHeaderIncorrectESize = El tamaño de la sección E es incorrecto
ElfHeaderIncorrectMagic = El archivo no contiene la magia ELF correcta; probablemente no es un archivo ELF
ElfHeaderNoErrors = La cabecera es correcta
ElfHeaderReadingFileError = Error al leer el archivo
ElfHeaderUnknownArchitecture = Arquitectura desconocida
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = No se ha encontrado la cabecera del programa.
ProgHeaderReadError = Error en la lectura de la cabecera del programa.
ProgHeaderSizeError = Desajuste de tamaño en la cabecera del programa.
ProgHeaderSuccess = Éxito
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Encontré múltiples tablas de cadenas, no soportadas por el momento.
ElfSectHeadMultiSymtabError = Encontré múltiples tablas de símbolos, no soportadas por el momento;
ElfSectHeadNotFound = Cabecera de sección no encontrada.
ElfSectHeadReadError = Cabecera de la sección de lectura de errores.
ElfSectHeadSizeError = Desajuste de tamaño en el encabezado de la sección.
ElfSectHeadStingIdxError = Índice de cadenas de error.
ElfSectHeadStingNotFound = Nombre de la sección no encontrado.
ElfSectHeadStingReadError = Error al leer la tabla de cadenas.
ElfSectHeadStingTypeError = Error de tipo de cadena.
ElfSectHeadSuccess = Éxito
ElfSymTableNotFound = No he podido encontrar la tabla de símbolos.
ElfSymTableReadError = No se pudo leer la tabla de símbolos.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim aún no es compatible con los archivos ELF de 64 bits.
ProcReadElfArchError = El archivo ELF es para un procesador«%s» mientras que debería ser para un procesador«%s».
ProcReadElfEndianMismatch = Desajuste endiano, el archivo ELF es«%s» mientras que el procesador pidió«%s».
ProcReadElfErrorOpeningFile = Imposible abrir el archivo ELF
ProcReadElfLoadableSectionNotFound = La sección de carga no se encuentra en el archivo ELF.
ProcReadElfLoadableSectionReadError = Error en la lectura de la sección cargable.
ProcReadElfLoadableSectionSizeError = Desajuste de tamaño en la sección de carga.
ProcReadElfLoadableSectionTooBig = El tamaño de la sección cargable es mayor que el tamaño soportado por logisim.
ProcReadElfMemoryError = Se ha producido un error al escribir una sección cargable en la memoria.\nAsegúrese de tener un componente de memoria SoC disponible para la zona de memoria:\n%s…%s
ProcReadElfNotExecutable = El archivo ELF no es un ejecutable
ProcReadElfSuccess = Éxito
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Archivos de ensamblaje (.asm,.S)
AsmPanAssemble = Ensamblar el código (ALT-A)
AsmPanDocumentChangedSave = Hay cambios en su documento, ¿guardarlos?
AsmPanErrorCreateFile = No se puede crear el archivo de ensamblaje.
AsmPanErrorReadingFile = No se puede leer el archivo
AsmPanNextError = Saltar al siguiente error (CTRL-N)
AsmPanOpenFile = Leer un fichero (CTRL-L)
AsmPanPreviousError = Saltar al error anterior (CTRL-P)
AsmPanReadAsmFile = Seleccione un archivo para leer
AsmPanRun = Ejecutar el código (ALT-R)
AsmPanSaveAsmFile = Seleccione un archivo para guardar
AsmPanSaveFile = Guardar archivo (CTRL-S)
AsmPanSaveFileAs = Guardar archivo como
AsmPanSaveFirstBeforeOpen = Hay cambios en su documento\n¿Desea guardarlas antes de abrir un nuevo archivo?
AssemblerAssembleSuccess = Éxito!\nNo se han encontrado errores en su código.
AssemblerRunSuccess = Ha cargado con éxito el programa en la memoria.\nPara ejecutar el programa, por favor, asegúrese de ello:\na) usted habilita las garrapatas\nb) usted establece el cpu en modo de ejecución
AssemblerUnableToDownload = No se puede almacenar el programa en la memoria,\npor favor, asegúrese de tener suficiente memoria disponible\nen las posiciones de memoria correctas.
RV32imAsmLineIndicator = Línea %d de %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Eliminar el punto de ruptura
RV32imSetBreakpoint = Añadir punto de ruptura
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Dirección del autobús: 0x
SocTransInsAtomicRequest = Transacción atómica
SocTransInsByteAccess = Transacción de bytes
SocTransInsHalfWordAccess = Transacción de media palabra (2 bytes)
SocTransInsInputData = Datos para escribir: 0x
SocTransInsInsertTransaction = Insertar la transacción en el autobús
SocTransInsManual = Manual insertado
SocTransInsReadData = Datos devueltos:
SocTransInsReadRequest = Solicitud de lectura de bus
SocTransInsTransResultTitle = Resultado de la transacción insertada:
SocTransInsWordAccess = Transacción Word (4 bytes)
SocTransInsWriteRequest = Solicitud de escritura de bus
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Montaje:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = No hay trazas de ejecución disponibles
Rv32imExecutionTrace = Traza de ejecución (última ejecución en la parte superior):
Rv32imRegisterFile = Archivo de registro:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Control de simulación
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Teclado claro
JtagUartKeybAvailable = Datos del teclado disponibles
JtagUartKeybData = Datos del teclado
JtagUartKeybReadEnable = Habilitar lectura de teclado
JtagUartTtyClear = Despejar TTY
JtagUartTtyData = Datos TTY
JtagUartTtyWrite = Datos de escritura TTY
# ==> SocJtagUartComponent =
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = Leer umbral de IRQ
JtagUartWriteIrqThreshold = Escribir umbral IRQ
UartJtagREADFifoSize = Leer el tamaño FIFO:
UartJtagWriteFifoSize = Escribe el tamaño FIFO:
#
# memory/SocMemory.java
#
SocMemBase = Base:
SocMemoryComponent = Simulador de memoria
SocMemSizeStr = Tamaño:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Ancho de dirección de byte:
SocMemStartAddress = Dirección de inicio:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Simulador de Nios2s
Nios2Dataa = Datos A
Nios2Datab = Datos B
Nios2Done = Hecho
Nios2N = N
Nios2ReadRa = Leer Ra
Nios2ReadRb = Leer Rb
Nios2Result = Resultado
Nios2Start = Inicio
Nios2WriteRc = Escribir Rc
Rv32imClockInput = Entrada de reloj
Rv32imIrqInput = Entrada IRQ %s
Rv32imResetInput = Entrada de reset
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Vector de ruptura
rv32ExceptionVector = Vector de excepción
rv32imIrqWidth = Número de líneas IRQ
rv32ResetVector = Restablecer vector
rv32StateVisible = Estado visible:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Se esperan cuatro argumentos
Nios2DonePinError = El pin hecho no definido o en estado de error no puede continuar.\n Por favor, compruebe el pin hecho.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Error al realizar una carga desde el sistema de memoria:
LoadStoreErrorInWriteTransaction = Error al realizar un almacenamiento en el sistema de memoria:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Se espera un valor inmediato
AssemblerExpectedNoArguments = No se esperan argumentos
AssemblerExpectedOneArgument = Esperaba un argumento
AssemblerExpectedTwoArguments = Se esperan dos argumentos
AssemblerExpectedZeroOrOneArgument = No se espera ningún o ningún argumento
AssemblerImmediateOutOfRange = El valor inmediato está fuera de rango
AssemblerUnknownRegister = Registro desconocido
Nios2AssemblerExpectedBracketedRegister = Se espera un registro entre corchetes, por ejemplo (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Se espera un registro indexado inmediato, por ejemplo, 5(r1)
Nios2CannotUseControlRegister = No se puede utilizar un registro de control en este contexto.
Nios2CannotUseCustomRegister = No se puede utilizar un registro personalizado en este contexto
Nios2ExpectedControlRegister = Se espera un registro de control (p. ej. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Se esperan tres argumentos
AssemblerExpextedImmediateOrLabel = Se espera un valor inmediato o una etiqueta
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = estado
RV32imBreakPointReached = La ejecución se detiene debido a un punto de interrupción establecido en la instrucción actual.
RV32imFetchExecutionError = Error en la ejecución de una instrucción recuperada
RV32imFetchInvalidInstruction = Instrucción inválida recuperada
RV32imFetchInvInstrAsm = Instrucción no válida!
RV32imFetchTransaction = -> Recuperar error de transacción.
Rv32imProgramCounter = pc:
SocHiddenForFasterSimulation = Contenidos ocultos para una simulación más rápida
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Se espera un registro
#
# pio/PioAttributes.java
#
SicPioIrqType = Tipo de Irq:
SocPioAnyEdge = Cualquier borde
SocPioBidir = Puertos bidireccionales (triestáticos)
SocPioCaptureEdge = Tipo de captura:
SocPioDirection = Dirección:
SocPioFallingEdge = Borde descendente
SocPioGenIRQ = IRQ habilitado:
SocPioInout = Puertos de entrada y salida
SocPioInputCaptureBit = Captura de borrado de bits:
SocPioInputOnly = Sólo puertos de entrada
SocPioInputsSyncCapture = Captura sincronizada:
SocPioIrQEdge = Borde
SocPioIrqLevel = Nivel
SocPioOutputIndividualBits = Bit de salida configurado/limpio:
SocPioOutputOnly = Sólo puertos de salida
SocPioOutputResetValue = Valor de reset de salida:
SocPioRisingEdge = Borde ascendente
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = No se pudo crear el encabezado y/o el archivo c!
ExportC = Exportación de plantillas en C
PioMenuBidirFunctionsRemark = /* Con las siguientes funciones se puede ajustar o leer el registro bidireccional\n * a 1 indica que el bit respect es una salida, a 0 indica que es una entrada\n * Nota: sólo se utilizan los porcentajes más bajos de bits.\n */
PioMenuCaptureAll = borrar todos los bits del registro de captura independientemente del valor del parámetro «value».
PioMenuCaptureAny = al menos un cambio de 0 a 1 o de 1 a 0
PioMenuCaptureBit = borrar los bits del registro de captura que son 1 en el parámetro "valor
PioMenuCaptureFalling = al menos un cambio de 1 a 0
PioMenuCaptureRising = al menos un cambio de 0 a 1
PioMenuEdgeCaptureRemark = /* Con las siguientes funciones se puede borrar o leer el registro de captura de bordes\n * en caso de que el registro de borde se lea en voz alta, un 1 en una posición indica que el\n * la entrada respectiva tiene un %s de sombrero,\n * de lo contrario, la entrada respectiva no ha cambiado.\n *\n * Escribir a este registro será %s.\n * Nota: sólo se utilizan los porcentajes más bajos de bits.\n */
PioMenuInputDataFunctionRemark = /* Con la siguiente función los valores de entrada del PIO pueden ser\n * Leer en voz alta.\n * Esta función devuelve el valor respectivo\n * Nota: sólo los %s de bits inferiores son válidos.\n */
PioMenuIrqEdge = bit correspondiente en el registro de captura
PioMenuIrqLevel = entrada correspondiente
PioMenuMaskFunctionsRemark = /* Con las siguientes funciones se puede ajustar o leer el registro de la máscara de interrupción.\n * Un 1 en una ubicación específica indica que se generará una interrupción.\n * si el %s es igual a 1.\n * Nota: sólo se utilizan los porcentajes más bajos de bits.\n */
PioMenuOutClearRemark = /* Con la siguiente función los bits que son 1 en el parámetro «value» forzarán a\n * la salida correspondiente a 0\n * Nota: sólo se utilizan los porcentajes más bajos de bits.\n */
PioMenuOutputDataFunctionRemark = /* Con la siguiente función los valores de salida del PIO pueden ser\n *Set*\n * Esta función toma el nuevo valor de salida como parámetro «valor».\n * Nota: sólo son válidos los bits %s inferiores del parámetro «value» proporcionado.\n */
PioMenuOutSetRemark = /* Con la siguiente función los bits que son 1 en el parámetro «value» forzarán a\n * la salida correspondiente a 1\n * Nota: sólo se utilizan los porcentajes más bajos de bits.\n */
SelectDirectoryToStoreC = Directorio de sets para almacenar las plantillas C
SuccesCreatingHeaderAndCFile = Ha creado con éxito los archivos:\n%s\ny\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Pines bidireccionales
SocPioComponent = Expansor de entradas/salidas en paralelo
SocPioInputPinx = Bit de entrada %s
SocPioInputs = Pines de entrada
SocPioIrqOutput = Salida de Irq
SocPioOutputPinx = Bit de salida %s
SocPioOutputs = Pines de salida
SocPioResetInput = Entrada de reset
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Simulador de mensajería instantánea Risc V
# ==> Rv32PlicBaseAddress =
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = Se esperan uno o dos argumentos
Rv32imAssemblerExpectedTwoOrThreeArguments = Se esperan dos o tres argumentos
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Actualmente no se han implementado los llamados y puntos de ruptura ambientales.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = ¡BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Se espera un registro entre corchetes, por ejemplo (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Se espera un registro indexado inmediato, por ejemplo, 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Opcode asm no soportado
Rv32imMOINotImplmented = Actualmente las instrucciones para ordenar la memoria no están implementadas.
#
# Soc.java
#
SocBusComponent = Simulador de bus SoC
socLibrary = System On a Chip
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Opcode desconocido
UnknownInstruction = Instrucción desconocida
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Asumiendo la dirección más baja con una instrucción como punto de entrada.\nPara asegurarse de que su cpu comienza a ejecutarse en la dirección correcta\npor favor, añada una etiqueta llamada “_start” en la ubicación\ndonde su cpu debería empezar a ejecutar el programa.
AssemblerCannotUseInsideMacro = Esta construcción no se puede utilizar dentro de una definición de macro
AssemblerEndOfMacroNotFound = No se pudo encontrar el final de la definición de macro
AssemblerExpectedMacroName = Se espera un nombre de la macroinstrucción
AssemblerExpectedMacroNrOfParameters = Número esperado de parámetros de macro
AssemblerExpectingLabelIdentifier = Esperando una etiqueta
AssemblerMissingLabelBefore = Para este operador debe ser una etiqueta
AssemblerNoExecutableSection = No se han encontrado instrucciones que puedan ejecutarse.
AssemblerReguiresNumberAfterMath = Después de una operación matemática debe seguir un número
AssemblerUnknowCharacter = Carácter desconocido
AssemblerWrongClosingBracket = Este soporte de cierre no está soportado
AssemblerWrongOpeningBracket = Este soporte de apertura no está soportado
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = No se pudo determinar una dirección para esta etiqueta
AssemblerCouldNotFindValueForDefine = No se pudo encontrar una definición de este parámetro
AssemblerDivZero = Dividir por cero error
AssemblerExpectedImmediateValueAfterMath = Se espera un valor inmediato después de una operación matemática
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Los nombres de las etiquetas deben ser únicos, se encuentran múltiples definiciones de esta etiqueta
AssemblerDuplicatedName = No se puede usar el mismo nombre para un.equ y una etiqueta
AssemblerDuplicatedSectionError = Los nombres de las secciones deben ser únicos, encontrándose varias secciones con este nombre
AssemblerExpectedLabel = Se espera una etiqueta
AssemblerExpectedLabelAndNumber = Se espera una etiqueta seguida de un valor inmediato
AssemblerExpectedParameter = Se espera un parámetro en esta posición
AssemblerExpectingNumber = Se espera un número
AssemblerExpectingPositiveNumber = Se espera un número positivo
AssemblerExpectingSectionName = Esperando un nombre para esta sección
AssemblerExpectingString = Se espera una cadena
AssemblerMacroIncorrectNumberOfParameters = Número incorrecto de parámetros de macro especificados
AssemblerOverlappingSections = Esta sección se solapa con otra sección
AssemblerUnknownIdentifier = No conozco este identificador
AssemblerUnknownLabel = Esta etiqueta no ha sido definida, por lo tanto no puedo usarla.
AssemblerUnsupportedAssemblerInstruction = Esta instrucción de ensamblador no se conoce
AssemblerValueOutOfRange = El valor está fuera de rango
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Las macros se llaman entre sí causando una situación de bloqueo
AssemblerMacroCannotUseRecurency = Macro se está llamando a sí misma causando una situación de bloqueo
AssemblerMacroParameterNotDefined = Este parámetro de macro no está definido, verifique el número de parámetros en su definición de macro.
#
# vga/SocVgaShape.java
#
SocVgaComponent = Pantalla VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Dirección del búfer de píxeles:
VgaInitialDisplayMode = Modo inicial:
VgaSoftMode = Software %s:
VgaStartAddress = Dirección de la base:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* Con las siguientes funciones se puede manipular el modo vga.\n * La lectura del modo vga devuelve los modos soportados (ver arriba define los posibles modos)\n * Escribir un modo compatible cambiará el modo de visualización de la pantalla VGA.\n */
#
# dma/SocDma.java, dma/DmaAttributes.java
#
# ==> SocDmaComponent =
# ==> SocDmaStartAddress =
# ==> SocDmaBurstSize =
# ==> SocDmaSrcBus =
# ==> SocDmaDstBus =
# ==> SocDmaResetInput =
# ==> SocDmaClockInput =
# ==> SocDmaIrqOutput =
# ==> SocDmaBaseLabel =
# ==> SocDmaBurstLabel =
# ==> SocDmaStatusIdle =
# ==> SocDmaStatusBusy =
# ==> SocDmaStatusDone =
