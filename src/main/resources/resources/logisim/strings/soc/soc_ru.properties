#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Размер следа:
SocBusTraceVisible = Следы видны:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Вставить транзакцию по шине
SocBusMemMap = Показать карту памяти
SocBusTraceWindow = Показать трассировку автобусных транзакций
SocInsertTransWindowTitle = Вставьте транзакцию в автобус:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Окно трассировки шины (дважды щелкните по трассировке, чтобы удалить ее)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Не подключен к шине
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Нет следов
SocMemMapWindowTitle = Карта памяти для автобуса:
SocMemoryMapOk = Близко
SocMemoryMapTitle = Карта памяти (красный цвет указывает на перекрывающиеся области памяти):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Инициатор
SocBusStateNoDataMax10chars = отсутствие данных
SocBusStateSlave = Отвечай:
SocBusStateTraceIndex = Транзакция №:
SocTransactionByteAccesNoSupport = Slave не поддерживает доступ к байтам.
SocTransactionByteAccesNoSupportShort = Нет доступа к байтам
SocTransactionHalfWordAccesNoSupport = Slave не поддерживает доступ к файлам длиной в полслова.
SocTransactionHalfWordAccesNoSupportShort = Нет доступа к ГВС
SocTransactionMisalignedAddress = Ведомый обнаружил неправильно выровненный адрес.
SocTransactionMisalignedAddressShort = Мисал. Аддр
SocTransactionMultipleSlaveAnswers = Несколько рабов ответили на операцию. Пожалуйста, проверьте карту памяти ваших ведомых устройств.
SocTransactionMultipleSlaveAnswersShort = Несколько рабов
SocTransactionNoBusConnected = Ведущий компонент не подключен к шине Soc Bus. Пожалуйста, подключите ведущее устройство к компоненту шины.
SocTransactionNoBusConnectedShort = Нет автобуса
SocTransactionNoneAtomicRW = Не требуется никаких действий по атомному чтению/записи. Это не разрешено.
SocTransactionNoneAtomicRWShort = Нет атомных РАО
SocTransactionNoRespons = Ни один из подчиненных компонентов не ответил на запрос. Пожалуйста, проверьте адрес памяти запроса и карту памяти вашей системы.
SocTransactionNoResponsShort = Нет ответа
SocTransactionNoSlavesAttached = Шина, подключенная к ведущему устройству, не имеет ведомых устройств. Пожалуйста, прикрепите несколько рабов к автобусу.
SocTransactionNoSlavesAttachedShort = Нет рабов
SocTransactionReadOnlyAccessError = Ведомый поддерживает только чтение по этому адресу.
SocTransactionReadOnlyAccessErrorShort = Только для чтения
SocTransactionRegisterDoesNotExist = Slave не поддерживает доступ по этому адресу.
SocTransactionRegisterDoesNotExistShort = Нет доступа
SocTransactionSuccessfull = Ошибки не произошло, транзакция прошла успешно.
SocTransactionSuccessfullShort = Успех
SocTransactionUnknownError = Странно, но это сообщение об ошибке никогда не должно произойти и представляет собой ошибку в логистике.
SocTransactionUnknownErrorShort = БУГ!
SocTransactionWordAccesNoSupport = Slave не поддерживает доступ к словам.
SocTransactionWordAccesNoSupportShort = Нет доступа к словам
SocTransactionWriteOnlyAccessError = Slave не поддерживает чтение по этому адресу.
SocTransactionWriteOnlyAccessErrorShort = Пишите только
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Пусто (нет рабов)
SocMemMapEndAddress = Конечный адрес:
SocMemMapSlaveName = Название компонента:
SocMemMapStartAddress = Стартовый адрес:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Пожалуйста, выберите шину для подключения к следующему устройству
SocBusSelectAttr = Подключенная шина
SocBusSelectAttrClick = Нажмите, чтобы выбрать
SocManagerNoBusses = Автобусов нет, пожалуйста, добавьте SoC-автобус к схеме соединений.
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Успешно загрузил эльфийский файл в память.\nТочка входа исполняемого файла настроена на процессор.\n\nВажно:\n   Так как в деле Эльфа нет информации о векторах исключений.\n   ты должен контролировать их сам!
SocUpMenuAsmWindow = Открытый ассемблер
SocUpMenuCpuAsmWindowTitle = ассемблер для КПО:
SocUpMenuCpuProgramWindowTitle = Разборщик для КПО:
SocUpMenuCpuStateWindowTitle = состояние процессора процессора для процессора:
SocUpMenuErrorReadingElfTitle = Ошибка при чтении эльфийского файла
SocUpMenuReadElf = Читать файл эльфа
SocUpMenuSelectElfFile = Выберите файл эльфа для импорта
SocUpMenuShowProgram = Показать загруженную программу
SocUpMenuShowState = Показать состояние процессора
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Массивный
SocUpSimHaltBreak = Точка останова
SocUpSimHaltError = Ошибка
SocUpSimRunning = Бегущий
SocUpSimStateLabel = Простой штат:
SocUpSimstateStart = Начать
SocUpSimstateStop = Пауза
SocUpUnknown = Неизвестный
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Не 32 или 64-битный эльфийский файл.
ElfHeaderEIDataError = Не маленький или большой файл в кодировке Эндиана.
ElfHeaderIncorrectEISize = Размер EI-секции неправильный.
ElfHeaderIncorrectESize = Размер E-секции неправильный.
ElfHeaderIncorrectMagic = Файл не содержит правильной эльфийской магии; возможно, это не эльфийский файл.
ElfHeaderNoErrors = Заголовок правильный
ElfHeaderReadingFileError = Ошибка чтения файла
ElfHeaderUnknownArchitecture = Неизвестная архитектура
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Заголовок программы не найден.
ProgHeaderReadError = Ошибка чтения заголовка программы.
ProgHeaderSizeError = Несоответствие размеров заголовка программы.
ProgHeaderSuccess = Успех
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Найдено несколько строковых таблиц, пока не поддерживаемых.
ElfSectHeadMultiSymtabError = Найдено несколько таблиц символов, на данный момент не поддерживаемых;
ElfSectHeadNotFound = Заголовок секции не найден.
ElfSectHeadReadError = Ошибка чтения заголовка раздела.
ElfSectHeadSizeError = Несоответствие размеров в заголовке секции.
ElfSectHeadStingIdxError = Индекс строки ошибки.
ElfSectHeadStingNotFound = Название секции не найдено.
ElfSectHeadStingReadError = Ошибка чтения строки таблицы.
ElfSectHeadStingTypeError = Ошибка типа строки.
ElfSectHeadSuccess = Успех
ElfSymTableNotFound = Не смог найти таблицу символов.
ElfSymTableReadError = Не смог прочитать таблицу символов.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim пока не поддерживает 64-битные файлы эльфов.
ProcReadElfArchError = Файл ELF предназначен для процессора «%s», а для процессора «%s».
ProcReadElfEndianMismatch = Эндиана несоответствия, файл ELF «%s», в то время как процессор запросил «%s».
ProcReadElfErrorOpeningFile = Невозможно открыть эльф-файл
ProcReadElfLoadableSectionNotFound = Загружаемый раздел не найден в файле ELF.
ProcReadElfLoadableSectionReadError = Ошибка чтения загружаемой секции.
ProcReadElfLoadableSectionSizeError = Несоответствие размеров загружаемого участка.
ProcReadElfLoadableSectionTooBig = Размер загружаемого участка больше, так как он поддерживается логистикой.
ProcReadElfMemoryError = Произошла ошибка при записи в память загружаемого раздела.\nУбедитесь в наличии компонента памяти SoC, доступного для данной области памяти:\n%s…%s…%s
ProcReadElfNotExecutable = ELF-файл не является исполняемым файлом.
ProcReadElfSuccess = Успех
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Монтажные файлы (.asm,.S.)
AsmPanAssemble = Сборка кода (ALT-A)
AsmPanDocumentChangedSave = В вашем документе есть изменения, сохраните их?
AsmPanErrorCreateFile = Невозможно создать сборочный файл.
AsmPanErrorReadingFile = Невозможно прочитать файл
AsmPanNextError = Переход к следующей ошибке (CTRL-N)
AsmPanOpenFile = Чтение файла (CTRL-L)
AsmPanPreviousError = Переход к предыдущей ошибке (CTRL-P)
AsmPanReadAsmFile = Выберите файл для чтения
AsmPanRun = Запустите код (ALT-R)
AsmPanSaveAsmFile = Выберите файл для сохранения
AsmPanSaveFile = Сохранить файл (CTRL-S)
AsmPanSaveFileAs = Сохранить файл как
AsmPanSaveFirstBeforeOpen = В вашем документе есть изменения.\nВы хотите сохранить их перед открытием нового файла?
AssemblerAssembleSuccess = Успех!\nОшибок в коде не обнаружено.
AssemblerRunSuccess = Успешно загрузил программу в память.\nЧтобы запустить программу, пожалуйста, убедитесь в этом:\na) Вы включаете галочки\nb) перевести процессор в режим работы
AssemblerUnableToDownload = Невозможно сохранить программу в памяти,\nпожалуйста, убедитесь, что у вас достаточно памяти.\nв нужных местах памяти.
RV32imAsmLineIndicator = Линия %d от %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Удалить точку разрыва
RV32imSetBreakpoint = Добавить точку останова
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Адрес автобуса: 0x
SocTransInsAtomicRequest = Атомная сделка
SocTransInsByteAccess = транзакция байта
SocTransInsHalfWordAccess = Транзакция с половиной слова (2 байта)
SocTransInsInputData = Данные для записи: 0x
SocTransInsInsertTransaction = Вставьте транзакцию в шину.
SocTransInsManual = Руководство вставлено
SocTransInsReadData = Данные возвращены:
SocTransInsReadRequest = Запрос на считывание данных с шины
SocTransInsTransResultTitle = Результат вставленной транзакции:
SocTransInsWordAccess = Транзакция слова (4 байта)
SocTransInsWriteRequest = Запрос на запись шины
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Сборка:
Rv32imBinInstruction = Опкод:
Rv32imEmptyTrace = Нет доступных следов исполнения
Rv32imExecutionTrace = Трасса исполнения (последняя выполняется сверху):
Rv32imRegisterFile = Зарегистрируйте файл:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Моделирование управления
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Четкая клавиатура
JtagUartKeybAvailable = Доступные данные клавиатуры
JtagUartKeybData = Данные клавиатуры
JtagUartKeybReadEnable = Разрешение чтения с клавиатуры
JtagUartTtyClear = TTY ясно
JtagUartTtyData = данные TTY
JtagUartTtyWrite = Запись данных TTY
SocJtagUartComponent = JTAG UART
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = Считывание порога IRQ
JtagUartWriteIrqThreshold = Запись порогового значения IRQ
UartJtagREADFifoSize = Читайте размер FIFO:
UartJtagWriteFifoSize = Напишите размер FIFO:
#
# memory/SocMemory.java
#
SocMemBase = База
SocMemoryComponent = Симулятор памяти
SocMemSizeStr = Размер
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Ширина адреса в байтах:
SocMemStartAddress = Стартовый адрес:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Симулятор Nios2s
Nios2Dataa = Данные A
Nios2Datab = Данные B
Nios2Done = Готово
Nios2N = N
Nios2ReadRa = Прочитать Ра
Nios2ReadRb = Читайте Rb
Nios2Result = Результат
Nios2Start = Начать
Nios2WriteRc = Напишите Rc
Rv32imClockInput = Вход часов
Rv32imIrqInput = Вход IRQ %s
Rv32imResetInput = Вход сброса
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Break Vector
rv32ExceptionVector = Вектор исключения
rv32imIrqWidth = Количество линий IRQ
rv32ResetVector = Вектор сброса
rv32StateVisible = Состояние видно:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Ожидаемые четыре аргумента
Nios2DonePinError = Готовый вывод не определен или находится в состоянии ошибки и не может быть продолжен.\n Пожалуйста, проверьте готовую булавку.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Ошибка при загрузке из системы памяти:
LoadStoreErrorInWriteTransaction = Ошибка при сохранении данных в системе памяти:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Ожидаемое немедленное значение
AssemblerExpectedNoArguments = Не ожидал никаких аргументов
AssemblerExpectedOneArgument = Ожидаемый один аргумент
AssemblerExpectedTwoArguments = Два ожидаемых аргумента
AssemblerExpectedZeroOrOneArgument = Ожидаемое отсутствие или один аргумент
AssemblerImmediateOutOfRange = Непосредственное значение выходит за пределы диапазона
AssemblerUnknownRegister = Неизвестный реестр
Nios2AssemblerExpectedBracketedRegister = Ожидаемый регистр в квадратных скобках, например (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Ожидаемый немедленный индексированный регистр, например, 5(r1)
Nios2CannotUseControlRegister = Невозможно использовать регистр управления в этом контексте
Nios2CannotUseCustomRegister = Невозможно использовать пользовательский регистр в этом контексте
Nios2ExpectedControlRegister = Ожидаемый контрольный регистр (например, ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Ожидаемые три аргумента
AssemblerExpextedImmediateOrLabel = Ожидаемое немедленное значение или ярлык
#
# nios2/Nios2State.java
#
Nios2Bstatus = статус
Nios2Estatus = статус
Nios2Status = положение
RV32imBreakPointReached = Исполнение приостанавливается из-за точки останова, установленной на текущей команде.
RV32imFetchExecutionError = Ошибка при выполнении извлеченной команды
RV32imFetchInvalidInstruction = Недействительная инструкция получена.
RV32imFetchInvInstrAsm = Недействительная инструкция!
RV32imFetchTransaction = -> Получить ошибку транзакции.
Rv32imProgramCounter = ПК:
SocHiddenForFasterSimulation = Скрытое содержимое для более быстрого моделирования
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Ожидаемый регистр
#
# pio/PioAttributes.java
#
SicPioIrqType = Ирк-тип:
SocPioAnyEdge = Любой край
SocPioBidir = Двунаправленные (трехсторонние) порты
SocPioCaptureEdge = Тип захвата:
SocPioDirection = Направление
SocPioFallingEdge = Падающая кромка
SocPioGenIRQ = IRQ включен:
SocPioInout = Как входной, так и выходной порты
SocPioInputCaptureBit = Захват битов очистки:
SocPioInputOnly = Только входные порты
SocPioInputsSyncCapture = Синхронизация. захват:
SocPioIrQEdge = Граница
SocPioIrqLevel = Уровень
SocPioOutputIndividualBits = Установка/очистка выходного бита:
SocPioOutputOnly = Только выходные порты
SocPioOutputResetValue = Значение сброса на выходе:
SocPioRisingEdge = Поднимающаяся кромка
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Не удалось создать заголовок и/или c-файл!
ExportC = Экспорт С-шаблонов
PioMenuBidirFunctionsRemark = /* С помощью следующих функций двунаправленный регистр может быть установлен или прочитан\n * a 1 означает, что бит уважения. бит - это выход, а 0 означает, что это вход\n * Примечание: используются только биты нижнего %s.\n */
PioMenuCaptureAll = очищает все биты регистра захвата независимо от значения параметра «value».
PioMenuCaptureAny = по крайней мере одно изменение от 0 до 1 или от 1 до 0.
PioMenuCaptureBit = очистить биты регистра захвата, которые в параметре «value» равны 1
PioMenuCaptureFalling = по крайней мере одно изменение от 1 до 0.
PioMenuCaptureRising = по крайней мере одно изменение от 0 до 1
PioMenuEdgeCaptureRemark = /* С помощью следующих функций регистр захвата краёв может быть очищен или считан\n * в случае, если регистр края считывается как единица на позиции указывает на то.\n * соответствующий вход имеет шляпу %s,\n * в противном случае соответствующий вход не изменился.\n *\n * Запись в этот регистр будет %s.\n * Примечание: используются только биты нижнего %s.\n */
PioMenuInputDataFunctionRemark = /* С помощью следующей функции входные значения PIO могут быть следующими\n * зачитай.\n * Эта функция возвращает соответствующее значение\n * Примечание: действительны только биты нижнего %s\n */
PioMenuIrqEdge = соответствующий бит в регистре захвата
PioMenuIrqLevel = соответствующий вход
PioMenuMaskFunctionsRemark = /* С помощью следующих функций регистр маски прерывания может быть установлен или считан.\n * 1 на определенном местоположении означает, что будет сгенерировано прерывание.\n * если %s равно 1.\n * Примечание: используются только биты нижнего %s.\n */
PioMenuOutClearRemark = /* С помощью следующей функции биты, составляющие 1 бит в параметре «value», будут вызывать следующие действия\n * соответствующий выход 0\n * Примечание: используются только биты нижнего %s.\n */
PioMenuOutputDataFunctionRemark = /* С помощью следующей функции выходные значения PIO могут быть следующими\n * Готово.\n * Эта функция принимает новое выходное значение в качестве параметра «значение».\n * Примечание: действительны только биты нижних %s входящего в комплект поставки параметра «Значение».\n */
PioMenuOutSetRemark = /* С помощью следующей функции биты, составляющие 1 бит в параметре «value», будут вызывать следующие действия\n * соответствующий выходу 1\n * Примечание: используются только биты нижнего %s.\n */
SelectDirectoryToStoreC = Задать директорию для хранения С-шаблонов
SuccesCreatingHeaderAndCFile = Файлы успешно созданы:\n%s\nи\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Бидир бит %s
SocPioBidirs = Двунаправленные штифты
SocPioComponent = Параллельный модуль расширения входов/выходов
SocPioInputPinx = Входной бит %s
SocPioInputs = Входные контакты
SocPioIrqOutput = Выход Irq
SocPioOutputPinx = Выходной бит %s
SocPioOutputs = Выходные контакты
SocPioResetInput = Вход сброса
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Симулятор мгновенного обмена мгновенными сообщениями Risc V
# ==> Rv32PlicBaseAddress =
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = Ожидаемый один или два аргумента
Rv32imAssemblerExpectedTwoOrThreeArguments = Ожидаемые два или три аргумента
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = В настоящее время природоохранные точки вызова и останова не реализованы
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = БУГ!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Ожидаемый регистр в квадратных скобках, например (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Ожидаемый немедленный индексированный регистр, например, 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Неподдерживаемый опкод asm
Rv32imMOINotImplmented = В настоящее время инструкции по заказу памяти не реализованы.
#
# Soc.java
#
SocBusComponent = симулятор шины SoC
socLibrary = System On a Chip
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Неизвестный опкод
UnknownInstruction = Неизвестная инструкция
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Предположим самый низкий адрес с инструкцией в качестве точки входа.\nЧтобы убедиться, что ваш процессор начинает исполняться по правильному адресу.\nпожалуйста, добавьте ярлык под названием «_старт» в адрес сайта.\nгде ваш процессор должен начать выполнение программы.
AssemblerCannotUseInsideMacro = Эта конструкция не может быть использована внутри макроопределения
AssemblerEndOfMacroNotFound = Не смог найти конца макроопределения.
AssemblerExpectedMacroName = Ожидаемое название макроса
AssemblerExpectedMacroNrOfParameters = Ожидаемое количество макропараметров
AssemblerExpectingLabelIdentifier = Ожидание ярлыка
AssemblerMissingLabelBefore = Для этого оператором должна быть метка
AssemblerNoExecutableSection = Не найдено ни одной команды, которая могла бы быть выполнена.
AssemblerReguiresNumberAfterMath = После математической операции нужно следовать за цифрой.
AssemblerUnknowCharacter = Неизвестный персонаж
AssemblerWrongClosingBracket = Этот закрывающий кронштейн не поддерживается
AssemblerWrongOpeningBracket = Этот кронштейн не поддерживается
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Не смог определить адрес для этой этикетки.
AssemblerCouldNotFindValueForDefine = Не смог найти определение этого параметра.
AssemblerDivZero = Разделить на ноль ошибок
AssemblerExpectedImmediateValueAfterMath = Ожидаемое немедленное значение после математической операции.
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Имена этикеток должны быть уникальными, найдено несколько определений этой этикетки.
AssemblerDuplicatedName = Невозможно использовать одно и то же имя для домена .equ и метки.
AssemblerDuplicatedSectionError = Имена секций должны быть уникальными, найдено несколько секций с таким именем.
AssemblerExpectedLabel = Ожидал лейбл
AssemblerExpectedLabelAndNumber = Ожидаемая метка с последующим немедленным введением значения
AssemblerExpectedParameter = Ожидаемый параметр на этой позиции
AssemblerExpectingNumber = Ожидаемый номер
AssemblerExpectingPositiveNumber = Ожидаемое положительное число
AssemblerExpectingSectionName = Ожидая название этого раздела.
AssemblerExpectingString = Ожидал строку
AssemblerMacroIncorrectNumberOfParameters = Неправильное количество указанных макропараметров
AssemblerOverlappingSections = Этот раздел пересекается с другим разделом
AssemblerUnknownIdentifier = Я не знаю этого идентификатора.
AssemblerUnknownLabel = Этот ярлык не определен, поэтому я не могу его использовать.
AssemblerUnsupportedAssemblerInstruction = Эта инструкция по сборке неизвестна.
AssemblerValueOutOfRange = Значение выходит за пределы диапазона
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Макросы звонят друг другу, создавая тупиковую ситуацию.
AssemblerMacroCannotUseRecurency = Макро называет себя вызывающим тупиковую ситуацию.
AssemblerMacroParameterNotDefined = Этот макропараметр не определен, проверьте количество параметров в вашем макросе.
#
# vga/SocVgaShape.java
#
SocVgaComponent = экран VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Адрес буфера пикселей Адрес:
VgaInitialDisplayMode = Исходный режим:
VgaSoftMode = Программное %s:
VgaStartAddress = Базовый адрес:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* С помощью следующих функций можно управлять режимом vga.\n * При чтении vga-режима возвращаются поддерживаемые режимы (см. выше определения возможных режимов).\n * Запись поддерживаемого режима изменит режим отображения на VGA-дисплее.\n */
#
# dma/SocDma.java, dma/DmaAttributes.java
#
# ==> SocDmaComponent =
# ==> SocDmaStartAddress =
# ==> SocDmaBurstSize =
# ==> SocDmaSrcBus =
# ==> SocDmaDstBus =
# ==> SocDmaResetInput =
# ==> SocDmaClockInput =
# ==> SocDmaIrqOutput =
# ==> SocDmaBaseLabel =
# ==> SocDmaBurstLabel =
# ==> SocDmaStatusIdle =
# ==> SocDmaStatusBusy =
# ==> SocDmaStatusDone =
