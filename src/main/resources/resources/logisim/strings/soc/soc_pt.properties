#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Tamanho dos vestígios:
SocBusTraceVisible = Vestígios visíveis:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Inserir uma transação de ônibus
SocBusMemMap = Mostrar mapa de memória
SocBusTraceWindow = Mostrar rastreamento de transação(ões) de ônibus
SocInsertTransWindowTitle = Inserir uma transação no ônibus:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Bus trace window (clique duas vezes em um traçado para removê-lo)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Não ligado a um autocarro
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Não há vestígios presentes
SocMemMapWindowTitle = Mapa de Memória para ônibus:
SocMemoryMapOk = Fechar
SocMemoryMapTitle = Mapa de Memória (o vermelho indica regiões de memória sobrepostas):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Iniciador:
SocBusStateNoDataMax10chars = nenhum dado
SocBusStateSlave = Responsável:
SocBusStateTraceIndex = Transacção nº:
SocTransactionByteAccesNoSupport = Escravo não suporta acessos por bytes.
SocTransactionByteAccesNoSupportShort = Sem acesso a bytes
SocTransactionHalfWordAccesNoSupport = Escravo não suporta acessos de meia palavra.
SocTransactionHalfWordAccesNoSupportShort = Sem acesso HW
SocTransactionMisalignedAddress = O escravo detectou um endereço desalinhado.
SocTransactionMisalignedAddressShort = Misal. Endereço.
SocTransactionMultipleSlaveAnswers = Múltiplos escravos respondidos a uma transacção. Por favor, verifique o mapa de memória dos seus escravos.
SocTransactionMultipleSlaveAnswersShort = Múltiplos escravos
SocTransactionNoBusConnected = O componente mestre não está conectado a nenhum barramento SoC. Por favor, conecte o mestre a um componente de barramento.
SocTransactionNoBusConnectedShort = Sem ônibus
SocTransactionNoneAtomicRW = Uma ação de leitura/gravação atômica nenhuma é solicitada. Isto não é permitido.
SocTransactionNoneAtomicRWShort = Nenhum RW atómico
SocTransactionNoRespons = Nenhum componente escravo respondeu ao pedido. Verifique o endereço de memória do pedido e o mapa de memória do seu sistema.
SocTransactionNoResponsShort = Sem resposta
SocTransactionNoSlavesAttached = O bus que está ligado ao mestre não tem escravos ligados. Por favor, prendam alguns escravos ao autocarro.
SocTransactionNoSlavesAttachedShort = Sem escravos
SocTransactionReadOnlyAccessError = Escravo suporta apenas acessos de leitura neste endereço
SocTransactionReadOnlyAccessErrorShort = Apenas leitura
SocTransactionRegisterDoesNotExist = Escravo não suporta nenhum acesso neste endereço
SocTransactionRegisterDoesNotExistShort = Sem acesso
SocTransactionSuccessfull = Não ocorreu nenhum erro, a transação é bem-sucedida.
SocTransactionSuccessfullShort = Sucesso
SocTransactionUnknownError = Bizarro, esta mensagem de erro nunca deve ocorrer e representa um bug em logisim.
SocTransactionUnknownErrorShort = BUG!
SocTransactionWordAccesNoSupport = Escravo não suporta acesso a palavras.
SocTransactionWordAccesNoSupportShort = Sem acesso a palavras
SocTransactionWriteOnlyAccessError = Escravo não suporta uma ação de leitura neste endereço.
SocTransactionWriteOnlyAccessErrorShort = Escrever apenas
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Vazio (sem escravos)
SocMemMapEndAddress = Endereço final:
SocMemMapSlaveName = Nome do componente:
SocMemMapStartAddress = Endereço inicial:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Por favor, selecione um ônibus para se conectar a
SocBusSelectAttr = Bus conectado
SocBusSelectAttrClick = Clique para selecionar
SocManagerNoBusses = Não há autocarros disponíveis, por favor adicione um SoC-bus ao seu esquema
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Carregou com sucesso o arquivo de elfo na memória.\nO ponto de entrada do executável foi definido para o processador.\n\nImportante:\n   Como o arquivo do elfo não tem informações sobre os vetores de exceção\n   tens de as controlar tu mesmo!
SocUpMenuAsmWindow = Assembler aberto
SocUpMenuCpuAsmWindowTitle = assembler para cpu:
SocUpMenuCpuProgramWindowTitle = desmontador para cpu:
SocUpMenuCpuStateWindowTitle = estado do processador para cpu:
SocUpMenuErrorReadingElfTitle = Erro na leitura do arquivo de elfo
SocUpMenuReadElf = Ler arquivo de elfo
SocUpMenuSelectElfFile = Selecione o arquivo de elfo para importar
SocUpMenuShowProgram = Mostrar programa carregado
SocUpMenuShowState = Mostrar estado da CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Parado
SocUpSimHaltBreak = Ponto de parada
SocUpSimHaltError = Erro
SocUpSimRunning = Corrida
SocUpSimStateLabel = Estado Sim:
SocUpSimstateStart = Início
SocUpSimstateStop = Pausa
SocUpUnknown = Desconhecido
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Não é um arquivo de elfo de 32 ou 64 bits
ElfHeaderEIDataError = Não é um pequeno ou grande arquivo codificado endian
ElfHeaderIncorrectEISize = O tamanho da secção EI está incorrecto
ElfHeaderIncorrectESize = O tamanho da secção E está incorrecto
ElfHeaderIncorrectMagic = O arquivo não contém o elf-magic correto; provavelmente não é um arquivo de elf-magic
ElfHeaderNoErrors = O cabeçalho está correto
ElfHeaderReadingFileError = Erro ao ler o ficheiro
ElfHeaderUnknownArchitecture = Arquitetura desconhecida
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Cabeçalho do programa não encontrado.
ProgHeaderReadError = Erro na leitura do cabeçalho do programa.
ProgHeaderSizeError = Desencontro de tamanho no cabeçalho do programa.
ProgHeaderSuccess = Sucesso
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Encontrei várias tabelas de strings, não suportadas no momento.
ElfSectHeadMultiSymtabError = Encontrei várias tabelas de símbolos, não suportadas de momento;
ElfSectHeadNotFound = O cabeçalho da secção não foi encontrado.
ElfSectHeadReadError = Cabeçalho da seção de leitura de erros.
ElfSectHeadSizeError = Desajuste de tamanho no cabeçalho da seção.
ElfSectHeadStingIdxError = Error String index.
ElfSectHeadStingNotFound = Nome da secção não encontrado.
ElfSectHeadStingReadError = Erro ao ler a tabela de strings.
ElfSectHeadStingTypeError = Erro de tipo String.
ElfSectHeadSuccess = Sucesso
ElfSymTableNotFound = Não consegui encontrar a tabela de símbolos.
ElfSymTableReadError = Não conseguia ler a tabela de símbolos.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim ainda não suporta arquivos de elfo de 64 bits.
ProcReadElfArchError = Arquivo de elfo é para um processador de Elf, enquanto que deveria ser para um processador de Elf.
ProcReadElfEndianMismatch = Endian Mismatch, arquivo de elfo é "Elf", enquanto o processador pediu "Elf".
ProcReadElfErrorOpeningFile = Impossível abrir o arquivo de elfo
ProcReadElfLoadableSectionNotFound = Seção carregável não encontrada no arquivo do elfo.
ProcReadElfLoadableSectionReadError = Erro na leitura da seção carregável.
ProcReadElfLoadableSectionSizeError = Desajuste de tamanho na seção carregável.
ProcReadElfLoadableSectionTooBig = O tamanho da seção carregável é maior do que o tamanho suportado pelo logisim.
ProcReadElfMemoryError = Ocorreu um erro ao escrever uma secção carregável na memória.\nCertifique-se de que tem um componente de memória SoC disponível para a região de memória:\n%s…%s
ProcReadElfNotExecutable = O arquivo de elfo não é um executável
ProcReadElfSuccess = Sucesso
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Arquivos de montagem (.asm,.S)
AsmPanAssemble = Montar o código (ALT-A)
AsmPanDocumentChangedSave = Há alterações no seu documento, guarde-as?
AsmPanErrorCreateFile = Não é possível criar o arquivo de montagem.
AsmPanErrorReadingFile = Não é possível ler o arquivo
AsmPanNextError = Saltar para o próximo erro (CTRL-N)
AsmPanOpenFile = Ler um ficheiro (CTRL-L)
AsmPanPreviousError = Saltar para erro anterior (CTRL-P)
AsmPanReadAsmFile = Selecione um arquivo para ler
AsmPanRun = Executar o código (ALT-R)
AsmPanSaveAsmFile = Selecione um arquivo para salvar
AsmPanSaveFile = Gravar file (CTRL-S)
AsmPanSaveFileAs = Salvar arquivo como
AsmPanSaveFirstBeforeOpen = Há modificações no documento\nVocê quer salvá-los antes de abrir um novo arquivo?
AssemblerAssembleSuccess = Sucesso!\nNão foram encontrados erros no seu código.
AssemblerRunSuccess = O programa foi carregado com sucesso na memória.\nPara executar o programa, por favor, certifique-se disso:\na) você habilita os ticks\nb) você configura o cpu para o modo de execução
AssemblerUnableToDownload = Não é possível armazenar o programa na memória,\npor favor, certifique-se de que tem memória suficiente disponível\nnos locais de memória correctos.
RV32imAsmLineIndicator = Linha %d de %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Remover ponto de parada
RV32imSetBreakpoint = Adicionar ponto de parada
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Endereço do autocarro: 0x
SocTransInsAtomicRequest = Transação atômica
SocTransInsByteAccess = Transação de byte
SocTransInsHalfWordAccess = Transação de meia palavra (2 bytes)
SocTransInsInputData = Dados para escrever: 0x
SocTransInsInsertTransaction = Inserir a transação no ônibus
SocTransInsManual = Manual inserido
SocTransInsReadData = Dados devolvidos:
SocTransInsReadRequest = Pedido de leitura de barramento
SocTransInsTransResultTitle = Resultado da transação inserida:
SocTransInsWordAccess = Transação Word (4 bytes)
SocTransInsWriteRequest = Solicitação de gravação de barramento
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Montagem:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = Não há vestígios de execução disponíveis
Rv32imExecutionTrace = Traçado de execução (último executado em cima):
Rv32imRegisterFile = Ficheiro de registo:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Controle de simulação
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Limpar teclado
JtagUartKeybAvailable = Dados do teclado disponíveis
JtagUartKeybData = Dados do teclado
JtagUartKeybReadEnable = Habilitação de leitura do teclado
JtagUartTtyClear = TTY transparente
JtagUartTtyData = Dados TTY
JtagUartTtyWrite = TTY escrever dados
SocJtagUartComponent = JTAG UART
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = Ler limiar IRQ
JtagUartWriteIrqThreshold = Escrever o limiar IRQ
UartJtagREADFifoSize = Ler tamanho FIFO:
UartJtagWriteFifoSize = Escrever tamanho FIFO:
#
# memory/SocMemory.java
#
SocMemBase = Base:
SocMemoryComponent = Simulador de memória
SocMemSizeStr = Tamanho:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Largura do endereço de byte:
SocMemStartAddress = Endereço inicial:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Simulador Nios2s
Nios2Dataa = Dados A
Nios2Datab = Dados B
Nios2Done = Feito em
Nios2N = N
Nios2ReadRa = Leia Ra
Nios2ReadRb = Ler Rb
Nios2Result = Resultado
Nios2Start = Início
Nios2WriteRc = Escrever Rc
Rv32imClockInput = Entrada do relógio
Rv32imIrqInput = Entrada IRQ %s
Rv32imResetInput = Entrada de reinicialização
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Vetor de Quebra
rv32ExceptionVector = Vetor de exceção
rv32imIrqWidth = Número de linhas IRQ
rv32ResetVector = Repor vector
rv32StateVisible = Estado visível:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Quatro argumentos esperados
Nios2DonePinError = O pino executado não definido ou em estado de erro não pode continuar.\n Por favor, verifique o pino feito.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Erro ao executar uma carga do sistema de memória:
LoadStoreErrorInWriteTransaction = Erro ao realizar um armazenamento no sistema de memória:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Valor esperado imediato
AssemblerExpectedNoArguments = Não se esperam argumentos
AssemblerExpectedOneArgument = Um argumento esperado
AssemblerExpectedTwoArguments = Dois argumentos esperados
AssemblerExpectedZeroOrOneArgument = Não se esperava nenhum ou um argumento
AssemblerImmediateOutOfRange = O valor imediato está fora do intervalo
AssemblerUnknownRegister = Registro desconhecido
Nios2AssemblerExpectedBracketedRegister = Espera-se um registro entre parênteses, por exemplo (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Espera-se um registo indexado imediato, por exemplo, 5(r1)
Nios2CannotUseControlRegister = Não é possível usar um registro de controle neste contexto
Nios2CannotUseCustomRegister = Não é possível usar um registro personalizado neste contexto
Nios2ExpectedControlRegister = Espera-se um registo de controlo (por exemplo, ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Três argumentos esperados
AssemblerExpextedImmediateOrLabel = Espera-se um valor imediato ou um rótulo
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = status
RV32imBreakPointReached = A execução é pausada devido a um ponto de parada definido na instrução atual.
RV32imFetchExecutionError = Erro na execução da instrução buscada
RV32imFetchInvalidInstruction = Instrução inválida obtida
RV32imFetchInvInstrAsm = Instrução inválida!
RV32imFetchTransaction = -> Buscar erro de transação.
Rv32imProgramCounter = pc:
SocHiddenForFasterSimulation = Conteúdos ocultos para uma simulação mais rápida
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Esperava um registo
#
# pio/PioAttributes.java
#
SicPioIrqType = Tipo Irq:
SocPioAnyEdge = Qualquer borda
SocPioBidir = Portas bidirecionais (tristate)
SocPioCaptureEdge = Tipo de captura:
SocPioDirection = Direção:
SocPioFallingEdge = Borda de queda
SocPioGenIRQ = IRQ activado:
SocPioInout = Portas de entrada e saída
SocPioInputCaptureBit = Captura de bit-clearing:
SocPioInputOnly = Apenas portas de entrada
SocPioInputsSyncCapture = Sincronização. Captura:
SocPioIrQEdge = Borda
SocPioIrqLevel = Nível
SocPioOutputIndividualBits = Saída bit set/clear:
SocPioOutputOnly = Apenas portas de saída
SocPioOutputResetValue = Valor de reposição de saída:
SocPioRisingEdge = Borda ascendente
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Não foi possível criar um ficheiro header e/ou c!
ExportC = Exportar modelos C
PioMenuBidirFunctionsRemark = /* Com as seguintes funções o registo bidireccional pode ser definido ou lido\n * a 1 indica que o respeito. bit é uma saída, um 0 indica que é uma entrada\n * Nota: apenas os bits de %s mais baixos são usados.\n */
PioMenuCaptureAll = limpar todos os bits do registo de captura independentemente do valor do parâmetro "valor".
PioMenuCaptureAny = pelo menos uma alteração de 0 para 1 ou de 1 para 0
PioMenuCaptureBit = limpar os bits no registro de captura que são 1 no parâmetro "valor".
PioMenuCaptureFalling = pelo menos uma alteração de 1 para 0
PioMenuCaptureRising = pelo menos uma alteração de 0 para 1
PioMenuEdgeCaptureRemark = /* Com as seguintes funções, o registro de captura de borda pode ser apagado ou lido\n * no caso do registro de borda ser lido um 1 em uma posição indica que o\n * A respectiva entrada tem o chapéu %s,\n * caso contrário, a respectiva entrada não foi alterada.\n *\n * Escrever para este registro será %s.\n * Nota: apenas os bits de %s mais baixos são usados.\n */
PioMenuInputDataFunctionRemark = /* Com a seguinte função, os valores de entrada do PIO podem ser\n * ? read out.\n * Esta função retorna o respectivo valor\n * Nota: apenas os bits %s mais baixos são válidos\n */
PioMenuIrqEdge = bit correspondente no registro de captura
PioMenuIrqLevel = entrada correspondente
PioMenuMaskFunctionsRemark = /* Com as seguintes funções, o registro da máscara de interrupção pode ser configurado ou lido.\n * A 1 em uma localização específica indica que uma interrupção será gerada\n * se a %s for igual a 1.\n * Nota: apenas os bits de %s mais baixos são usados.\n */
PioMenuOutClearRemark = /* Com a seguinte função os bits que são 1 no parâmetro "valor" forçarão\n * a saída correspondente a 0\n * Nota: apenas os bits de %s mais baixos são usados.\n */
PioMenuOutputDataFunctionRemark = /* Com a seguinte função, os valores de saída do PIO podem ser\n * set.\n * Esta função toma o novo valor de saída como parâmetro "valor".\n * Nota: apenas os bits %s mais baixos do parâmetro "valor" fornecido são válidos.\n */
PioMenuOutSetRemark = /* Com a seguinte função os bits que são 1 no parâmetro "valor" forçarão\n * a saída correspondente a 1\n * Nota: apenas os bits de %s mais baixos são usados.\n */
SelectDirectoryToStoreC = Definir diretório para armazenar os modelos C
SuccesCreatingHeaderAndCFile = Criou os arquivos com sucesso:\n%s\ne\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Pinos bidirecionais
SocPioComponent = Expansor de entrada/saída paralela
SocPioInputPinx = Bit de entrada %s
SocPioInputs = Pinos de entrada
SocPioIrqOutput = Saída Irq
SocPioOutputPinx = Bit de saída %s
SocPioOutputs = Pinos de saída
SocPioResetInput = Entrada de reinicialização
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Simulador Risc V IM
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = Espera-se um ou dois argumentos
Rv32imAssemblerExpectedTwoOrThreeArguments = Dois ou três argumentos esperados
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Atualmente, a chamada ambiental e os breakpoints não estão implementados
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Espera-se um registro entre parênteses, por exemplo (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Espera-se um registo indexado imediato, por exemplo, 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Opcode não suportado asm opcode
Rv32imMOINotImplmented = Atualmente as instruções de pedido de memória não estão implementadas
#
# Soc.java
#
SocBusComponent = Simulador de barramento SoC
socLibrary = Sistema On Chip
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Desconhecido opcode
UnknownInstruction = Instrução desconhecida
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Assumindo o endereço mais baixo com uma instrução como ponto de entrada.\nPara se certificar de que a sua cpu começa a ser executada no endereço certo\npor favor adicione um rótulo chamado '_start' no local\nonde a sua CPU deve começar a executar o programa.
AssemblerCannotUseInsideMacro = Esta construção não pode ser usada dentro de uma definição de macro
AssemblerEndOfMacroNotFound = Não foi possível encontrar o fim da definição macro
AssemblerExpectedMacroName = Espera-se um nome para a macro
AssemblerExpectedMacroNrOfParameters = Número esperado de parâmetros de macro
AssemblerExpectingLabelIdentifier = Esperando um rótulo
AssemblerMissingLabelBefore = Para este operador deve ser um rótulo
AssemblerNoExecutableSection = Não foram encontradas instruções que possam ser executadas.
AssemblerReguiresNumberAfterMath = Após uma operação matemática deve seguir um número
AssemblerUnknowCharacter = Carácter desconhecido
AssemblerWrongClosingBracket = Este suporte de fechamento não é suportado
AssemblerWrongOpeningBracket = Este suporte de abertura não é suportado
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Não foi possível determinar um endereço para esta etiqueta
AssemblerCouldNotFindValueForDefine = Não foi possível encontrar uma definição deste parâmetro
AssemblerDivZero = Dividir por erro zero
AssemblerExpectedImmediateValueAfterMath = Valor esperado imediato após uma operação matemática
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Os nomes dos rótulos devem ser únicos, encontrados várias definições deste rótulo
AssemblerDuplicatedName = Não é possível usar o mesmo nome para um .equ e uma etiqueta
AssemblerDuplicatedSectionError = Os nomes das secções devem ser únicos, encontrados em múltiplas secções com este nome
AssemblerExpectedLabel = Esperava uma etiqueta
AssemblerExpectedLabelAndNumber = Espera-se um rótulo seguido de um valor imediato
AssemblerExpectedParameter = Um parâmetro esperado nesta posição
AssemblerExpectingNumber = Um número esperado
AssemblerExpectingPositiveNumber = Esperava um número positivo
AssemblerExpectingSectionName = Esperando um nome para esta seção
AssemblerExpectingString = Esperava uma string
AssemblerMacroIncorrectNumberOfParameters = Número incorreto de parâmetros de macro especificados
AssemblerOverlappingSections = Esta seção se sobrepõe a outra seção
AssemblerUnknownIdentifier = Não conheço este identificador
AssemblerUnknownLabel = Esta etiqueta não foi definida, por isso não posso usá-la.
AssemblerUnsupportedAssemblerInstruction = Esta instrução de assembler não é conhecida
AssemblerValueOutOfRange = Valor fora do intervalo
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = As macros estão a chamar-se umas às outras, causando uma situação de impasse.
AssemblerMacroCannotUseRecurency = A macro está a chamar-se a si própria, causando uma situação de impasse.
AssemblerMacroParameterNotDefined = Este parâmetro de macro não está definido, verificar o número de parâmetros na definição de macro
#
# vga/SocVgaShape.java
#
SocVgaComponent = Tela VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Endereço do buffer de pixels:
VgaInitialDisplayMode = Modo inicial:
VgaSoftMode = Software %s:
VgaStartAddress = Endereço base:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* Com as seguintes funções o modo vga pode ser manipulado.\n * Ler o modo vga retorna os modos suportados (ver acima define os modos possíveis)\n * Escrever um modo suportado mudará o modo de exibição do visor VGA\n */
