#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Trace size:
SocBusTraceVisible = Traces visible:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Insert a bus transaction
SocBusMemMap = Show memory map
SocBusTraceWindow = Show bus transaction(s) trace
SocInsertTransWindowTitle = Insert a transaction to bus:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Bus trace window (double click on a trace to remove it)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Not connected to a bus
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = No traces present
SocMemMapWindowTitle = Memory Map for bus:
SocMemoryMapOk = Close
SocMemoryMapTitle = Memory Map (red indicates overlapping memory regions):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Initiator:
SocBusStateNoDataMax10chars = no data
SocBusStateSlave = Responder:
SocBusStateTraceIndex = Transaction nr.:
SocTransactionByteAccesNoSupport = Slave does not support byte accesses.
SocTransactionByteAccesNoSupportShort = No byte access
SocTransactionHalfWordAccesNoSupport = Slave does not support half word accesses.
SocTransactionHalfWordAccesNoSupportShort = No HW access
SocTransactionMisalignedAddress = Slave detected a misaligned address.
SocTransactionMisalignedAddressShort = Misal. Addr.
SocTransactionMultipleSlaveAnswers = Multiple slaves answered to a transaction. Please check the memory map of your slaves.
SocTransactionMultipleSlaveAnswersShort = Multiple slaves
SocTransactionNoBusConnected = The master component is not connected to any SoC Bus. Please connect the master to a bus component.
SocTransactionNoBusConnectedShort = No bus
SocTransactionNoneAtomicRW = A none atomic read/write action is requested. This is not allowed.
SocTransactionNoneAtomicRWShort = None atomic RW
SocTransactionNoRespons = No slave component answered to the request. Please check the memory address of the request and the memory map of your system.
SocTransactionNoResponsShort = No response
SocTransactionNoSlavesAttached = The bus that is connected to the master has no slaves attached. Please attach some slaves to the bus.
SocTransactionNoSlavesAttachedShort = No slaves
SocTransactionReadOnlyAccessError = Slave supports only read accesses on this address
SocTransactionReadOnlyAccessErrorShort = Read only
SocTransactionRegisterDoesNotExist = Slave does not support any access on this address
SocTransactionRegisterDoesNotExistShort = No access
SocTransactionSuccessfull = No error has occurred, the transaction is successful.
SocTransactionSuccessfullShort = Success
SocTransactionUnknownError = Bizarre, this error message should never occur and represents a bug in logisim.
SocTransactionUnknownErrorShort = BUG!
SocTransactionWordAccesNoSupport = Slave does not support word accesses.
SocTransactionWordAccesNoSupportShort = No word access
SocTransactionWriteOnlyAccessError = Slave does not support a read action on this address.
SocTransactionWriteOnlyAccessErrorShort = Write only
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Empty (no slaves)
SocMemMapEndAddress = End address:
SocMemMapSlaveName = Name of component:
SocMemMapStartAddress = Start address:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Please select a bus to connect to
SocBusSelectAttr = Connected bus
SocBusSelectAttrClick = Click to select
SocManagerNoBusses = No buses available, please add a SoC-bus to your schematic
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Successfully loaded the elf file into memory.\nThe entry point of the executable has been set to the processor.\n\nImportant:\n   As the elf file has no information on the exception vectors\n   you have to control them yourself!
SocUpMenuAsmWindow = Open assembler
SocUpMenuCpuAsmWindowTitle = assembler for cpu:
SocUpMenuCpuProgramWindowTitle = disassembler for cpu:
SocUpMenuCpuStateWindowTitle = processor state for cpu:
SocUpMenuErrorReadingElfTitle = Error in reading elf file
SocUpMenuReadElf = Read elf file
SocUpMenuSelectElfFile = Select elf file to import
SocUpMenuShowProgram = Show loaded program
SocUpMenuShowState = Show CPU state
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Halted
SocUpSimHaltBreak = Break point
SocUpSimHaltError = Error
SocUpSimRunning = Running
SocUpSimStateLabel = Sim state:
SocUpSimstateStart = Start
SocUpSimstateStop = Pause
SocUpUnknown = Unknown
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Not a 32 or 64 bit elf file
ElfHeaderEIDataError = Not a little or big endian encoded file
ElfHeaderIncorrectEISize = The size for the EI-section is incorrect
ElfHeaderIncorrectESize = The size for the E-section is incorrect
ElfHeaderIncorrectMagic = The file does not contain the correct elf-magic; probably not an elf-file
ElfHeaderNoErrors = Header is correct
ElfHeaderReadingFileError = Error reading the file
ElfHeaderUnknownArchitecture = Unknown architecture
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Program header not found.
ProgHeaderReadError = Error reading program header.
ProgHeaderSizeError = Size mismatch in program header.
ProgHeaderSuccess = Success
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Found multiple string tables, not supported for the moment.
ElfSectHeadMultiSymtabError = Found multiple symbol tables, not supported for the moment;
ElfSectHeadNotFound = Section header not found.
ElfSectHeadReadError = Error reading section header.
ElfSectHeadSizeError = Size mismatch in section header.
ElfSectHeadStingIdxError = Error String index.
ElfSectHeadStingNotFound = Section name not found.
ElfSectHeadStingReadError = Error reading string table.
ElfSectHeadStingTypeError = String type error.
ElfSectHeadSuccess = Success
ElfSymTableNotFound = Could not find the symbol table.
ElfSymTableReadError = Could not read the symbol table.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim does not yet support 64-bit elf files.
ProcReadElfArchError = Elf file is for a \"%s\" processor whilst it should be for a \"%s\" processor.
ProcReadElfEndianMismatch = Endian mismatch, elf file is \"%s\" whilst the processor requested \"%s\".
ProcReadElfErrorOpeningFile = Impossible to open elf-file
ProcReadElfLoadableSectionNotFound = Loadable section not found in elf file.
ProcReadElfLoadableSectionReadError = Error reading loadable section.
ProcReadElfLoadableSectionSizeError = Size mismatch in loadable section.
ProcReadElfLoadableSectionTooBig = The size of the loadable section is bigger as the size supported by logisim.
ProcReadElfMemoryError = An error occurred writing a loadable section to memory.\nMake sure you have a SoC memory component available for the memory region:\n%s...%s
ProcReadElfNotExecutable = The elf-file is not an executable
ProcReadElfSuccess = Success
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Assembly files (.asm,.S)
AsmPanAssemble = Assemble the code (ALT-A)
AsmPanDocumentChangedSave = There are changes in your document, save them?
AsmPanErrorCreateFile = Unable to create the assembly file.
AsmPanErrorReadingFile = Unable to read the file
AsmPanNextError = Jump to next error (CTRL-N)
AsmPanOpenFile = Read a file (CTRL-L)
AsmPanPreviousError = Jump to previous error (CTRL-P)
AsmPanReadAsmFile = Select a file to read
AsmPanRun = Run the code (ALT-R)
AsmPanSaveAsmFile = Select a file to save
AsmPanSaveFile = Save file (CTRL-S)
AsmPanSaveFileAs = Save file as
AsmPanSaveFirstBeforeOpen = There are changes in your document\nDo you want to save them before opening a new file?
AssemblerAssembleSuccess = Success!\nNo errors found in your code.
AssemblerRunSuccess = Successfully loaded the program to memory.\nTo run the program, please make sure that:\n- you enable the ticks\n- you set the CPU to running mode.
AssemblerUnableToDownload = Unable to store the program to memory,\nplease make sure that you have enough memory available\nat the correct memory locations.
RV32imAsmLineIndicator = Line %d of %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Remove break point
RV32imSetBreakpoint = Add break point
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Bus address: 0x
SocTransInsAtomicRequest = Atomic transaction
SocTransInsByteAccess = Byte transaction
SocTransInsHalfWordAccess = Half word transaction (2 bytes)
SocTransInsInputData = Data to write: 0x
SocTransInsInsertTransaction = Insert the transaction into the bus
SocTransInsManual = Manual inserted
SocTransInsReadData = Data returned:
SocTransInsReadRequest = Bus read request
SocTransInsTransResultTitle = Result of the inserted transaction:
SocTransInsWordAccess = Word transaction (4 bytes)
SocTransInsWriteRequest = Bus write request
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Assembly:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = No execution traces available
Rv32imExecutionTrace = Execution trace (last executed on top):
Rv32imRegisterFile = Register file:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Simulation control
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Clear keyboard
JtagUartKeybAvailable = Keyboard data available
JtagUartKeybData = Keyboard data
JtagUartKeybReadEnable = Keyboard read enable
JtagUartTtyClear = TTY clear
JtagUartTtyData = TTY data
JtagUartTtyWrite = TTY write data
SocJtagUartComponent = JTAG UART
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = Read IRQ threshold
JtagUartWriteIrqThreshold = Write IRQ threshold
UartJtagREADFifoSize = Read FIFO size:
UartJtagWriteFifoSize = Write FIFO size:
#
# memory/SocMemory.java
#
SocMemBase = Base:
SocMemoryComponent = Memory simulator
SocMemSizeStr = Size:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Byte address width:
SocMemStartAddress = Start address:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Nios2s simulator
Nios2Dataa = Data A
Nios2Datab = Data B
Nios2Done = Done
Nios2N = N
Nios2ReadRa = Read Ra
Nios2ReadRb = Read Rb
Nios2Result = Result
Nios2Start = Start
Nios2WriteRc = Write Rc
Rv32imClockInput = Clock input
Rv32imIrqInput = IRQ input %s
Rv32imResetInput = Reset input
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Break Vector
rv32ExceptionVector = Exception vector
rv32imIrqWidth = Number of IRQ lines
rv32ResetVector = Reset vector
rv32StateVisible = State visible:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Expected four arguments
Nios2DonePinError = Done pin not defined or in error state cannot continue.\n Please check the done pin.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Error performing a load from memory system:
LoadStoreErrorInWriteTransaction = Error performing a store to the memory system:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Expected an immediate value
AssemblerExpectedNoArguments = Expected no arguments
AssemblerExpectedOneArgument = Expected one argument
AssemblerExpectedTwoArguments = Expected two arguments
AssemblerExpectedZeroOrOneArgument = Expected no or one argument
AssemblerImmediateOutOfRange = The immediate value is out of range
AssemblerUnknownRegister = Unknown register
Nios2AssemblerExpectedBracketedRegister = Expected a bracketed register, e.g. (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Expected an immediate indexed register, e.g. 5(r1)
Nios2CannotUseControlRegister = Cannot use a control register in this context
Nios2CannotUseCustomRegister = Cannot use a custom register in this context
Nios2ExpectedControlRegister = Expected a control register (e.g. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Expected three arguments
AssemblerExpextedImmediateOrLabel = Expected an immediate value or a label
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = status
RV32imBreakPointReached = Execution is paused due to a break point set at the current instruction.
RV32imFetchExecutionError = Error in executing fetched instruction
RV32imFetchInvalidInstruction = Invalid instruction fetched
RV32imFetchInvInstrAsm = Invalid instruction!
RV32imFetchTransaction = -> Fetch transaction error.
Rv32imProgramCounter = pc:
SocHiddenForFasterSimulation = Contents hidden for faster simulation
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Expected a register
#
# pio/PioAttributes.java
#
SicPioIrqType = Irq type:
SocPioAnyEdge = Any edge
SocPioBidir = Bidirectional (tristate) ports
SocPioCaptureEdge = Capture type:
SocPioDirection = Direction:
SocPioFallingEdge = Falling edge
SocPioGenIRQ = IRQ enabled:
SocPioInout = Both input and output ports
SocPioInputCaptureBit = Capture bit-clearing:
SocPioInputOnly = Input ports only
SocPioInputsSyncCapture = Sync. capture:
SocPioIrQEdge = Edge
SocPioIrqLevel = Level
SocPioOutputIndividualBits = Output bit set/clear:
SocPioOutputOnly = Output ports only
SocPioOutputResetValue = Output reset value:
SocPioRisingEdge = Rising edge
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Could not create header and/or c file!
ExportC = Export C-templates
PioMenuBidirFunctionsRemark = /* With the following functions the bi-directional register can be set or read out\n * a 1 indicates that the respect. bit is an output, a 0 indicates it is an input\n * Note: only the lower %s bits are used.\n */
PioMenuCaptureAll = clear all bits in the capture register independently of the value of the parameter "value"
PioMenuCaptureAny = at least one change from 0 to 1 or from 1 to 0
PioMenuCaptureBit = clear the bits in the capture register that are 1 in the parameter "value"
PioMenuCaptureFalling = at least one change from 1 to 0
PioMenuCaptureRising = at least one change from 0 to 1
PioMenuEdgeCaptureRemark = /* With the following functions the edge capture register can be cleared or read out\n * in case the edge register is read out a 1 on a position indicates that the\n * respective input has hat %s,\n * otherwise the respective input has not changed.\n *\n * Writing to this register will %s.\n * Note: only the lower %s bits are used.\n */
PioMenuInputDataFunctionRemark = /* With the following function the input values of the PIO can be\n * read out.\n * This function returns the respective value\n * Note: only the lower %s bits are valid\n */
PioMenuIrqEdge = corresponding bit in the capture register
PioMenuIrqLevel = corresponding input
PioMenuMaskFunctionsRemark = /* With the following functions the Interrupt mask register can be set or read out.\n * A 1 on a specific location indicates that an interrupt will be generated\n * if the %s is equal to 1.\n * Note: only the lower %s bits are used.\n */
PioMenuOutClearRemark = /* With the following function the bits that are 1 in the parameter "value" will force\n * the corresponding output to 0\n * Note: only the lower %s bits are used.\n */
PioMenuOutputDataFunctionRemark = /* With the following function the output values of the PIO can be\n * set.\n * This function takes the new output value as parameter "value"\n * Note: only the lower %s bits of the provided parameter "value" are valid\n */
PioMenuOutSetRemark = /* With the following function the bits that are 1 in the parameter "value" will force\n * the corresponding output to 1\n * Note: only the lower %s bits are used.\n */
SelectDirectoryToStoreC = Set directory to store the C-templates
SuccesCreatingHeaderAndCFile = Successfully created the files:\n%s\nand\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Bi-directional pins
SocPioComponent = Parallel input/output expander
SocPioInputPinx = Input bit %s
SocPioInputs = Input pins
SocPioIrqOutput = Irq output
SocPioOutputPinx = Output bit %s
SocPioOutputs = Output pins
SocPioResetInput = Reset input
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Risc V IM simulator
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = Expected one or two arguments
Rv32imAssemblerExpectedTwoOrThreeArguments = Expected two or three arguments
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Currently the environmental call and breakpoints are not implemented
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Expected a bracketed register, e.g. (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Expected an immediate indexed register, e.g. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Unsupported asm opcode
Rv32imMOINotImplmented = Currently the memory ordering instructions are not implemented
#
# Soc.java
#
SocBusComponent = SoC bus simulator
socLibrary = System On a Chip
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Unknown opcode
UnknownInstruction = Unknown instruction
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Assuming the lowest address with an instruction as entry-point.\nTo make sure that your cpu starts executing at the right address\nplease add a label called '_start' at the location\nwhere your cpu should start executing the program.
AssemblerCannotUseInsideMacro = This construct cannot be used inside a macro definition
AssemblerEndOfMacroNotFound = Could not find the end of the macro definition
AssemblerExpectedMacroName = Expected a name of the macro
AssemblerExpectedMacroNrOfParameters = Expected the number of macro parameters
AssemblerExpectingLabelIdentifier = Expecting a label
AssemblerMissingLabelBefore = For this operator should be a label
AssemblerNoExecutableSection = No instructions found that can be executed.
AssemblerReguiresNumberAfterMath = After a math operation should follow a number
AssemblerUnknowCharacter = Unknown character
AssemblerWrongClosingBracket = This closing bracket is not supported
AssemblerWrongOpeningBracket = This opening bracket is not supported
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Could not determine an address for this label
AssemblerCouldNotFindValueForDefine = Could not find a definition of this parameter
AssemblerDivZero = Divide by zero error
AssemblerExpectedImmediateValueAfterMath = Expected an immediate value after a math operation
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Label names must be unique, found multiple definitions of this label
AssemblerDuplicatedName = Cannot use the same name for a .equ and a label
AssemblerDuplicatedSectionError = Section names must be unique, found multiple sections with this name
AssemblerExpectedLabel = Expected a label
AssemblerExpectedLabelAndNumber = Expected a label followed by an immediate value
AssemblerExpectedParameter = Expected a parameter at this position
AssemblerExpectingNumber = Expected a number
AssemblerExpectingPositiveNumber = Expected a positive number
AssemblerExpectingSectionName = Expecting a name for this section
AssemblerExpectingString = Expected a string
AssemblerMacroIncorrectNumberOfParameters = Incorrect number of macro parameters specified
AssemblerOverlappingSections = This section overlaps with another section
AssemblerUnknownIdentifier = I do not know this identifier
AssemblerUnknownLabel = This label has not been defined, hence I cannot use it
AssemblerUnsupportedAssemblerInstruction = This assembler instruction is not known
AssemblerValueOutOfRange = Value is out of range
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Macros are calling each other causing a deadlock situation
AssemblerMacroCannotUseRecurency = Macro is calling itself causing a deadlock situation
AssemblerMacroParameterNotDefined = This macro parameter is not defined, check the number of parameters in your macro definition
#
# vga/SocVgaShape.java
#
SocVgaComponent = VGA screen
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Pixel buffer Address:
VgaInitialDisplayMode = Initial mode:
VgaSoftMode = Software %s:
VgaStartAddress = Base address:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* With the following functions the VGA mode can be manipulated.\n * Reading the VGA mode returns the supported modes (see above defines of possible modes)\n * Writing a supported mode will change the display mode of the VGA display\n */

