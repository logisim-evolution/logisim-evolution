#
# bus/SocBusAttributes.java
#
SocBusTraceSize = 总线事务踪迹数量
SocBusTraceVisible = 总线事务踪迹可见
#
# bus/SocBusMenuProvider.java
#
insertTrans = 插入总线事务
SocBusMemMap = 显示内存映射
SocBusTraceWindow = 显示总线事务踪迹
SocInsertTransWindowTitle = 将事务插入总线：
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = 总线踪迹窗口（双击踪迹可将其删除）
#
# data/SocBusInfo.java
#
SocBusNotConnected = 未连接到总线
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = 尚不存在踪迹
SocMemMapWindowTitle = 总线内存映射：
SocMemoryMapOk = 关闭
SocMemoryMapTitle = 内存映射（红色表示重叠的内存区域）：
#
# data/SocBusTransaction.java
#
SocBusStateMaster = 主设备：
SocBusStateNoDataMax10chars = 无数据
SocBusStateSlave = 从设备：
SocBusStateTraceIndex = 事务编号：
SocTransactionByteAccesNoSupport = 从设备不支持字节访问
SocTransactionByteAccesNoSupportShort = 不支持字节访问
SocTransactionHalfWordAccesNoSupport = 从设备不支持半字访问
SocTransactionHalfWordAccesNoSupportShort = 不支持半字访问
SocTransactionMisalignedAddress = 从设备检测到地址未对齐
SocTransactionMisalignedAddressShort = 地址未对齐
SocTransactionMultipleSlaveAnswers = 多个从设备对同一事务作出了响应，请检查从设备的内存映射
SocTransactionMultipleSlaveAnswersShort = 多个从设备响应
SocTransactionNoBusConnected = 主设备未连接到任何 SoC 总线，请将主设备连接到总线组件
SocTransactionNoBusConnectedShort = 未连接总线
SocTransactionNoneAtomicRW = 不允许请求非原子性的读/写操作
SocTransactionNoneAtomicRWShort = 非原子读写
SocTransactionNoRespons = 没有从设备对该请求作出响应，请检查请求的内存地址以及系统的内存映射
SocTransactionNoResponsShort = 无响应
SocTransactionNoSlavesAttached = 与主设备连接的总线上未挂接任何从设备，请在总线上添加从设备
SocTransactionNoSlavesAttachedShort = 无从设备
SocTransactionReadOnlyAccessError = 从设备在该地址上仅支持读访问
SocTransactionReadOnlyAccessErrorShort = 只读
SocTransactionRegisterDoesNotExist = 从设备在该地址上不支持任何访问
SocTransactionRegisterDoesNotExistShort = 无访问权限
SocTransactionSuccessfull = 未发生任何错误，事务执行成功
SocTransactionSuccessfullShort = 成功
SocTransactionUnknownError = 未知错误：该错误不应出现，可能由于 Logisim 的逻辑存在缺陷
SocTransactionUnknownErrorShort = 程序错误
SocTransactionWordAccesNoSupport = 从设备不支持字访问
SocTransactionWordAccesNoSupportShort = 不支持字访问
SocTransactionWriteOnlyAccessError = 从设备不支持在该地址上执行读操作
SocTransactionWriteOnlyAccessErrorShort = 只写
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = 空（无从设备）
SocMemMapEndAddress = 结束地址：
SocMemMapSlaveName = 组件名称：
SocMemMapStartAddress = 起始地址：
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = 请选择要连接的总线
SocBusSelectAttr = 连接总线
SocBusSelectAttrClick = 点击以选择
SocManagerNoBusses = 没有可用的总线，请在电路中添加一个 SoC 总线
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = 已成功将 ELF 文件加载到内存中\n可执行文件的入口点已设置到处理器\n\n重要说明：\n  由于 ELF 文件不包含异常向量的信息，您需要自行处理这些异常向量！
SocUpMenuAsmWindow = 打开汇编器
SocUpMenuCpuAsmWindowTitle = CPU 的汇编器：
SocUpMenuCpuProgramWindowTitle = CPU 的反汇编程序：
SocUpMenuCpuStateWindowTitle = CPU 的处理器状态：
SocUpMenuErrorReadingElfTitle = 读取 ELF 文件时出错
SocUpMenuReadElf = 读取 ELF 文件
SocUpMenuSelectElfFile = 选择要导入的 ELF 文件
SocUpMenuShowProgram = 显示已加载的程序
SocUpMenuShowState = 显示 CPU 状态
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = 已停止
SocUpSimHaltBreak = 断点
SocUpSimHaltError = 错误
SocUpSimRunning = 运行中
SocUpSimStateLabel = 仿真状态：
SocUpSimstateStart = 启动
SocUpSimstateStop = 暂停
SocUpUnknown = 未知
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = 不是 32 位或 64 位的 ELF 文件
ElfHeaderEIDataError = 不是采用小端或大端编码的文件
ElfHeaderIncorrectEISize = EI 段的大小不正确
ElfHeaderIncorrectESize = E 段的大小不正确
ElfHeaderIncorrectMagic = 文件不包含正确的 ELF 魔数；可能不是 ELF 文件
ElfHeaderNoErrors = 头部正确
ElfHeaderReadingFileError = 读取文件时出错
ElfHeaderUnknownArchitecture = 未知的处理器架构
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = 未找到程序头
ProgHeaderReadError = 读取程序头时出错
ProgHeaderSizeError = 程序头中的大小不匹配
ProgHeaderSuccess = 成功
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = 发现多个字符串表，当前版本暂不支持
ElfSectHeadMultiSymtabError = 发现多个符号表，当前版本暂不支持
ElfSectHeadNotFound = 未找到节头部
ElfSectHeadReadError = 读取节头部时出错
ElfSectHeadSizeError = 节头部的大小不匹配
ElfSectHeadStingIdxError = 字符串索引错误
ElfSectHeadStingNotFound = 未找到节名称
ElfSectHeadStingReadError = 读取字符串表时出错
ElfSectHeadStingTypeError = 字符串类型错误
ElfSectHeadSuccess = 成功
ElfSymTableNotFound = 找不到符号表
ElfSymTableReadError = 无法读取符号表
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim 目前尚不支持 64 位 ELF 文件
ProcReadElfArchError = 该 ELF 文件是为“%s”处理器生成的，但应选取为“%s”处理器生成的文件
ProcReadElfEndianMismatch = 端序不匹配，ELF 文件为“%s”，但处理器需要“%s”
ProcReadElfErrorOpeningFile = 无法打开 ELF 文件
ProcReadElfLoadableSectionNotFound = 在 ELF 文件中未找到可加载的节
ProcReadElfLoadableSectionReadError = 读取可加载节时出错
ProcReadElfLoadableSectionSizeError = 可加载段中的大小不匹配
ProcReadElfLoadableSectionTooBig = 可加载节的大小超过了 Logisim 所支持的大小
ProcReadElfMemoryError = 将可加载节写入内存时发生错误\n请确认在以下内存区域内存在可用的 SoC 内存组件：\n%s…%s
ProcReadElfNotExecutable = 该 ELF 文件不是可执行文件
ProcReadElfSuccess = 成功
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = 汇编文件（.asm, .S）
AsmPanAssemble = 汇编代码（Alt-A）
AsmPanDocumentChangedSave = 文件已发生更改，是否保存？
AsmPanErrorCreateFile = 无法创建汇编文件
AsmPanErrorReadingFile = 无法读取该件
AsmPanNextError = 跳转至下一个错误（Ctrl-N）
AsmPanOpenFile = 读取文件（Ctrl-L）
AsmPanPreviousError = 跳转到上一个错误（Ctrl-P）
AsmPanReadAsmFile = 选择要读取的文件
AsmPanRun = 运行代码（ALT-R）
AsmPanSaveAsmFile = 选择要保存的文件
AsmPanSaveFile = 保存文件（Ctrl-S）
AsmPanSaveFileAs = 另存为
AsmPanSaveFirstBeforeOpen = 文件中存在未保存的更改\n打开新文件前是否保存？
AssemblerAssembleSuccess = 成功！\n代码中未发现任何错误
AssemblerRunSuccess = 已成功将程序加载到内存中\n要运行该程序，请确保：\n- 已启用时钟脉冲\n- 已将 CPU 设置为运行模式
AssemblerUnableToDownload = 无法将程序存储到内存中\n请确认在正确的内存地址处有足够的可用内存
RV32imAsmLineIndicator = 第 %d 行，共 %d 行
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = 删除断点
RV32imSetBreakpoint = 添加断点
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = 总线地址：0x
SocTransInsAtomicRequest = 原子事务
SocTransInsByteAccess = 字节事务
SocTransInsHalfWordAccess = 半字事务（2 字节）
SocTransInsInputData = 写入数据：0x
SocTransInsInsertTransaction = 将事务插入到总线中
SocTransInsManual = 手动插入
SocTransInsReadData = 返回的数据：
SocTransInsReadRequest = 总线读请求
SocTransInsTransResultTitle = 已插入事务的结果：
SocTransInsWordAccess = 字事务（4 字节）
SocTransInsWriteRequest = 总线写请求
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = 汇编指令：
Rv32imBinInstruction = 操作码：
Rv32imEmptyTrace = 无可用的执行踪迹
Rv32imExecutionTrace = 执行踪迹（最近执行的在最上方）：
Rv32imRegisterFile = 寄存器堆：
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = 仿真控制
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = 输出：清除键盘缓冲（为 1 时请求键盘清空其内部缓冲）
JtagUartKeybAvailable = 输入：键盘数据可用指示（为 1 表示当前有字符可供读取）
JtagUartKeybData = 输入：键盘输入数据（7 比特 ASCII 字符）
JtagUartKeybReadEnable = 输出：键盘读取使能（为 1 表示本周期读取一个键盘字符）
JtagUartTtyClear = 输出：清除 TTY 显示（为 1 时请求清空终端内容）
JtagUartTtyData = 输出：TTY 输出数据（7 比特 ASCII 字符）
JtagUartTtyWrite = 输出：TTY 写使能（为 1 表示 DATA_OUT 在本周期有效）
# ==> SocJtagUartComponent =
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = 读 IRQ 阈值
JtagUartWriteIrqThreshold = 写 IRQ 阈值
UartJtagREADFifoSize = 读 FIFO 大小
UartJtagWriteFifoSize = 写 FIFO 大小
#
# memory/SocMemory.java
#
SocMemBase = 基地址：
SocMemoryComponent = 内存仿真器
SocMemSizeStr = 容量：
#
# memory/SocMemoryAttributes.java
#
SocMemSize = 地址宽度（以字节计）：
SocMemStartAddress = 起始地址：
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Nios2S 仿真器
Nios2Dataa = 数据 A
Nios2Datab = 数据 B
Nios2Done = 完成
Nios2N = N
Nios2ReadRa = 读取 Ra
Nios2ReadRb = 读取 Rb
Nios2Result = 结果
Nios2Start = 开始
Nios2WriteRc = 写入 Rc
Rv32imClockInput = 输入：时钟
Rv32imIrqInput = 输入：IRQ %s
Rv32imResetInput = 输入：复位
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = 中断向量
rv32ExceptionVector = 异常向量
rv32imIrqWidth = IRQ 线路数量
rv32ResetVector = 复位向量
rv32StateVisible = 状态可见
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = 需要四个参数
Nios2DonePinError = 完成（done）引脚未定义或处于错误状态，无法继续\n请检查完成引脚
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = 从内存系统执行加载操作时出错：
LoadStoreErrorInWriteTransaction = 向内存系统执行存储操作时出错：
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = 应为一个立即数
AssemblerExpectedNoArguments = 不需要参数
AssemblerExpectedOneArgument = 需要一个参数
AssemblerExpectedTwoArguments = 需要两个参数
AssemblerExpectedZeroOrOneArgument = 需要零个或一个参数
AssemblerImmediateOutOfRange = 立即数超出范围
AssemblerUnknownRegister = 未知寄存器
Nios2AssemblerExpectedBracketedRegister = 应为带括号的寄存器，例如 (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = 应为立即数索引寄存器，例如 5(r1)
Nios2CannotUseControlRegister = 无法在此上下文中使用控制寄存器
Nios2CannotUseCustomRegister = 无法在此上下文中使用自定义寄存器
Nios2ExpectedControlRegister = 应为一个控制寄存器，例如 ctl4
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = 需要三个参数
AssemblerExpextedImmediateOrLabel = 应为立即数或标签
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = status
RV32imBreakPointReached = 由于在当前指令处设置了断点，执行已暂停
RV32imFetchExecutionError = 执行取指指令时发生错误
RV32imFetchInvalidInstruction = 取到的指令无效
RV32imFetchInvInstrAsm = 无效指令！
RV32imFetchTransaction = -> 取指事务错误
Rv32imProgramCounter = PC：
SocHiddenForFasterSimulation = 为加快仿真速度，内容已隐藏
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = 应为寄存器
#
# pio/PioAttributes.java
#
SicPioIrqType = IRQ 类型
SocPioAnyEdge = 任意边沿
SocPioBidir = 双向（三态）端口
SocPioCaptureEdge = 捕获类型
SocPioDirection = 方向
SocPioFallingEdge = 下降沿
SocPioGenIRQ = 启用 IRQ
SocPioInout = 输入和输出
SocPioInputCaptureBit = 捕获寄存器按位清除
SocPioInputOnly = 仅输入
SocPioInputsSyncCapture = 同步捕获
SocPioIrQEdge = 边沿
SocPioIrqLevel = 电平
SocPioOutputIndividualBits = 输出寄存器按位置位/清除
SocPioOutputOnly = 仅输出
SocPioOutputResetValue = 输出复位值
SocPioRisingEdge = 上升沿
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = 无法创建头文件或 C 文件！
ExportC = 导出 C 模板
PioMenuBidirFunctionsRemark = /* 使用以下函数可以设置或读取双向寄存器\n * 数值 1 表示对应位为输出，0 表示为输入\n * 注意：仅使用低 %s 位\n */
PioMenuCaptureAll = 清除捕获寄存器中的所有位，与参数“value”的值无关
PioMenuCaptureAny = 至少一次从 0 到 1 或从 1 到 0 的变化
PioMenuCaptureBit = 清除捕获寄存器中在参数“value”中为 1 的那些位
PioMenuCaptureFalling = 至少一次从 1 到 0 的变化
PioMenuCaptureRising = 至少一次从 0 到 1 的变化
PioMenuEdgeCaptureRemark = /* 使用以下函数可以清除或读取边沿捕获寄存器\n * 当读取边沿寄存器时，某一位为 1 表示对应的输入发生了%s，\n * 否则表示对应输入未发生变化\n *\n * 向该寄存器写入将会 %s\n * 注意：仅使用低 %s 位\n */
PioMenuInputDataFunctionRemark = /* 使用以下函数可以读取 PIO 的输入值\n * 该函数返回相应的数值\n * 注意：仅低 %s 位有效\n */
PioMenuIrqEdge = 捕获寄存器中的对应位
PioMenuIrqLevel = 对应的输入
PioMenuMaskFunctionsRemark = /* 使用以下函数可以设置或读取中断屏蔽寄存器\n * 某一位为 1 表示当%s等于 1 时将产生中断\n * 注意：仅使用低 %s 位\n */
PioMenuOutClearRemark = /* 使用以下函数，参数“value”中为 1 的位将强制对应的输出为 0\n * 注意：仅使用低 %s 位\n */
PioMenuOutputDataFunctionRemark = /* 使用以下函数可以设置 PIO 的输出值\n * 该函数以新的输出值作为参数“value”\n * 注意：所提供参数“value”中仅低 %s 位有效\n */
PioMenuOutSetRemark = /* 使用以下函数，参数“value”中为 1 的位将强制对应的输出为 1\n * 注意：仅使用低 %s 位\n */
SelectDirectoryToStoreC = 设置用于存放 C 模板的目录
SuccesCreatingHeaderAndCFile = 已成功创建以下文件：\n%s\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = 双向：位 %s
SocPioBidirs = 双向端口
SocPioComponent = 并行输入/输出扩展器
SocPioInputPinx = 输入：位 %s
SocPioInputs = 输入端口
SocPioIrqOutput = 输出：IRQ
SocPioOutputPinx = 输出：位 %s
SocPioOutputs = 输出端口
SocPioResetInput = 输入：复位
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = RISC-V IM 仿真器
Rv32PlicBaseAddress = PLIC 基址
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = 需要一个或两个参数
Rv32imAssemblerExpectedTwoOrThreeArguments = 需要两个或三个参数
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = 当前尚未实现环境调用和断点功能
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = Bug！
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = 应为带括号的寄存器，例如 (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = 应为立即数索引寄存器，例如 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = 尚不支持的汇编操作码
Rv32imMOINotImplmented = 当前尚未实现内存排序指令
#
# Soc.java
#
SocBusComponent = SoC 总线仿真器
socLibrary = 片上系统
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = 未知操作码
UnknownInstruction = 未知指令
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = 假定最低地址处的指令为入口点\n为确保 CPU 从正确的地址开始执行，\n请在希望 CPU 开始执行程序的位置\n添加一个名为“_start”的标签
AssemblerCannotUseInsideMacro = 该结构不能在宏定义中使用
AssemblerEndOfMacroNotFound = 未找到宏定义的结束位置
AssemblerExpectedMacroName = 需要宏名称
AssemblerExpectedMacroNrOfParameters = 需要指定宏参数的数量
AssemblerExpectingLabelIdentifier = 需要标签
AssemblerMissingLabelBefore = 该操作符前应有一个标签
AssemblerNoExecutableSection = 未找到可执行的指令
AssemblerReguiresNumberAfterMath = 数学运算后应跟随一个数值
AssemblerUnknowCharacter = 未知字符
AssemblerWrongClosingBracket = 不支持该右括号
AssemblerWrongOpeningBracket = 不支持该左括号
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = 无法确定该标签的地址
AssemblerCouldNotFindValueForDefine = 找不到该参数的定义
AssemblerDivZero = 除以零错误
AssemblerExpectedImmediateValueAfterMath = 数学运算后应为一个立即数
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = 标签名必须唯一，发现该标签被多次定义
AssemblerDuplicatedName = .equ 与标签不能使用相同的名称
AssemblerDuplicatedSectionError = 节名必须唯一，发现多个同名节
AssemblerExpectedLabel = 应为标签
AssemblerExpectedLabelAndNumber = 应为标签和立即数
AssemblerExpectedParameter = 此处应为参数
AssemblerExpectingNumber = 应为数字
AssemblerExpectingPositiveNumber = 应为正数
AssemblerExpectingSectionName = 需要为该节指定一个名称
AssemblerExpectingString = 应为字符串
AssemblerMacroIncorrectNumberOfParameters = 指定的宏参数数量不正确
AssemblerOverlappingSections = 该段与另一个段发生重叠
AssemblerUnknownIdentifier = 未知标识符
AssemblerUnknownLabel = 该标签尚未定义，无法使用
AssemblerUnsupportedAssemblerInstruction = 不支持的汇编指令
AssemblerValueOutOfRange = 数值超出范围
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = 宏相互调用导致死锁
AssemblerMacroCannotUseRecurency = 宏递归调用自身导致死锁
AssemblerMacroParameterNotDefined = 该宏参数未定义，请检查宏定义中的参数数量
#
# vga/SocVgaShape.java
#
SocVgaComponent = VGA 屏幕
#
# vga/VgaAttributes.java
#
VgaBufferAddress = 像素缓冲区地址
VgaInitialDisplayMode = 初始显示模式
VgaSoftMode = 软件支持 %s
VgaStartAddress = 基地址
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* 使用以下函数可以配置 VGA 显示模式\n * 读取 VGA 模式将返回所支持的显示模式（参见上方定义的可用模式）\n * 写入一个受支持的模式将改变 VGA 显示器的显示模式\n */
