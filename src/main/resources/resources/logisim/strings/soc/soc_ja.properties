#
# bus/SocBusAttributes.java
#
SocBusTraceSize = トレースのサイズ:
SocBusTraceVisible = トレースが表示されます:
#
# bus/SocBusMenuProvider.java
#
insertTrans = バストランザクションを挿入する
SocBusMemMap = メモリマップを表示
SocBusTraceWindow = バストランザクションのトレースを表示する
SocInsertTransWindowTitle = バスにトランザクションを挿入します。
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = バストレースウィンドウ(トレースをダブルクリックして削除する)
#
# data/SocBusInfo.java
#
SocBusNotConnected = バスに接続されていません。
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = 痕跡がありません:
SocMemMapWindowTitle = バスのメモリマップ:
SocMemoryMapOk = 閉じる
SocMemoryMapTitle = メモリマップ（赤はメモリ領域の重複を示す）:
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Initiator:
SocBusStateNoDataMax10chars = データなし
SocBusStateSlave = レスポンダ:
SocBusStateTraceIndex = トランザクション番号:
SocTransactionByteAccesNoSupport = スレーブはバイトアクセスをサポートしていません。
SocTransactionByteAccesNoSupportShort = バイトアクセスをサポートしていません。
SocTransactionHalfWordAccesNoSupport = スレーブがハーフワードアクセスをサポートしていません。
SocTransactionHalfWordAccesNoSupportShort = HWアクセスがありません。
SocTransactionMisalignedAddress = スレーブがアドレスの位置ずれを検出しました。
SocTransactionMisalignedAddressShort = Misal. Addr.
SocTransactionMultipleSlaveAnswers = 複数のスレーブがトランザクションに回答しました。スレーブのメモリマップを確認してください。
SocTransactionMultipleSlaveAnswersShort = 複数のスレーブがトランザクションに回答しました。
SocTransactionNoBusConnected = マスターコンポーネントがどのSocバスにも接続されていません。マスターをバス・コンポーネントに接続してください。
SocTransactionNoBusConnectedShort = バスがありません。
SocTransactionNoneAtomicRW = アトミックな読み書き動作が要求されていません。これは許可されていません。
SocTransactionNoneAtomicRWShort = ノーアトミックRW
SocTransactionNoRespons = リクエストに応答したスレーブコンポーネントがありません。リクエストのメモリアドレスとシステムのメモリマップを確認してください。
SocTransactionNoResponsShort = 応答がありません。
SocTransactionNoSlavesAttached = マスターに接続されているバスにはスレーブが接続されていません。バスにいくつかのスレーブを取り付けてください。
SocTransactionNoSlavesAttachedShort = スレーブがありません。
SocTransactionReadOnlyAccessError = スレーブはこのアドレスの読み取りアクセスのみをサポートしています。
SocTransactionReadOnlyAccessErrorShort = 読み取り専用
SocTransactionRegisterDoesNotExist = スレーブはこのアドレスへのアクセスをサポートしていません。
SocTransactionRegisterDoesNotExistShort = アクセスできません。
SocTransactionSuccessfull = エラーが発生していません。
SocTransactionSuccessfullShort = 成功
SocTransactionUnknownError = 奇妙なことに、このエラーメッセージは決して発生しないはずで、logisim のバグを表しています。
SocTransactionUnknownErrorShort = バグ!
SocTransactionWordAccesNoSupport = スレーブはワードアクセスをサポートしていません。
SocTransactionWordAccesNoSupportShort = ワードアクセスがありません。
SocTransactionWriteOnlyAccessError = スレーブはこのアドレスの読み取りアクションをサポートしていません。
SocTransactionWriteOnlyAccessErrorShort = 書き込み専用です。
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = 空 (スレーブなし)
SocMemMapEndAddress = エンドアドレス:
SocMemMapSlaveName = コンポーネントの名前:
SocMemMapStartAddress = 開始アドレス:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = 接続するバスを選択してください。
SocBusSelectAttr = 接続バス
SocBusSelectAttrClick = クリックして選択します。
SocManagerNoBusses = 利用可能なバスがありません。
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = ELF ファイルのメモリへのロードに成功しました。\n実行ファイルのエントリポイントがプロセッサに設定されています。\n\n重要:\n   エルフファイルには例外ベクトルに関する情報がありません。\n   そのため自分で制御する必要があります
SocUpMenuAsmWindow = オープンアセンブラ
SocUpMenuCpuAsmWindowTitle = cpu用アセンブラ:
SocUpMenuCpuProgramWindowTitle = cpu用ディスアセンブラ:
SocUpMenuCpuStateWindowTitle = CPUのプロセッサの状態:
SocUpMenuErrorReadingElfTitle = ELFファイルの読み込み中にエラーが発生しました。
SocUpMenuReadElf = ELFファイルの読み込み
SocUpMenuSelectElfFile = インポートするELFファイルの選択
SocUpMenuShowProgram = 読み込まれたプログラムを表示する
SocUpMenuShowState = CPUの状態を表示する
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = 停止
SocUpSimHaltBreak = ブレークポイント
SocUpSimHaltError = エラー
SocUpSimRunning = 実行中
SocUpSimStateLabel = シミュレーション状態:
SocUpSimstateStart = 開始
SocUpSimstateStop = 一時停止
SocUpUnknown = 不明
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = 32 ビットまたは 64 ビットのELFファイルではありません。
ElfHeaderEIDataError = リトルエンディアンまたはビッグエンディアンでエンコードされたファイルではありません。
ElfHeaderIncorrectEISize = EIセクションのサイズが正しくありません。
ElfHeaderIncorrectESize = E-sectionのサイズが正しくありません。
ElfHeaderIncorrectMagic = ファイルには正しいエルフマジックが含まれていません。
ElfHeaderNoErrors = ヘッダーは正常です
ElfHeaderReadingFileError = ファイルの読み取りエラー
ElfHeaderUnknownArchitecture = 不明なアーキテクチャ
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = プログラム・ヘッダが見つかりません。
ProgHeaderReadError = プログラム・ヘッダの読み取りエラー。
ProgHeaderSizeError = プログラム・ヘッダのサイズの不一致。
ProgHeaderSuccess = 成功
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = 複数の文字列テーブルが見つかりました。
ElfSectHeadMultiSymtabError = 複数のシンボル・テーブルが見つかりました。
ElfSectHeadNotFound = セクション・ヘッダが見つかりませんでした。
ElfSectHeadReadError = セクション・ヘッダーの読み取りエラー。
ElfSectHeadSizeError = セクション・ヘッダのサイズの不一致。
ElfSectHeadStingIdxError = 文字列インデックスのエラー。
ElfSectHeadStingNotFound = セクション名が見つかりません。
ElfSectHeadStingReadError = 文字列テーブルの読み取りエラー。
ElfSectHeadStingTypeError = 文字列型エラー。
ElfSectHeadSuccess = 成功。
ElfSymTableNotFound = シンボル・テーブルが見つかりませんでした。
ElfSymTableReadError = シンボルテーブルを読み込めませんでした。
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisimは64ビットのELFファイルをまだサポートしていません。
ProcReadElfArchError = ELF ファイルは \“%s” プロセッサ用ですが、 \“%s” プロセッサ用であるはずです。
ProcReadElfEndianMismatch = エンディアン不一致、ELFファイルは\“%s ”ですが、プロセッサは“\”%s "を要求しました。
ProcReadElfErrorOpeningFile = ELFファイルを開くことができませんでした。
ProcReadElfLoadableSectionNotFound = ELFファイルにロード可能なセクションが見つかりません。
ProcReadElfLoadableSectionReadError = ロード可能なセクションの読み取りエラー。
ProcReadElfLoadableSectionSizeError = ロード可能なセクションのサイズの不一致。
ProcReadElfLoadableSectionTooBig = ロード可能なセクションのサイズがlogisimがサポートしているサイズよりも大きいです。
ProcReadElfMemoryError = ロード可能なセクションをメモリに書き込む際にエラーが発生しました。
ProcReadElfNotExecutable = ELFファイルは実行可能ではありません。
ProcReadElfSuccess = 成功
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = アセンブリファイル (.asm, .S)
AsmPanAssemble = コードをアセンブルする (ALT-A)
AsmPanDocumentChangedSave = ドキュメントに変更がありますが、保存しますか？
AsmPanErrorCreateFile = アセンブリファイルを作成できません。
AsmPanErrorReadingFile = ファイルを読み込むことができません。
AsmPanNextError = 次のエラーにジャンプ (CTRL-N)
AsmPanOpenFile = ファイルの読み込み (CTRL-L)
AsmPanPreviousError = 前のエラーにジャンプ (CTRL-P)
AsmPanReadAsmFile = 読み取るファイルの選択
AsmPanRun = コードの実行 (ALT-R)
AsmPanSaveAsmFile = 保存するファイルの選択
AsmPanSaveFile = ファイルの保存 (CTRL-S)
AsmPanSaveFileAs = ファイルを名前を付けて保存する
# ==> AsmPanSaveFirstBeforeOpen =
AssemblerAssembleSuccess = Success!\nNo errors found in your code.
AssemblerRunSuccess = Successfully loaded the program to memory.\nTo run the program, please make sure that:\na) you enable the ticks\nb) you set the cpu to running mode
AssemblerUnableToDownload = Unable to store the program to memory,\nplease make sure that you have enough memory available\nat the correct memory locations.
RV32imAsmLineIndicator = Line %d of %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = ブレークポイントの削除
RV32imSetBreakpoint = ブレークポイントの追加
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = バス・アドレス: 0x
SocTransInsAtomicRequest = アトミックトランザクション
SocTransInsByteAccess = バイトトランザクション
SocTransInsHalfWordAccess = ハーフワード・トランザクション(2バイト)
SocTransInsInputData = 書き込むデータ:0x
SocTransInsInsertTransaction = バスにトランザクションを挿入します
SocTransInsManual = 手動挿入
SocTransInsReadData = 返されたデータ
SocTransInsReadRequest = バス読み取り要求
SocTransInsTransResultTitle = 挿入されたトランザクションの結果。
SocTransInsWordAccess = ワード・トランザクション(4バイト)
SocTransInsWriteRequest = バス書き込み要求
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = アセンブリ:
Rv32imBinInstruction = オペコード:
Rv32imEmptyTrace = 実行トレースは利用できません
Rv32imExecutionTrace = 実行トレース(上で最後に実行されたもの):
Rv32imRegisterFile = レジスタファイル:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = シミュレーション制御
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = キーボードのクリア
JtagUartKeybAvailable = 利用可能なキーボードデータ
JtagUartKeybData = キーボードデータ
JtagUartKeybReadEnable = キーボードの読み取りを有効にする。
JtagUartTtyClear = TTYクリア
JtagUartTtyData = TTYデータ
JtagUartTtyWrite = TTY書き込みデータ
SocJtagUartComponent = JTAG UART
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = 読み取りIRQしきい値
JtagUartWriteIrqThreshold = IRQしきい値を書き込む
UartJtagREADFifoSize = 読み出しFIFOサイズ:
UartJtagWriteFifoSize = 書き込みFIFOサイズ:
#
# memory/SocMemory.java
#
SocMemBase = ベース:
SocMemoryComponent = メモリシミュレータ
SocMemSizeStr = サイズ:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = バイトアドレスの幅:
SocMemStartAddress = 開始アドレス:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Nios2sシミュレータ
Nios2Dataa = データ A
Nios2Datab = データ B
Nios2Done = 完了
Nios2N = N
Nios2ReadRa = Raを読み込む
Nios2ReadRb = Rbを読み込む
Nios2Result = 結果
Nios2Start = 開始
Nios2WriteRc = Rcを書き込む
Rv32imClockInput = クロック入力
Rv32imIrqInput = IRQ 入力 %s
Rv32imResetInput = リセット入力
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = ブレークベクタ
rv32ExceptionVector = 例外ベクタ
rv32imIrqWidth = IRQライン数
rv32ResetVector = リセットベクタ
rv32StateVisible = 表示可能な状態:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = 期待される4つの引数
Nios2DonePinError = Doneピンが定義されていないか、エラー状態で続行できません。\n完了ピンを確認してください。
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = メモリシステムからのロードの実行中にエラーが発生しました:
LoadStoreErrorInWriteTransaction = メモリシステムへの保存を実行しているエラー:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = 即値を期待しています
AssemblerExpectedNoArguments = 引数を期待していません
AssemblerExpectedOneArgument = 1つの引数を期待しています
AssemblerExpectedTwoArguments = 2つの引数を期待しています
AssemblerExpectedZeroOrOneArgument = 引数がないか、1つを期待しています
AssemblerImmediateOutOfRange = 即値が範囲外です。
AssemblerUnknownRegister = 不明なレジスタ
Nios2AssemblerExpectedBracketedRegister = 括弧で囲まれたレジスタを期待しています。 例（r1）
Nios2AssemblerExpectedImmediateIndexedRegister = 即時インデックス付きレジスタを期待しています例5(r1)
Nios2CannotUseControlRegister = このコンテキストでは制御レジスタを使用できません。
Nios2CannotUseCustomRegister = このコンテキストではカスタム・レジスタを使用できません。
Nios2ExpectedControlRegister = 制御レジスタ（例：ctl4）を期待しています。
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = 期待される3つの引数
AssemblerExpextedImmediateOrLabel = 即値またはラベルを期待しています。
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = status
RV32imBreakPointReached = 現在の命令にブレークポイントが設定されているため、実行が一時停止しています。
RV32imFetchExecutionError = フェッチされた命令の実行中にエラーが発生しました。
RV32imFetchInvalidInstruction = 無効な命令をフェッチしました。
RV32imFetchInvInstrAsm = 無効な命令です。
RV32imFetchTransaction = -> フェッチ・トランザクション・エラーです。
Rv32imProgramCounter = pc:
SocHiddenForFasterSimulation = 高速シミュレーションのために隠された内容
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = レジスタを期待しています。
#
# pio/PioAttributes.java
#
SicPioIrqType = Irqタイプ:
SocPioAnyEdge = 任意のエッジ
SocPioBidir = 双方向（三元）ポート
SocPioCaptureEdge = キャプチャタイプ:
SocPioDirection = 方向:
SocPioFallingEdge = Falling edge
SocPioGenIRQ = IRQ が有効です:
SocPioInout = 入力と出力の両方のポート
SocPioInputCaptureBit = キャプチャビットクリア:
SocPioInputOnly = 入力ポートのみ
SocPioInputsSyncCapture = 同期. キャプチャ:
SocPioIrQEdge = エッジ
SocPioIrqLevel = レベル
SocPioOutputIndividualBits = 出力ビットのセット/クリア:
SocPioOutputOnly = 出力ポートのみ
SocPioOutputResetValue = 出力リセット値:
SocPioRisingEdge = Rising edge
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = ヘッダおよび/または c ファイルを作成できませんでした!
ExportC = C テンプレートをエクスポートします。
PioMenuBidirFunctionsRemark = /* 以下の機能により、双方向レジスタの設定及び読み出しが可能です。\n *1 はrespect. bitが出力であることを示し、0 は入力であることを示す。,\n *a 0 は input を示す。\n *注：下位％sビットのみが使用されます。\n */
PioMenuCaptureAll = パラメータ “value”の値とは独立してキャプチャレジスタ内のすべてのビットをクリアする
PioMenuCaptureAny = 0から1または1から0への少なくとも1つの変化
PioMenuCaptureBit = パラメータ “value”で1になっているキャプチャレジスタのビットをクリアします。
PioMenuCaptureFalling = 1から0までの少なくとも1つの変化
PioMenuCaptureRising = 0から1までの少なくとも1つの変化
PioMenuEdgeCaptureRemark = /* 以下の関数を使用して、エッジキャプチャレジスタをクリア又は読み出しが可能です。\n *エッジレジスタが読み出された場合、位置に１があると、それぞれの入力が %s になっていることを示します。,\n * そうでない場合は、それぞれの入力は変更されません。\n * このレジスタへの書き込みは %s になります。\n * 注：下位％sビットのみが使用されます。\n */
PioMenuInputDataFunctionRemark = /* 以下の関数を使用すると、PIO の入力値を\n * 読み出すことができます。\n * この関数は、それぞれの値を返します。\n * 注意:下位の %s ビットのみが有効です。\n */
PioMenuIrqEdge = キャプチャレジスタの対応するビット
PioMenuIrqLevel = 対応する入力
PioMenuMaskFunctionsRemark = /* 以下の機能により、割り込みマスクレジスタの設定及び読み出しが可能です。\n * 特定の場所の 1 は、%s が 1 になると割り込みが発生することを示します。\n * %sが1に等しい場合.\n * 注：下位％sビットのみが使用されます。\n */
PioMenuOutClearRemark = /* 以下の関数では、パラメータ “value ”に1が含まれているビットは、強制的に\n * 対応する出力を 0 に設定します。\n * 注：下位％sビットのみが使用されます。\n */
PioMenuOutputDataFunctionRemark = /* 以下の機能により、PIO の出力値を以下のように変更することができます。\n * セットする.\n * この関数は、新しい出力値をパラメータ “value”として受け取ります。\n * 注意: 指定されたパラメータ “value” の下位 %s ビットのみが有効です。\n */
PioMenuOutSetRemark = /* 以下の関数では、パラメータ “value ”に1が含まれているビットは、強制的に\n * 対応する出力を1に設定します。\n * 注：下位％sビットのみが使用されます。n */
SelectDirectoryToStoreC = C-templatesを格納するディレクトリを設定します。
SuccesCreatingHeaderAndCFile = ファイルの作成に成功しました。:\n%s\n　と\n　%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir ビット %s
SocPioBidirs = 双方向ピン
SocPioComponent = パラレル 入力/出力　拡張期
SocPioInputPinx = 入力ビット %s
SocPioInputs = 入力ピン
SocPioIrqOutput = Irq出力
SocPioOutputPinx = 出力ビット %s
SocPioOutputs = 出力端子
SocPioResetInput = リセット入力
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Risc V IMシミュレータ
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = 期待される1つまたは2つの引数
Rv32imAssemblerExpectedTwoOrThreeArguments = 2つまたは3つの引数を期待しています
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = 現在、環境コールとブレークポイントは実装されていません
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = (x1)のような括弧付きレジスタを期待します。
RV32imAssemblerExpectedImmediateIndexedRegister = 5(x1)のような即値インデックスレジスタを期待しています。
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = asm opcodeはサポートされていません。
Rv32imMOINotImplmented = 現在、メモリ順序付け命令は実装されていません。
#
# Soc.java
#
SocBusComponent = SoCバスシミュレータ
socLibrary = システム・オン・チップ・コンポーネント
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = 不明なオペコード
UnknownInstruction = 不明な命令
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = 一番下のアドレスをエントリーポイントとした命令を想定しています。\n正しいアドレスで実行を開始するように、「_start」というラベルをプログラムの実行を開始する場所に追加してください。
AssemblerCannotUseInsideMacro = この構文は、マクロ定義内では使用できません。
AssemblerEndOfMacroNotFound = マクロ定義の最後が見つかりませんでした。
AssemblerExpectedMacroName = マクロの名前を期待しています。
AssemblerExpectedMacroNrOfParameters = マクロパラメータの数を期待しています。
AssemblerExpectingLabelIdentifier = ラベルを期待する
AssemblerMissingLabelBefore = この演算子のためにラベルでなければなりません。
AssemblerNoExecutableSection = 実行可能な命令が見つかりません。
AssemblerReguiresNumberAfterMath = 算術演算の後に数字が続くようにします。
AssemblerUnknowCharacter = 不明な文字
AssemblerWrongClosingBracket = このクロージング・ブラケットはサポートされていません。
AssemblerWrongOpeningBracket = このオープニング・ブラケットはサポートされていません。
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = このラベルのアドレスを決定できませんでした。
AssemblerCouldNotFindValueForDefine = このパラメータの定義が見つかりませんでした。
AssemblerDivZero = ゼロ除算によるエラー
AssemblerExpectedImmediateValueAfterMath = 算術演算後の即値を期待します。
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = ラベル名は一意でなければなりません。
AssemblerDuplicatedName = .equとラベルに同じ名前を使用できません。
AssemblerDuplicatedSectionError = セクション名は一意でなければなりません。
AssemblerExpectedLabel = ラベルを期待しています。
AssemblerExpectedLabelAndNumber = ラベルの後に即値が続くことを期待しています。
AssemblerExpectedParameter = この位置で期待されるパラメータ
AssemblerExpectingNumber = 期待される数
AssemblerExpectingPositiveNumber = 正の数を期待しています。
AssemblerExpectingSectionName = このセクションの名前を期待しています。
AssemblerExpectingString = 期待される文字列
AssemblerMacroIncorrectNumberOfParameters = 指定されたマクロ・パラメータの数が正しくありません。
AssemblerOverlappingSections = このセクションは別のセクションと重なっています
AssemblerUnknownIdentifier = この識別子を知りません
AssemblerUnknownLabel = このラベルは定義されていないので、使用できません。
AssemblerUnsupportedAssemblerInstruction = このアセンブラ命令は知られていません。
AssemblerValueOutOfRange = 値が範囲外です
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = マクロがお互いに呼び出してデッドロック状況を引き起こしています。
AssemblerMacroCannotUseRecurency = マクロが自分自身を呼び出しているため、デッドロック状況が発生しています。
AssemblerMacroParameterNotDefined = このマクロ・パラメータは定義されていません。
#
# vga/SocVgaShape.java
#
SocVgaComponent = VGAスクリーン
#
# vga/VgaAttributes.java
#
VgaBufferAddress = ピクセルバッファのアドレス:
VgaInitialDisplayMode = 初期モード:
# ==> VgaSoftMode =
VgaStartAddress = ベースアドレス:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* 以下の機能を使用して、VGA モードを操作することができます。\n * vga mode の読み出しは、サポートされているモードを返します（上記の定義を参照）\n * サポートされているモードを書き込むと、VGA ディスプレイの表示モードが変わります。\n */
