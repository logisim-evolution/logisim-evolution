#
# Reviewed MOR: 2021-07-05 (WiP)
#
#
# bus/SocBusAttributes.java
#
# SocBusTraceSize = Trace size:
SocBusTraceSize = Rozmiar śladu:
# SocBusTraceVisible = Traces visible:
SocBusTraceVisible = Ślady widoczne:
#
# bus/SocBusMenuProvider.java
#
# insertTrans = Insert a bus transaction
insertTrans = Włóż transakcję szyny
SocBusMemMap = Pokaż mapę pamięci
SocBusTraceWindow = Pokaż ślady transakcji szyny
SocInsertTransWindowTitle = Wkładanie transakcję do szyny
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Okno śledzenia szyny (dwukrotnie kliknij na ślad, aby go usunąć)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Niepodłączony do szyny
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Brak śladów
SocMemMapWindowTitle = Mapa pamięci dla szyny:
SocMemoryMapOk = Zamknij
# SocMemoryMapTitle = Me mory Map (red indicates overlapping memory regions):
SocMemoryMapTitle = Mapa pamięci (kolor czerwony oznacza nakładające się na siebie regiony pamięci):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Inicjujący:
SocBusStateNoDataMax10chars = brak danych
SocBusStateSlave = Responder:
SocBusStateTraceIndex = Transakcja nr:
SocTransactionByteAccesNoSupport = Slave nie obsługuje dostępu do bajtów.
SocTransactionByteAccesNoSupportShort = Brak dostępu do bajtów
SocTransactionHalfWordAccesNoSupport = Slave nie obsługuje dostępu do pół-słów.
SocTransactionHalfWordAccesNoSupportShort = Brak dostępu do sprzętu.
SocTransactionMisalignedAddress = Slave wykrył źle wyrównany adres.
SocTransactionMisalignedAddressShort = Źle wyrównany adres.
SocTransactionMultipleSlaveAnswers = Wiele Slave odpowiedziało na transakcję. Proszę sprawdzić mapę pamięci swoich elementów Slave.
SocTransactionMultipleSlaveAnswersShort = Wiele Slave.
SocTransactionNoBusConnected = Komponent Master nie jest podłączony do żadnej szynt SoC. Proszę podłączyć urządzenie Master do szyny.
SocTransactionNoBusConnectedShort = Brak szyny
SocTransactionNoneAtomicRW = Nie żadano żadnej nieatomowej operacji odczytu/zapisu. Nie jest to dozwolone.
SocTransactionNoneAtomicRWShort = Nieatomowy zapisz/odczyt
SocTransactionNoRespons = Żaden element Slave nie odpowiedział na zapytanie. Proszę sprawdzić adres pamięci żądania i mapę pamięci systemu.
SocTransactionNoResponsShort = Brak odpowiedzi.
SocTransactionNoSlavesAttached = Szyna podłączona do Mastera nie ma podłączonego żadnego Slave.
SocTransactionNoSlavesAttachedShort = Brak Slaves
SocTransactionReadOnlyAccessError = Slave obsługuje tylko dostęp do odczytu pod tym adresem
SocTransactionReadOnlyAccessErrorShort = Tylko do odczytu
SocTransactionRegisterDoesNotExist = Slave nie obsługuje żadnego dostępu pod tym adresem
SocTransactionRegisterDoesNotExistShort = Brak dostępu
SocTransactionSuccessfull = Nie wystąpił żaden błąd, transakcja jest udana.
SocTransactionSuccessfullShort = Success
SocTransactionUnknownError = Ten komunikat o błędzie nie powinien nigdy się pojawić i wskazuje na błąd w Logisim-evolution.
SocTransactionUnknownErrorShort = BŁĄD!
# SocTransactionWordAccesNoSupport = Slave does not support word accesses.
SocTransactionWordAccesNoSupport = Slave nie obsługuje dostępu do słów.
# SocTransactionWordAccesNoSupportShort = No word access
SocTransactionWordAccesNoSupportShort = Brak dostępu do słów.
SocTransactionWriteOnlyAccessError = Slave nie obsługuje akcji odczytu na tym adresie.
SocTransactionWriteOnlyAccessErrorShort = Tylko do zapisu
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Pusty (brak Slave)
SocMemMapEndAddress = Adres końcowy:
SocMemMapSlaveName = Nazwa komponentu:
SocMemMapStartAddress = Adres początkowy:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Wybierz szynę do której chcesz się podłączyć
SocBusSelectAttr = Podłączona szyna
SocBusSelectAttrClick = Kliknij, aby wybrać
SocManagerNoBusses = Brak dostępnych szyn, proszę dodaj szynę SoC do schematu.
#
# data/SocUpMenuProvider.java
#
# ProcReadElfLoadedAndEntrySet = Successfully loaded the elf file into memory.\nThe entry point of the executable has been set to the processor.\n\nImportant:\n   As the elf file has no information on the exception vectors\n   you have to control them yourself!
ProcReadElfLoadedAndEntrySet = Udane załadowanie pliku elfów do pamięci.\n Punkt wejścia pliku wykonywalnego został ustawiony na procesor.\n\nNieważne:\n Ponieważ plik elfów nie ma informacji o wektorach wyjątków, musisz je samodzielnie kontrolować!
SocUpMenuAsmWindow = Otwórz assembler
SocUpMenuCpuAsmWindowTitle = assembler dla CPU:
SocUpMenuCpuProgramWindowTitle = disassembler dla CPU:
SocUpMenuCpuStateWindowTitle = stan procesora dla CPU:
SocUpMenuErrorReadingElfTitle = Błąd w odczytywaniu pliku ELF
SocUpMenuReadElf = Odczytywanie pliku ELF
SocUpMenuSelectElfFile = Wybierz plik ELF do zaimportowania
SocUpMenuShowProgram = Pokaż załadowany program
SocUpMenuShowState = Pokaż stan CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Zatrzymany
SocUpSimHaltBreak = Pułapka
SocUpSimHaltError = Błąd
SocUpSimRunning = Uruchomiony
SocUpSimStateLabel = Stan Symulacji:
SocUpSimstateStart = Start
SocUpSimstateStop = Pauza
SocUpUnknown = Nieznany
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = To nie jest ani 32- ani 64-bitowy plik ELP.
# ElfHeaderEIDataError = Not a little or big endian encoded file
#ElfHeaderEIDataError = Niewielki lub duży endian zakodowany plik
ElfHeaderIncorrectEISize = Rozmiar dla sekcji EI jest nieprawidłowy
ElfHeaderIncorrectESize = Rozmiar dla sekcji E jest nieprawidłowy
ElfHeaderIncorrectMagic = Plik nie zawiera poprawnego nagłówka ELF. To prawdopodobnie nie jest plik typu ELF.
ElfHeaderNoErrors = Nagłówek jest poprawny
ElfHeaderReadingFileError = Błąd odczytu pliku
ElfHeaderUnknownArchitecture = Nieznana architektura
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Nie znaleziono nagłówka programu.
ProgHeaderReadError = Błąd odczytu nagłówka programu.
ProgHeaderSizeError = Niezgodność rozmiaru w nagłówku programu.
ProgHeaderSuccess = Sukces
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Znaleziono wiele tablic znakowych, co nie jest w tej chwili obsługiwane.
ElfSectHeadMultiSymtabError = Znaleziono wiele tabel symboli, co nie jest w tej chwili obsługiwane.
ElfSectHeadNotFound = Nie znaleziono nagłówka sekcji.
ElfSectHeadReadError = Błąd odczytu nagłówka sekcji.
ElfSectHeadSizeError = Niezgodność rozmiaru w nagłówku sekcji.
ElfSectHeadStingIdxError = Błędny indeks łańcucha.
ElfSectHeadStingNotFound = Nazwa sekcji nie została znaleziona.
ElfSectHeadStingReadError = Błąd odczytu tablicy znakowej.
ElfSectHeadStingTypeError = Błąd typu łańcucha znaków.
ElfSectHeadSuccess = Sukces
ElfSymTableNotFound = Nie udało się znaleźć tabeli symboli.
ElfSymTableReadError = Nie udało się odczytać tabeli symboli.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = 64-bitowe pliki ELF nie są jeszcze obsługiwane.
ProcReadElfArchError = Plik ELF jest przeznaczony dla procesora "%s", podczas gdy powinien być przeznaczony dla procesora "%s".
ProcReadElfEndianMismatch = Nieprawidłowy endian, plik ELF jest typu "%s", podczas gdy procesor zażądał "%s".
ProcReadElfErrorOpeningFile = Brak możliwości otwarcia pliku ELF.
ProcReadElfLoadableSectionNotFound = Ładowalna sekcja nie znaleziona w pliku ELF.
ProcReadElfLoadableSectionReadError = Błąd odczytu sekcji ładowalnej.
ProcReadElfLoadableSectionSizeError = Niezgodność rozmiaru w sekcji ładowalnej.
ProcReadElfLoadableSectionTooBig = Rozmiar części ładowalnej jest większy niż rozmiar obsługiwany przez Logisim.
ProcReadElfMemoryError = Błąd podczas zapisu sekcji ładowalnej do pamięci.\nUpewnij się że posiadasz komponent pamięci SoC dla regionu pamięci:\n%s...%s
ProcReadElfNotExecutable = Plik ELF nie jest plikiem wykonywalnym.
ProcReadElfSuccess = Sukces
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Asembler (.asm, .S)
AsmPanAssemble = Asembluj kod (ALT-A)
AsmPanDocumentChangedSave = W twoim dokumencie są zmiany, zapisać je?
# AsmPanErrorCreateFile = Unable to create the assembly file.
#AsmPanErrorCreateFile = Nie można utworzyć pliku zespołu.
AsmPanErrorReadingFile = Nie można odczytać pliku.
AsmPanNextError = Skocz do następnego błędu (CTRL-N)
AsmPanOpenFile = Odczytaj plik (CTRL-L)
AsmPanPreviousError = Skocz do poprzedniego błędu (CTRL-P)
AsmPanReadAsmFile = Wybierz plik do odczytu
AsmPanRun = Uruchom kod (ALT-R)
AsmPanSaveAsmFile = Wybierz plik do zapisania
AsmPanSaveFile = Zapisz plik (CTRL-S)
AsmPanSaveFileAs = Zapisz plik jako
AsmPanSaveFirstBeforeOpen = W twoim dokumencie są zmiany.\nCzy chcesz je zapisać przed otwarciem nowego pliku?
AssemblerAssembleSuccess = Sukces!\nNie znaleziono żadnych błędów w kodzie.
AssemblerRunSuccess = Udane załadowanie programu do pamięci.\nAby uruchomić program, upewnij się, że:\na) włączyłeś tiki zegara,\nb) ustawiłeś CPU w tryb pracy
AssemblerUnableToDownload = Nie można zapisać programu w pamięci. Upewnij się, że masz wystarczającą ilość dostępnej pamięci w odpowiednich miejscach pamięci.
RV32imAsmLineIndicator = Linia %d z %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Usuń pułapkę
RV32imSetBreakpoint = Dodaj pułapke
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Adres szyny: 0x
SocTransInsAtomicRequest = Transakcja atomowa
SocTransInsByteAccess = Transakcja bajtowa
SocTransInsHalfWordAccess = Transakcja półsłowa (2 bajty)
SocTransInsInputData = Dane do zapisu: 0x
SocTransInsInsertTransaction = Włóż transakcję do szyny
SocTransInsManual = Włożona ręcznie
SocTransInsReadData = Dane zwrócone:
SocTransInsReadRequest = Żądanie odczytu z szyny
SocTransInsTransResultTitle = Wynik włożonej transakcji:
SocTransInsWordAccess = Transakcja słowa (4 bajty)
SocTransInsWriteRequest = Żądanie zapisu na szyny
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Kod maszynowy:
Rv32imBinInstruction = Opcode:
# Rv32imEmptyTrace = No execution traces available
Rv32imEmptyTrace = Brak dostępnych śladów wykonania
Rv32imExecutionTrace = Śledzenie wykonania (ostatnio wykonane na górze):
Rv32imRegisterFile = Plik rejestru:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Sterowanie symulacją
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Wyczyść klawiaturę
JtagUartKeybAvailable = Dane z klawiatury dostępne
JtagUartKeybData = Dane z klawiatury
JtagUartKeybReadEnable = Odczytu klawiatury włączony
JtagUartTtyClear = Wyczyść TTY
JtagUartTtyData = Dane TTY
JtagUartTtyWrite = Dane do zapisu TTY
SocJtagUartComponent = JTAG UART
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = Próg odczytu IRQ
JtagUartWriteIrqThreshold = Próg zapisu IRQ
UartJtagREADFifoSize = Rozmiar FIFO do odczytu:
# UartJtagWriteFifoSize = Write FIFO size:
UartJtagWriteFifoSize = Rozmiar FIFO do zapisu:
#
# memory/SocMemory.java
#
# SocMemBase = Base:
SocMemBase = Baza:
SocMemoryComponent = Symulator pamięci
# SocMemSizeStr = Size:
#
# memory/SocMemoryAttributes.java
#
# SocMemSize = Byte address width:
SocMemSize = Szerokość adresu bajtowego:
SocMemStartAddress = Adres początkowy:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
# Nios2Component = Nios2s simulator
Nios2Component = Symulator Nios2s
Nios2Dataa = Dane A
Nios2Datab = Dane B
Nios2Done = Gotowe
Nios2N = N
Nios2ReadRa = Odczytaj Ra
Nios2ReadRb = Odczytaj Rb
Nios2Result = Rezultat
Nios2Start = Start
Nios2WriteRc = Zapisz Rc
Rv32imClockInput = Wejście zegara
Rv32imIrqInput = Wejście IRQ %s
Rv32imResetInput = Zresetuj wejście
#
# nios2/Nios2Attributes.java
#
# nios2BreakVector = Break Vector
#nios2BreakVector = Break Vector
rv32ExceptionVector = Wektor wyjątku
rv32imIrqWidth = Liczba linii IRQ
rv32ResetVector = Resetowanie wektora
rv32StateVisible = Stan widoczny:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Oczekiwane cztery argumenty
# Nios2DonePinError = Done pin not defined or in error state cannot continue.\n Please check the done pin.
#Nios2DonePinError = Done pin nie zdefiniowany lub w stanie błędu nie może być kontynuowany.\n Proszę sprawdzić zrobiony pin.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Błąd podczas wczytywania danych z systemu pamięci:
LoadStoreErrorInWriteTransaction = Błąd wykonania zapisu do systemu pamięci:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Oczekiwana wartość natychmiastowa
AssemblerExpectedNoArguments = Oczekiwany brak argumentów
AssemblerExpectedOneArgument = Oczekiwany jeden argument
AssemblerExpectedTwoArguments = Oczekiwane dwa argumenty
AssemblerExpectedZeroOrOneArgument = Oczekiwany brak lub jeden argument
AssemblerImmediateOutOfRange = Bezpośrednia wartość jest poza zakresem
AssemblerUnknownRegister = Nieznany rejestr
# Nios2AssemblerExpectedBracketedRegister = Expected a bracketed register, e.g. (r1)
#Nios2AssemblerExpectedBracketedRegister = Spodziewany rejestrator wspornikowy, np. (r1)
# Nios2AssemblerExpectedImmediateIndexedRegister = Expected an immediate indexed register, e.g. 5(r1)
#Nios2AssemblerExpectedImmediateIndexedRegister = Oczekiwany natychmiastowy indeksowany rejestr, np. 5(r1)
# Nios2CannotUseControlRegister = Cannot use a control register in this context
Nios2CannotUseControlRegister = W tym kontekście nie można używać rejestru kontrolnego.
# Nios2CannotUseCustomRegister = Cannot use a custom register in this context
Nios2CannotUseCustomRegister = W tym kontekście nie można korzystać z rejestru niestandardowego.
# Nios2ExpectedControlRegister = Expected a control register (e.g. ctl4)
Nios2ExpectedControlRegister = Oczekiwany rejestr kontroli (np. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Oczekiwane trzy argumenty
AssemblerExpextedImmediateOrLabel = Oczekiwana wartość natychmiastowa lub etykieta
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = status
RV32imBreakPointReached = Wykonanie jest wstrzymywane z powodu pułapki ustawionej na bieżącej instrukcji.
RV32imFetchExecutionError = Błąd w wykonaniu pobranej instrukcji.
RV32imFetchInvalidInstruction = Pobrano nieprawidłową instrukcję
RV32imFetchInvInstrAsm = Nieprawidłowa instrukcja!
RV32imFetchTransaction = -> Błąd pobierania transakcji.
Rv32imProgramCounter = PC:
# SocHiddenForFasterSimulation = Contents hidden for faster simulation
SocHiddenForFasterSimulation = Ukryta zawartośc by przyspieszyć symulację
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Oczekiwany rejestr
#
# pio/PioAttributes.java
#
SicPioIrqType = Typ przerwania:
SocPioAnyEdge = Dowolne zbocze
SocPioBidir = Porty dwukierunkowe (trójstanowiskowe)
SocPioCaptureEdge = Typ przechwytywania:
SocPioDirection = Kierunek:
SocPioFallingEdge = Zbocze opadające
SocPioGenIRQ = Przerwania włączone:
SocPioInout = Port wejściowy i wyjściowy
# SocPioInputCaptureBit = Capture bit-clearing:
SocPioInputCaptureBit = Przechwytuj czyszczenie bitów:
SocPioInputOnly = Tylko porty wejściowe
# SocPioInputsSyncCapture = Sync. capture:
SocPioInputsSyncCapture = Synchronizuj przechwytuwanie:
SocPioIrQEdge = Zbocze
SocPioIrqLevel = Poziom
# SocPioOutputIndividualBits = Output bit set/clear:
SocPioOutputIndividualBits = Ustawianie/czyszczenie bitu wyjściowego:
SocPioOutputOnly = Tylko porty wyjściowe
SocPioOutputResetValue = Wartość resetująca wyjście:
SocPioRisingEdge = Zbocze wznoszące
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Nie można utworzyć nagłówka i/lub pliku C!
ExportC = Eksportuj szablony C
PioMenuBidirFunctionsRemark = /* Za pomocą następujących funkcji można ustawić lub odczytać rejestr dwukierunkowy * a 1 oznacza, że bit jest wyjściem, a 0 oznacza, że jest wejściem\n * Uwaga: używane są tylko mniej znaczące bity %s.\n */
PioMenuCaptureAll = usuń wszystkie bity w rejestrze przechwytywania niezależnie od wartości parametru "wartość".
PioMenuCaptureAny = co najmniej jedna zmiana z 0 na 1 lub z 1 na 0
PioMenuCaptureBit = skasuj bity w rejestrze przechwytywania, które wynoszą 1 w parametrze "wartość".
PioMenuCaptureFalling = co najmniej jedna zmiana z 1 na 0
PioMenuCaptureRising = co najmniej jedna zmiana z 0 na 1
# PioMenuEdgeCaptureRemark = /* With the following functions the edge capture register can be cleared or read out\n * in case the edge register is read out a 1 on a position indicates that the\n * respective input has hat %s,\n * otherwise the respective input has not changed.\n *\n * Writing to this register will %s.\n * Note: only the lower %s bits are used.\n */
PioMenuEdgeCaptureRemark = /* Za pomocą następujących funkcji można wyczyścić lub odczytać rejestr zbocza, jeśli rejestr zbocza jest odczytywany a 1 na pozycji wskazuje, że odpowiednie wejście ma hat %s,\n * w przeciwnym razie odpowiednie wejście nie zmieni się.\n *\n * Zapisanie do tego rejestru będzie oznaczać %s.\n * Uwaga: używane są tylko dolne bity %s.\n */
# PioMenuInputDataFunctionRemark = /* With the following function the input values of the PIO can be\n * read out.\n * This function returns the respective value\n * Note: only the lower %s bits are valid\n */
PioMenuInputDataFunctionRemark = /* Za pomocą następującej funkcji wartości wejściowe PIO mogą być\n * odczytywane.\n * Funkcja ta zwraca odpowiednią wartość\n * Uwaga: tylko dolne bity %s są ważne\n */
# PioMenuIrqEdge = corresponding bit in the capture register
PioMenuIrqEdge = odpowiedni bit w rejestrze przechwytywania
PioMenuIrqLevel = odpowiednie wejście
# PioMenuMaskFunctionsRemark = /* With the following functions the Interrupt mask register can be set or read out.\n * A 1 on a specific location indicates that an interrupt will be generated\n * if the %s is equal to 1.\n * Note: only the lower %s bits are used.\n */
PioMenuMaskFunctionsRemark = /* Za pomocą następujących funkcji można ustawić lub odczytać rejestr maski przerwania.\n * A 1 w określonej lokalizacji wskazuje, że przerwanie zostanie wygenerowane\n * jeśli %s jest równe 1.\n * Uwaga: używane są tylko niższe bity %s.\n */
# PioMenuOutClearRemark = /* With the following function the bits that are 1 in the parameter "value" will force\n * the corresponding output to 0\n * Note: only the lower %s bits are used.\n */
PioMenuOutClearRemark = /* Za pomocą następującej funkcji bity o wartości 1 w parametrze "wartość" wymuszą\n * odpowiednie wyjście do 0\n * Uwaga: stosowane są tylko bity o wartości niższej %s.\n */
# PioMenuOutputDataFunctionRemark = /* With the following function the output values of the PIO can be\n * set.\n * This function takes the new output value as parameter "value"\n * Note: only the lower %s bits of the provided parameter "value" are valid\n */
PioMenuOutputDataFunctionRemark = /* Za pomocą następującej funkcji wartości wyjściowe PIO mogą być\n * ustawione.\n * Funkcja ta przyjmuje nową wartość wyjściową jako parametr "wartość"\n * Uwaga: tylko dolne bity %s podanego parametru "wartość" są ważne\n */
# PioMenuOutSetRemark = /* With the following function the bits that are 1 in the parameter "value" will force\n * the corresponding output to 1\n * Note: only the lower %s bits are used.\n */
PioMenuOutSetRemark = /* Za pomocą następującej funkcji bity o wartości 1 w parametrze "wartość" wymuszą\n * odpowiednie wyjście do 1\n * Uwaga: stosowane są tylko bity o niższej wartości %s.\n */
SelectDirectoryToStoreC = Ustaw katalog do zapisu szablonów C
SuccesCreatingHeaderAndCFile = Udane utworzenie plików:\n%s\noraz\n%s
#
# pio/SocPio.java
#
# SocPioBidirPinx = Bidir bit %s
#SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Piny dwukierunkowe
SocPioComponent = Ekspander równoległy wejścia/wyjścia
SocPioInputPinx = Bit wejściowy %s
SocPioInputs = Piny wejściowe
SocPioIrqOutput = Wyjście IRQ
SocPioOutputPinx = Bit wyjściowy %s
SocPioOutputs = Piny wyjściowe
SocPioResetInput = Wejście resetowania
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Symulator Risc V IM
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = Oczekiwany jeden lub dwa argumenty
Rv32imAssemblerExpectedTwoOrThreeArguments = Oczekiwane dwa lub trzy argumenty
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
# Rv32imECABNotImplmented = Currently the environmental call and breakpoints are not implemented
Rv32imECABNotImplmented = Obecnie nie wdrożono zaproszenia do składania wniosków w zakresie ochrony środowiska i punktów krytycznych.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
# RV32imAssemblerBUG = BUG!
RV32imAssemblerBUG = BŁĄD!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
# RV32imAssemblerExpectedBracketedRegister = Expected a bracketed register, e.g. (x1)
RV32imAssemblerExpectedBracketedRegister = Spodziewany rejestrator z uchwytem, np. (x1)
# RV32imAssemblerExpectedImmediateIndexedRegister = Expected an immediate indexed register, e.g. 5(x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Oczekiwany natychmiastowy indeksowany rejestr, np. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Nieobsługiwany OPcode
# Rv32imMOINotImplmented = Currently the memory ordering instructions are not implemented
#Rv32imMOINotImplmented = Obecnie instrukcje zamawiania pamięci nie są zaimplementowane.
#
# Soc.java
#
SocBusComponent = Symulator szyny SoC
socLibrary = System On a Chip
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Nieznany OPCode
UnknownInstruction = Nieznana instrukcja
#
# util/Assembler.java
#
# AssemblerAssumingEntryPoint = Assuming the lowest address with an instruction as entry-point.\nTo make sure that your cpu starts executing at the right address\nplease add a label called '_start' at the location\nwhere your cpu should start executing the program.
AssemblerAssumingEntryPoint = Zakładając najniższy adres z instrukcją jako punkt wejścia.\nAby upewnić się, że twój cpu zaczyna wykonywać program pod właściwym adresem, dodaj etykietę '_start' w miejscu, w którym twój cpu powinien zacząć wykonywać program.
AssemblerCannotUseInsideMacro = Ta konstrukcja nie może być użyta wewnątrz makrodefinicji.
AssemblerEndOfMacroNotFound = Nie mogę znaleźć końca makrodefinicji.
AssemblerExpectedMacroName = Oczekiwana nazwa makrodefinicji.
AssemblerExpectedMacroNrOfParameters = Oczekiwana liczba parametrów dla makrodefinicji
AssemblerExpectingLabelIdentifier = Oczekiwana etykieta
AssemblerMissingLabelBefore = Dla tego operatora powinna być etykieta
AssemblerNoExecutableSection = Nie znaleziono żadnej instrukcji którą można wykonać.
AssemblerReguiresNumberAfterMath = Po operacji matematycznej powinna wystąpić liczba
AssemblerUnknowCharacter = Nieznany znak
AssemblerWrongClosingBracket = Ten nawias zamykający nie jest obsługiwany
AssemblerWrongOpeningBracket = Ten nawias otwierający nie jest obsługiwany
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Nie można ustalić adresu dla tej etykiety.
AssemblerCouldNotFindValueForDefine = Nie można znaleźć definicji tego parametru.
AssemblerDivZero = Błąd dzielenia przez zero.
AssemblerExpectedImmediateValueAfterMath = Oczekiwana wartość natychmiastowa po operacji matematycznej
#
# util/AssemblerInfo.java
#
# AssemblerDuplicatedLabelNotSupported = Label names must be unique, found multiple definitions of this label
AssemblerDuplicatedLabelNotSupported = Nazwy etykiet muszą być unikalne. Etykieta o tej nazwie już istnieje.
AssemblerDuplicatedName = Nie można użyć tej samej nazwy dla .equ i etykiety
AssemblerDuplicatedSectionError = Nazwy sekcji muszą być unikalne. Sekcja o podanej nazwie już istnieje.
AssemblerExpectedLabel = Oczekiwano etykiety
AssemblerExpectedLabelAndNumber = Oczekiwano etykiety z występującą po niej wartością natychmiastowa
AssemblerExpectedParameter = Oczekiwany parametr na tej pozycji
AssemblerExpectingNumber = Oczekiwano liczby
AssemblerExpectingPositiveNumber = Oczekiwano liczby dodatniej
AssemblerExpectingSectionName = Oczekiwano nazwy dla tej sekcji
AssemblerExpectingString = Oczekiwano ciągu znaków
AssemblerMacroIncorrectNumberOfParameters = Podano nieprawidłową liczba parametrów makrodefinicji
AssemblerOverlappingSections = Ta sekcja pokrywa się z inną sekcją
AssemblerUnknownIdentifier = Nie znam tego identyfikatora
AssemblerUnknownLabel = Ta etykieta nie została zdefiniowana, dlatego nie może być użyta.
AssemblerUnsupportedAssemblerInstruction = Ta instrukcja asemblera nie jest znana.
AssemblerValueOutOfRange = Wartość jest poza zakresem
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Makra wywołują się wzajemnie powodując deadlock
AssemblerMacroCannotUseRecurency = Makro wywołuje sibie do siebie powodując powodując deadlock
AssemblerMacroParameterNotDefined = Ten parametr makro nie jest zdefiniowany, sprawdź liczbę parametrów w definicji makra.
#
# vga/SocVgaShape.java
#
SocVgaComponent = Ekran VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Adres bufora pikseli:
VgaInitialDisplayMode = Tryb początkowy:
VgaSoftMode = Programowe %s:
VgaStartAddress = Adres bazowy:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* Za pomocą następujących funkcji można manipulować trybem VGA.\n * Odczytywanie trybu VGA zwraca obsługiwane tryby (patrz powyższe definicje możliwych trybów)\n * Zapisanie obsługiwanego trybu spowoduje zmianę trybu wyświetlania wyświetlacza VGA\n */
