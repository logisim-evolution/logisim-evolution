#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Taille des traces :
SocBusTraceVisible = Traces visibles :
#
# bus/SocBusMenuProvider.java
#
insertTrans = Insérer une transaction de bus
SocBusMemMap = Afficher la carte mémoire
SocBusTraceWindow = Afficher la trace de la ou des transaction(s) de bus
SocInsertTransWindowTitle = Insérer une transaction dans le bus :
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Fenêtre de traçage du bus (double-cliquez sur un tracé pour le supprimer)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Non connecté à un bus
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Aucune trace présente
SocMemMapWindowTitle = Carte mémoire pour bus :
SocMemoryMapOk = Fermer
SocMemoryMapTitle = Carte mémoire (le rouge indique les zones de mémoire qui se chevauchent) :
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Initiateur :
SocBusStateNoDataMax10chars = pas de données
SocBusStateSlave = Répondeur :
SocBusStateTraceIndex = N° de transaction :
SocTransactionByteAccesNoSupport = L’esclave ne prend pas en charge les accès par octets.
SocTransactionByteAccesNoSupportShort = Pas d’accès aux octets
SocTransactionHalfWordAccesNoSupport = L’esclave ne prend pas en charge les accès en demi-mot.
SocTransactionHalfWordAccesNoSupportShort = Pas d’accès HW
SocTransactionMisalignedAddress = L’esclave a détecté une adresse mal alignée.
SocTransactionMisalignedAddressShort = Misal. Adr.
SocTransactionMultipleSlaveAnswers = Plusieurs esclaves ont répondu à une transaction. Veuillez vérifier la carte mémoire de vos esclaves.
SocTransactionMultipleSlaveAnswersShort = Esclaves multiples
SocTransactionNoBusConnected = Le composant maître n’est connecté à aucun Soc Bus. Veuillez raccorder le maître à un composant bus.
SocTransactionNoBusConnectedShort = Pas de bus
SocTransactionNoneAtomicRW = Une action de lecture/écriture non atomique est demandée. Ceci n’est pas permis.
SocTransactionNoneAtomicRWShort = Aucun RW atomique
SocTransactionNoRespons = Aucun composant esclave n’a répondu à la demande. Veuillez vérifier l’adresse mémoire de la demande et la carte mémoire de votre système.
SocTransactionNoResponsShort = Pas de réponse
SocTransactionNoSlavesAttached = Le bus qui est connecté au maître n’a pas d’esclaves connectés. Veuillez attacher des esclaves au bus.
SocTransactionNoSlavesAttachedShort = Pas d’esclaves
SocTransactionReadOnlyAccessError = L’esclave ne supporte que les accès en lecture sur cette adresse
SocTransactionReadOnlyAccessErrorShort = Lecture seule
SocTransactionRegisterDoesNotExist = L’esclave ne supporte aucun accès sur cette adresse
SocTransactionRegisterDoesNotExistShort = Pas d’accès
SocTransactionSuccessfull = Aucune erreur n’est survenue, la transaction est réussie.
SocTransactionSuccessfullShort = Succès
SocTransactionUnknownError = Bizarre, ce message d’erreur ne devrait jamais se produire et représente un bug dans logisim.
SocTransactionUnknownErrorShort = BUG !
SocTransactionWordAccesNoSupport = L’esclave ne prend pas en charge les accès par mot.
SocTransactionWordAccesNoSupportShort = Pas d’accès aux mots
SocTransactionWriteOnlyAccessError = L’esclave ne prend pas en charge une action de lecture sur cette adresse.
SocTransactionWriteOnlyAccessErrorShort = Écrire seulement
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Vide (pas d’esclaves)
SocMemMapEndAddress = Adresse de fin :
SocMemMapSlaveName = Nom du composant :
SocMemMapStartAddress = Adresse de départ :
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Veuillez sélectionner un bus pour vous connecter à
SocBusSelectAttr = Bus connecté
SocBusSelectAttrClick = Cliquez pour sélectionner
SocManagerNoBusses = Pas de bus disponible, veuillez ajouter un bus SoC à votre schéma.
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = A chargé avec succès le fichier ELF dans la mémoire.\nLe point d’entrée de l’exécutable a été défini sur le processeur.\n\nImportant :\n   Comme le fichier ELF ne contient aucune information sur les vecteurs d’exception\n   tu dois les contrôler toi-même !
SocUpMenuAsmWindow = Assembleur ouvert
SocUpMenuCpuAsmWindowTitle = assembleur pour processeur cpu :
SocUpMenuCpuProgramWindowTitle = désassembleur pour processeur cpu :
SocUpMenuCpuStateWindowTitle = état du processeur pour cpu :
SocUpMenuErrorReadingElfTitle = Erreur dans la lecture du fichier ELF
SocUpMenuReadElf = Lire le fichier ELF
SocUpMenuSelectElfFile = Sélectionner le fichier ELF à importer
SocUpMenuShowProgram = Afficher le programme chargé
SocUpMenuShowState = Afficher l'état du CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Arrêté
SocUpSimHaltBreak = Point de rupture
SocUpSimHaltError = Erreur
SocUpSimRunning = Course à pied
SocUpSimStateLabel = État Sim :
SocUpSimstateStart = Début
SocUpSimstateStop = Pause
SocUpUnknown = Inconnu
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Pas un fichier ELF 32 ou 64 bits
ElfHeaderEIDataError = Pas un petit ou un gros fichier encodé en endian
ElfHeaderIncorrectEISize = La taille de la section EI est incorrecte
ElfHeaderIncorrectESize = La taille de la section E est incorrecte.
ElfHeaderIncorrectMagic = Le fichier ne contient pas le bon magic ELF ; probablement pas un fichier ELF.
ElfHeaderNoErrors = L’en-tête est correct
ElfHeaderReadingFileError = Erreur de lecture du fichier
ElfHeaderUnknownArchitecture = Architecture inconnue
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = En-tête de programme introuvable.
ProgHeaderReadError = Erreur de lecture de l’en-tête du programme.
ProgHeaderSizeError = Incohérence de taille dans l’en-tête du programme.
ProgHeaderSuccess = Succès
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = J’ai trouvé plusieurs tables de chaînes de caractères, non prises en charge pour le moment.
ElfSectHeadMultiSymtabError = J’ai trouvé plusieurs tables de symboles, non prises en charge pour le moment ;
ElfSectHeadNotFound = En-tête de section introuvable.
ElfSectHeadReadError = En-tête de la section de lecture des erreurs.
ElfSectHeadSizeError = Incohérence de taille dans l’en-tête de section.
ElfSectHeadStingIdxError = Indice de chaîne d’erreurs.
ElfSectHeadStingNotFound = Le nom de la section n’a pas été trouvé.
ElfSectHeadStingReadError = Erreur de lecture de la table des chaînes de caractères.
ElfSectHeadStingTypeError = Erreur de type chaîne de caractères.
ElfSectHeadSuccess = Succès
ElfSymTableNotFound = Impossible de trouver le tableau des symboles.
ElfSymTableReadError = Impossible de lire le tableau des symboles.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim ne supporte pas encore les fichiers ELF 64 bits.
ProcReadElfArchError = Le fichier ELF est pour un processeur « %s » alors qu’il devrait être pour un processeur « %s ».
ProcReadElfEndianMismatch = Incohérence endiane, le fichier ELF est « %s » alors que le processeur a demandé « %s ».
ProcReadElfErrorOpeningFile = C'est impossible d’ouvrir le fichier ELF.
ProcReadElfLoadableSectionNotFound = Section chargeable non trouvée dans le fichier ELF.
ProcReadElfLoadableSectionReadError = Erreur de lecture section chargeable.
ProcReadElfLoadableSectionSizeError = Désalignement des tailles dans la section chargeable.
ProcReadElfLoadableSectionTooBig = La taille de la section chargeable est plus grande que la taille supportée par logisim.
ProcReadElfMemoryError = Une erreur s’est produite lors de l'écriture d’une section chargeable en mémoire.\nAssurez-vous d’avoir un composant de mémoire SoC disponible pour la région mémoire :\n%s…%s
ProcReadElfNotExecutable = Le fichier ELF n’est pas un exécutable.
ProcReadElfSuccess = Succès
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Fichiers d’assemblage (.asm,.S)
AsmPanAssemble = Assemblez le code (ALT-A)
AsmPanDocumentChangedSave = Il y a des changements dans votre document, sauvegardez-les ?
AsmPanErrorCreateFile = Impossible de créer le fichier d’assemblage.
AsmPanErrorReadingFile = Impossible de lire le fichier
AsmPanNextError = Passer à l’erreur suivante (CTRL-N)
AsmPanOpenFile = Lire un fichier (CTRL-L)
AsmPanPreviousError = Aller à l’erreur précédente (CTRL-P)
AsmPanReadAsmFile = Sélectionnez un fichier à lire
AsmPanRun = Exécuter le code (ALT-R)
AsmPanSaveAsmFile = Sélectionnez un fichier à enregistrer
AsmPanSaveFile = Enregistrer le fichier (CTRL-S)
AsmPanSaveFileAs = Enregistrer le fichier sous
AsmPanSaveFirstBeforeOpen = Il y a des changements dans votre document\nVoulez-vous les enregistrer avant d’ouvrir un nouveau fichier ?
AssemblerAssembleSuccess = Succès !\nAucune erreur trouvée dans votre code.
AssemblerRunSuccess = A chargé avec succès le programme en mémoire.\nPour exécuter le programme, assurez-vous que :\na) vous activez les tiques\nb) vous mettez le processeur en mode de fonctionnement
AssemblerUnableToDownload = Impossible de stocker le programme en mémoire,\nassurez-vous d’avoir suffisamment de mémoire disponible\naux bons emplacements de mémoire.
RV32imAsmLineIndicator = Ligne %d de %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Supprimer le point de rupture
RV32imSetBreakpoint = Ajouter un point de rupture
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Adresse du bus : 0x
SocTransInsAtomicRequest = Transaction atomique
SocTransInsByteAccess = Octet de transaction
SocTransInsHalfWordAccess = Transaction en demi-mot (2 octets)
SocTransInsInputData = Données à écrire : 0x
SocTransInsInsertTransaction = Insérer la transaction dans le bus
SocTransInsManual = Insertion manuelle
SocTransInsReadData = Données retournées :
SocTransInsReadRequest = Demande de lecture du bus
SocTransInsTransResultTitle = Résultat de la transaction insérée :
SocTransInsWordAccess = Transaction Word (4 octets)
SocTransInsWriteRequest = Demande d'écriture de bus
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Assemblage :
Rv32imBinInstruction = Opcode :
Rv32imEmptyTrace = Aucune trace d’exécution disponible
Rv32imExecutionTrace = Trace d’exécution (dernière exécution en haut) :
Rv32imRegisterFile = Enregistrer fichier :
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Contrôle de simulation
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Effacer le clavier
JtagUartKeybAvailable = Données clavier disponibles
JtagUartKeybData = Données du clavier
JtagUartKeybReadEnable = Activation de la lecture du clavier
JtagUartTtyClear = ATS clair
JtagUartTtyData = Données ATS
JtagUartTtyWrite = Données d'écriture ATS
SocJtagUartComponent = JTAG UART
#
# jtaguart/JtagUartAttributes.java
#
JtagUartReadIrqThreshold = Lecture du seuil IRQ
JtagUartWriteIrqThreshold = Écriture du seuil d’IRQ
UartJtagREADFifoSize = Taille de lecture FIFO :
UartJtagWriteFifoSize = Taille d'écriture FIFO :
#
# memory/SocMemory.java
#
SocMemBase = Base :
SocMemoryComponent = Simulateur de mémoire
SocMemSizeStr = Taille :
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Largeur de l’adresse de l’octet :
SocMemStartAddress = Adresse de départ :
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Simulateur Nios2s
Nios2Dataa = Données A
Nios2Datab = Données B
Nios2Done = Fait
Nios2N = N
Nios2ReadRa = Lisez Ra
Nios2ReadRb = Lire Rb
Nios2Result = Résultat
Nios2Start = Début
Nios2WriteRc = Écrire Rc
Rv32imClockInput = Entrée horloge
Rv32imIrqInput = Entrée IRQ %s
Rv32imResetInput = Entrée de réinitialisation
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Vecteur de rupture
rv32ExceptionVector = Vecteur d’exception
rv32imIrqWidth = Nombre de lignes IRQ
rv32ResetVector = Réinitialiser le vecteur
rv32StateVisible = État visible :
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = On s’attendait à quatre arguments
Nios2DonePinError = Si la broche n’est pas définie ou si elle est dans un état d’erreur, il n’est pas possible de continuer.\n S’il vous plaît, vérifiez l'épingle faite.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Erreur lors de l’exécution d’une charge à partir du système de mémoire :
LoadStoreErrorInWriteTransaction = Erreur lors de l’exécution d’une mémorisation dans le système de mémoire :
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Une valeur attendue immédiate
AssemblerExpectedNoArguments = Pas d’arguments attendus
AssemblerExpectedOneArgument = Attendu un argument
AssemblerExpectedTwoArguments = Attendu deux arguments
AssemblerExpectedZeroOrOneArgument = Aucun ou un seul argument n'était attendu
AssemblerImmediateOutOfRange = La valeur immédiate est hors plage
AssemblerUnknownRegister = Registre inconnu
Nios2AssemblerExpectedBracketedRegister = Attendu un registre entre crochets, par exemple (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = On s’attendait à un registre indexé immédiat, p. ex. 5(r1)
Nios2CannotUseControlRegister = Impossible d’utiliser un registre de contrôle dans ce contexte
Nios2CannotUseCustomRegister = Impossible d’utiliser un registre personnalisé dans ce contexte
Nios2ExpectedControlRegister = Attendu un registre de contrôle (par ex. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Attendu trois arguments
AssemblerExpextedImmediateOrLabel = Attendu une valeur immédiate ou une étiquette
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = situation
RV32imBreakPointReached = L’exécution est interrompue en raison d’un point d’arrêt réglé sur l’instruction en cours.
RV32imFetchExecutionError = Erreur dans l’exécution de l’instruction récupérée
RV32imFetchInvalidInstruction = L’instruction non valide a été récupérée.
RV32imFetchInvInstrAsm = Instruction invalide !
RV32imFetchTransaction = -> Erreur de transaction de récupération.
Rv32imProgramCounter = pc :
SocHiddenForFasterSimulation = Contenu caché pour une simulation plus rapide
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Attendu un registre
#
# pio/PioAttributes.java
#
SicPioIrqType = Type Irq :
SocPioAnyEdge = N’importe quel bord
SocPioBidir = Ports bidirectionnels (tristates)
SocPioCaptureEdge = Type de capture :
SocPioDirection = Direction :
SocPioFallingEdge = Bord de chute
SocPioGenIRQ = IRQ activé :
SocPioInout = Ports d’entrée et de sortie
SocPioInputCaptureBit = Nettoyage du trépan de capture :
SocPioInputOnly = Ports d’entrée uniquement
SocPioInputsSyncCapture = Synchronisation de la capture :
SocPioIrQEdge = Bord
SocPioIrqLevel = Niveau
SocPioOutputIndividualBits = Bit de sortie activé/effacé :
SocPioOutputOnly = Ports de sortie uniquement
SocPioOutputResetValue = Valeur de réinitialisation de la sortie :
SocPioRisingEdge = Arête montante
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Impossible de créer un en-tête et/ou un fichier c !
ExportC = Exporter des modèles C
PioMenuBidirFunctionsRemark = /* Les fonctions suivantes permettent de régler ou de lire le registre bidirectionnel\n * a 1 indique que le bit de respect est une sortie, a 0 indique qu’il est une entrée\n * Remarque : seuls les bits %s inférieurs sont utilisés.\n */
PioMenuCaptureAll = effacer tous les bits du registre de capture indépendamment de la valeur du paramètre « valeur ».
PioMenuCaptureAny = au moins un changement de 0 à 1 ou de 1 à 0
PioMenuCaptureBit = effacer les bits du registre de capture qui sont 1 dans le paramètre « value ».
PioMenuCaptureFalling = au moins un changement de 1 à 0
PioMenuCaptureRising = au moins un changement de 0 à 1
PioMenuEdgeCaptureRemark = /* Les fonctions suivantes permettent d’effacer ou de lire le registre de capture des fronts\n * dans le cas où le registre de bord est lu un 1 sur une position indique que l’option\n * l’entrée respective a des %s de chapeau,\n * sinon l’entrée correspondante n’a pas changé.\n *\n * Ecrire dans ce registre sera %s.\n * Remarque : seuls les bits %s inférieurs sont utilisés.\n */
PioMenuInputDataFunctionRemark = /* Avec la fonction suivante, les valeurs d’entrée du PIO peuvent être\n * read out.\n * Cette fonction renvoie la valeur correspondante\n * Remarque : seuls les bits %s inférieurs sont valides.\n */
PioMenuIrqEdge = bit correspondant dans le registre de capture
PioMenuIrqLevel = entrée correspondante
PioMenuMaskFunctionsRemark = /* Les fonctions suivantes permettent de régler ou de lire le registre des masques d’interruption.\n * Un 1 sur un emplacement spécifique indique qu’une interruption sera générée\n * si le %s est égal à 1.\n * Remarque : seuls les bits %s inférieurs sont utilisés.\n */
PioMenuOutClearRemark = /* Avec la fonction suivante, les bits qui sont 1 dans le paramètre « valeur » forceront\n * la sortie correspondante à 0\n * Remarque : seuls les bits %s inférieurs sont utilisés.\n */
PioMenuOutputDataFunctionRemark = /* Avec la fonction suivante, les valeurs de sortie du PIO peuvent être\n *Set.\n * Cette fonction prend la nouvelle valeur de sortie comme paramètre « valeur ».\n * Remarque : seuls les bits %s inférieurs du paramètre « value » fourni sont valides.\n */
PioMenuOutSetRemark = /* Avec la fonction suivante, les bits qui sont 1 dans le paramètre « valeur » forceront\n * la sortie correspondante à 1\n * Remarque : seuls les bits %s inférieurs sont utilisés.\n */
SelectDirectoryToStoreC = Définir le répertoire pour stocker les C-templates
SuccesCreatingHeaderAndCFile = A créé avec succès les fichiers :\n%s\net\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bit Bidir %s
SocPioBidirs = Broches bidirectionnelles
SocPioComponent = Expandeur d’entrée/sortie parallèle
SocPioInputPinx = Bit d’entrée %s
SocPioInputs = Broches d’entrée
SocPioIrqOutput = Sortie Irq
SocPioOutputPinx = Bit de sortie %s
SocPioOutputs = Broches de sortie
SocPioResetInput = Entrée de réinitialisation
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Simulateur Risc V IM
# ==> Rv32PlicBaseAddress =
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = On s’attendait à un ou deux arguments
Rv32imAssemblerExpectedTwoOrThreeArguments = On s’attendait à deux ou trois arguments
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = À l’heure actuelle, les points d’appel et les points d’arrêt environnementaux ne sont pas mis en œuvre.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG !
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Attendu un registre entre crochets, par exemple (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = On s’attendait à un registre indexé immédiat, p. ex. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Opcode asm non supporté
Rv32imMOINotImplmented = Actuellement, les instructions de commande de mémoire ne sont pas implémentées.
#
# Soc.java
#
SocBusComponent = Simulateur de bus SoC
socLibrary = System On a Chip
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Code d’opération inconnu
UnknownInstruction = Instruction inconnue
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = En supposant l’adresse la plus basse avec une instruction comme point d’entrée.\nPour vous assurer que votre processeur commence à s’exécuter à la bonne adresse\nveuillez ajouter une étiquette appelée’_start' à l’emplacement\noù votre processeur devrait commencer à exécuter le programme.
AssemblerCannotUseInsideMacro = Cette construction ne peut pas être utilisée à l’intérieur d’une macro-définition
AssemblerEndOfMacroNotFound = Impossible de trouver la fin de la macro-définition
AssemblerExpectedMacroName = Nom de macro attendu
AssemblerExpectedMacroNrOfParameters = Nombre prévu de paramètres macroéconomiques
AssemblerExpectingLabelIdentifier = Étiquette attendue
AssemblerMissingLabelBefore = Pour cet opérateur doit être une étiquette
AssemblerNoExecutableSection = Aucune instruction ne peut être exécutée.
AssemblerReguiresNumberAfterMath = Après une opération mathématique devrait suivre un nombre
AssemblerUnknowCharacter = Caractère inconnu
AssemblerWrongClosingBracket = Ce support de fermeture n’est pas supporté
AssemblerWrongOpeningBracket = Ce support d’ouverture n’est pas supporté
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Impossible de déterminer une adresse pour cette étiquette
AssemblerCouldNotFindValueForDefine = Impossible de trouver une définition de ce paramètre
AssemblerDivZero = Diviser par zéro erreur
AssemblerExpectedImmediateValueAfterMath = Valeur attendue immédiatement après une opération mathématique
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Les noms d'étiquettes doivent être uniques, plusieurs définitions de cette étiquette ont été trouvées.
AssemblerDuplicatedName = Impossible d’utiliser le même nom pour un.equ et une étiquette
AssemblerDuplicatedSectionError = Les noms de sections doivent être uniques, trouvés plusieurs sections avec ce nom
AssemblerExpectedLabel = Étiquette attendue
AssemblerExpectedLabelAndNumber = Étiquette suivie d’une valeur immédiate attendue
AssemblerExpectedParameter = Paramètre attendu à cette position
AssemblerExpectingNumber = Nombre attendu
AssemblerExpectingPositiveNumber = Nombre positif attendu
AssemblerExpectingSectionName = Nom de section attendu
AssemblerExpectingString = Chaîne de caractères attendue
AssemblerMacroIncorrectNumberOfParameters = Nombre incorrect de paramètres macro spécifiés
AssemblerOverlappingSections = Cette section recoupe une autre section
AssemblerUnknownIdentifier = Je ne connais pas cet identifiant
AssemblerUnknownLabel = Cette étiquette n’a pas été définie, donc je ne peux pas l’utiliser
AssemblerUnsupportedAssemblerInstruction = Cette instruction assembleur n’est pas connue
AssemblerValueOutOfRange = La valeur est hors plage
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Les macros s’appellent l’une l’autre, ce qui crée une situation d’impasse.
AssemblerMacroCannotUseRecurency = Macro s’appelle lui-même, ce qui provoque une situation d’impasse.
AssemblerMacroParameterNotDefined = Ce paramètre macro n’est pas défini, vérifiez le nombre de paramètres dans votre définition de macro.
#
# vga/SocVgaShape.java
#
SocVgaComponent = écran VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Adresse du tampon de pixels :
VgaInitialDisplayMode = Mode initial :
VgaSoftMode = Logiciel %s :
VgaStartAddress = Adresse de base :
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* Avec les fonctions suivantes, le mode VGA peut être manipulé.\n * La lecture du mode VGA renvoie les modes supportés (voir ci-dessus les définitions des modes possibles).\n * L'écriture d’un mode supporté changera le mode d’affichage de l’affichage VGA.\n */
#
# dma/SocDma.java, dma/DmaAttributes.java
#
# ==> SocDmaComponent =
# ==> SocDmaStartAddress =
# ==> SocDmaBurstSize =
# ==> SocDmaSrcBus =
# ==> SocDmaDstBus =
# ==> SocDmaResetInput =
# ==> SocDmaClockInput =
# ==> SocDmaIrqOutput =
# ==> SocDmaBaseLabel =
# ==> SocDmaBurstLabel =
# ==> SocDmaStatusIdle =
# ==> SocDmaStatusBusy =
# ==> SocDmaStatusDone =
