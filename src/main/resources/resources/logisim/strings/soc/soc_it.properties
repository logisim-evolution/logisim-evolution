#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Dimensione delle tracce:
SocBusTraceVisible = Tracce visibili:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Inserire una transazione bus
SocBusMemMap = Mostra mappa della memoria
SocBusTraceWindow = Mostra la traccia delle transazioni del bus
SocInsertTransWindowTitle = Inserire una transazione su bus:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Finestra Bus trace (doppio click su una traccia per rimuoverla)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Non collegato ad un bus
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Nessuna traccia presente
SocMemMapWindowTitle = Mappa di memoria per bus:
SocMemoryMapOk = Chiudere
SocMemoryMapTitle = Memory Map (in rosso indica le regioni di memoria sovrapposte):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Iniziatore:
SocBusStateNoDataMax10chars = nessun dato
SocBusStateSlave = Risponditore:
SocBusStateTraceIndex = Operazione nr:
SocTransactionByteAccesNoSupport = Slave non supporta gli accessi ai byte.
SocTransactionByteAccesNoSupportShort = Nessun accesso al byte
SocTransactionHalfWordAccesNoSupport = Slave non supporta gli accessi a mezza parola.
SocTransactionHalfWordAccesNoSupportShort = Nessun accesso HW
SocTransactionMisalignedAddress = Lo schiavo ha rilevato un indirizzo disallineato.
SocTransactionMisalignedAddressShort = Misal. Addr.
SocTransactionMultipleSlaveAnswers = Più schiavi hanno risposto a una transazione. Controlla la mappa della memoria dei tuoi schiavi.
SocTransactionMultipleSlaveAnswersShort = Più schiavi
SocTransactionNoBusConnected = Il componente master non è collegato ad alcun Soc Bus. Collegare il master ad un componente bus.
SocTransactionNoBusConnectedShort = Senza autobus
SocTransactionNoneAtomicRW = È richiesta un'azione di lettura/scrittura non atomica. Questo non è permesso.
SocTransactionNoneAtomicRWShort = Nessuno atomico RW
SocTransactionNoRespons = Nessun componente slave ha risposto alla richiesta. Controllare l'indirizzo di memoria della richiesta e la mappa della memoria del sistema.
SocTransactionNoResponsShort = Nessuna risposta
SocTransactionNoSlavesAttached = Il bus collegato al master non ha slave collegati. Per favore, allega qualche schiavo all'autobus.
SocTransactionNoSlavesAttachedShort = Nessun schiavo
SocTransactionReadOnlyAccessError = Lo slave supporta solo gli accessi in lettura su questo indirizzo
SocTransactionReadOnlyAccessErrorShort = Sola lettura
SocTransactionRegisterDoesNotExist = Slave non supporta alcun accesso a questo indirizzo
SocTransactionRegisterDoesNotExistShort = Nessun accesso
SocTransactionSuccessfull = Non si è verificato alcun errore, la transazione ha avuto successo.
SocTransactionSuccessfullShort = Il successo
SocTransactionUnknownError = Bizzarro, questo messaggio di errore non dovrebbe mai verificarsi e rappresenta un bug in logisim.
SocTransactionUnknownErrorShort = BUG!
SocTransactionWordAccesNoSupport = Slave non supporta gli accessi alle parole.
SocTransactionWordAccesNoSupportShort = Nessun accesso alle parole
SocTransactionWriteOnlyAccessError = Slave non supporta un'azione di lettura su questo indirizzo.
SocTransactionWriteOnlyAccessErrorShort = Solo scrivere
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Vuoto (senza schiavi)
SocMemMapEndAddress = Indirizzo finale:
SocMemMapSlaveName = Nome del componente:
SocMemMapStartAddress = Indirizzo di partenza:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = Si prega di selezionare un autobus a cui collegarsi
SocBusSelectAttr = Bus collegato
SocBusSelectAttrClick = Fare clic per selezionare
SocManagerNoBusses = Nessun autobus disponibile, si prega di aggiungere un bus SOC al vostro schematico
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Caricato con successo il file elf in memoria.\nIl punto di ingresso dell'eseguibile è stato impostato sul processore.\n\nImportante:\n   Poiché il file elf non ha informazioni sui vettori di eccezione\n   devi controllarli tu stesso!
SocUpMenuAsmWindow = Assemblatore aperto
SocUpMenuCpuAsmWindowTitle = assemblatore per cpu :
SocUpMenuCpuProgramWindowTitle = disassemblatore per cpu :
SocUpMenuCpuStateWindowTitle = stato del processore per la CPU :
SocUpMenuErrorReadingElfTitle = Errore nella lettura del file elf
SocUpMenuReadElf = Leggi file elfo
SocUpMenuSelectElfFile = Selezionare il file elfo da importare
SocUpMenuShowProgram = Mostra programma caricato
SocUpMenuShowState = Mostra stato della CPU
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Arrestato
SocUpSimHaltBreak = Punto di rottura
SocUpSimHaltError = Errore
SocUpSimRunning = Corsa
SocUpSimStateLabel = Stato Sim:
SocUpSimstateStart = Inizio
SocUpSimstateStop = Pausa
SocUpUnknown = Sconosciuto
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Non un file elfo a 32 o 64 bit
ElfHeaderEIDataError = Non un piccolo o grande file codificato in formato endian
ElfHeaderIncorrectEISize = La dimensione della sezione EI non è corretta.
ElfHeaderIncorrectESize = La dimensione della sezione E non è corretta.
ElfHeaderIncorrectMagic = Il file non contiene l'elf-magic corretto; probabilmente non è un elf-file
ElfHeaderNoErrors = L'intestazione è corretta
ElfHeaderReadingFileError = Errore nella lettura del file
ElfHeaderUnknownArchitecture = Architettura sconosciuta
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Intestazione del programma non trovata.
ProgHeaderReadError = Errore di lettura dell'intestazione del programma.
ProgHeaderSizeError = Disallineamento delle dimensioni nell'intestazione del programma.
ProgHeaderSuccess = Il successo
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Trovate tabelle di stringhe multiple, per il momento non supportate.
ElfSectHeadMultiSymtabError = Trovate tabelle di simboli multipli, per il momento non supportate;
ElfSectHeadNotFound = Intestazione di sezione non trovata.
ElfSectHeadReadError = Errore nella lettura dell'intestazione della sezione.
ElfSectHeadSizeError = Disallineamento delle dimensioni nell'intestazione della sezione.
ElfSectHeadStingIdxError = Errore Indice di stringa.
ElfSectHeadStingNotFound = Nome della sezione non trovato.
ElfSectHeadStingReadError = Errore nella lettura della tabella delle stringhe.
ElfSectHeadStingTypeError = Errore di tipo di stringa.
ElfSectHeadSuccess = Il successo
ElfSymTableNotFound = Impossibile trovare la tabella dei simboli.
ElfSymTableReadError = Impossibile leggere la tabella dei simboli.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim non supporta ancora i file elf a 64 bit.
ProcReadElfArchError = Il file Elf è per un processore "%s" mentre dovrebbe essere per un processore "%s".
ProcReadElfEndianMismatch = Il file elfo è "%s" mentre il processore ha richiesto "%s".
ProcReadElfErrorOpeningFile = Impossibile aprire elf-file
ProcReadElfLoadableSectionNotFound = Sezione caricabile non presente nel file elf.
ProcReadElfLoadableSectionReadError = Errore di lettura sezione caricabile.
ProcReadElfLoadableSectionSizeError = Disallineamento dimensionale nella sezione caricabile.
ProcReadElfLoadableSectionTooBig = La dimensione della sezione caricabile è maggiore di quella supportata da logisim.
ProcReadElfMemoryError = Si è verificato un errore nella scrittura in memoria di una sezione caricabile.\nAssicurarsi di avere a disposizione un componente di memoria SOC per l'area di memoria:\n%s....%s
ProcReadElfNotExecutable = Il file elf non è un eseguibile
ProcReadElfSuccess = Il successo
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Fascicoli di montaggio (.asm,.S)
AsmPanAssemble = Assemblare il codice (ALT-A)
AsmPanDocumentChangedSave = Ci sono cambiamenti nel tuo documento, salvarli?
AsmPanErrorCreateFile = Impossibile creare il file di assemblaggio.
AsmPanErrorReadingFile = Impossibile leggere il file
AsmPanNextError = Passa all'errore successivo (CTRL-N)
AsmPanOpenFile = Leggere un file (CTRL-L)
AsmPanPreviousError = Passa all'errore precedente (CTRL-P)
AsmPanReadAsmFile = Selezionare un file da leggere
AsmPanRun = Eseguire il codice (ALT-R)
AsmPanSaveAsmFile = Selezionare un file da salvare
AsmPanSaveFile = Salva file (CTRL-S)
AsmPanSaveFileAs = Salva file con nome
AsmPanSaveFirstBeforeOpen = Ci sono cambiamenti nel tuo documento\nVuoi salvarli prima di aprire un nuovo file?
AssemblerAssembleSuccess = Il successo!\nNessun errore trovato nel tuo codice.
AssemblerRunSuccess = Caricato con successo il programma in memoria.\nPer eseguire il programma, per favore, assicurati che sia così:\na) si attivano le zecche\nb) si imposta la CPU in modalità di funzionamento
AssemblerUnableToDownload = Impossibile memorizzare il programma nella memoria,\nsi assicuri di avere abbastanza memoria disponibile\nnelle posizioni di memoria corrette.
RV32imAsmLineIndicator = Linea %d di %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Rimuovere il punto di rottura
RV32imSetBreakpoint = Aggiungi punto di interruzione
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Indirizzo dell'autobus: 0x
SocTransInsAtomicRequest = Operazione atomica
SocTransInsByteAccess = Operazione byte
SocTransInsHalfWordAccess = Operazione a mezza parola (2 byte)
SocTransInsInputData = Dati da scrivere: 0x
SocTransInsInsertTransaction = Inserire la transazione nel bus
SocTransInsManual = Manuale inserito
SocTransInsReadData = Dati restituiti:
SocTransInsReadRequest = Richiesta di lettura bus
SocTransInsTransResultTitle = Risultato della transazione inserita:
SocTransInsWordAccess = Operazione Word (4 byte)
SocTransInsWriteRequest = Richiesta di scrittura bus
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Montaggio:
Rv32imBinInstruction = Opcode:
Rv32imEmptyTrace = Nessuna traccia di esecuzione disponibile
Rv32imExecutionTrace = Traccia dell'esecuzione (ultima esecuzione eseguita in alto):
Rv32imRegisterFile = File di registro:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Controllo di simulazione
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Tastiera chiara
JtagUartKeybAvailable = Dati della tastiera disponibili
JtagUartKeybData = Dati della tastiera
JtagUartKeybReadEnable = Abilita lettura da tastiera
JtagUartTtyClear = TTY chiaro
JtagUartTtyData = Dati TTY
JtagUartTtyWrite = TTY scrivere i dati
SocJtagUartComponent = Componente Jtag Uart
#
# jtaguart/JtagUartAttributes.java
#
JtagSize1024 = 1k
JtagSize128 = 128
JtagSize16 = 16
JtagSize16384 = 16k
JtagSize2048 = 2k
JtagSize256 = 256
JtagSize32 = 32
JtagSize32768 = 32k
JtagSize4096 = 4k
JtagSize512 = 512
JtagSize64 = 64
JtagSize8 = 8
JtagSize8192 = 8k
JtagUartReadIrqThreshold = Leggere la soglia IRQ
JtagUartWriteIrqThreshold = Scrivi soglia IRQ
UartJtagREADFifoSize = Leggi il formato FIFO:
UartJtagWriteFifoSize = Scrivi il formato FIFO:
#
# memory/SocMemory.java
#
SocMemBase = Base:
SocMemoryComponent = Simulatore di memoria
SocMemSizeStr = Dimensione:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Larghezza indirizzo byte:
SocMemStartAddress = Indirizzo di partenza:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Simulatore Nios2s
Nios2Dataa = Dati A
Nios2Datab = Dati B
Nios2Done = Fatto
Nios2N = N
Nios2ReadRa = Leggi Ra
Nios2ReadRb = Leggi Rb
Nios2Result = Risultato
Nios2Start = Inizio
Nios2WriteRc = Scrivi Rc
Rv32imClockInput = Ingresso orologio
Rv32imIrqInput = Ingresso IRQ %s
Rv32imResetInput = Ingresso di reset
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Vettore di rottura
rv32ExceptionVector = Vettore di eccezione
rv32imIrqWidth = Numero di linee IRQ
rv32ResetVector = Reimposta vettore
rv32StateVisible = Stato visibile:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Quattro argomenti previsti
Nios2DonePinError = Il pin non definito o in stato di errore non può continuare.\n Si prega di controllare il perno fatto.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Errore nell'esecuzione di un carico dal sistema di memoria:
LoadStoreErrorInWriteTransaction = Errore nell'esecuzione di una memorizzazione nel sistema di memoria:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Previsto un valore immediato
AssemblerExpectedNoArguments = Previsto nessun argomento
AssemblerExpectedOneArgument = Previsto un argomento
AssemblerExpectedTwoArguments = Due argomenti previsti
AssemblerExpectedZeroOrOneArgument = Previsto nessun argomento o un solo argomento
AssemblerImmediateOutOfRange = Il valore immediato è fuori intervallo
AssemblerUnknownRegister = Registro sconosciuto
Nios2AssemblerExpectedBracketedRegister = Previsto un registro tra parentesi, ad esempio (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Previsto un registro indicizzato immediato, ad es. 5(r1)
Nios2CannotUseControlRegister = Non è possibile utilizzare un registro di controllo in questo contesto
Nios2CannotUseCustomRegister = Non è possibile utilizzare un registro personalizzato in questo contesto
Nios2ExpectedControlRegister = Previsto un registro di controllo (es. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Tre argomenti previsti
AssemblerExpextedImmediateOrLabel = Previsto un valore immediato o un'etichetta
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estato
Nios2Status = condizione
RV32imBreakPointReached = L'esecuzione viene messa in pausa a causa di un punto di interruzione impostato nell'istruzione corrente.
RV32imFetchExecutionError = Errore nell'esecuzione dell'istruzione recuperata
RV32imFetchInvalidInstruction = Istruzione non valida recuperata
RV32imFetchInvInstrAsm = Istruzione non valida!
RV32imFetchTransaction = -> Recuperare l'errore di transazione.
Rv32imProgramCounter = pc:
SocHiddenForFasterSimulation = Contenuti nascosti per una simulazione più veloce
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Previsto un registro
#
# pio/PioAttributes.java
#
SicPioIrqType = Tipo Irq:
SocPioAnyEdge = Qualsiasi bordo
SocPioBidir = Porte bidirezionali (tristate)
SocPioCaptureEdge = Tipo di cattura:
SocPioDirection = Direzione:
SocPioFallingEdge = Bordo di caduta
SocPioGenIRQ = IRQ abilitato:
SocPioInout = Porte di ingresso e di uscita
SocPioInputCaptureBit = Capture bit-clearing:
SocPioInputOnly = Solo porte di ingresso
SocPioInputsSyncCapture = Catturare..... sincronizzazione:
SocPioIrQEdge = Bordo
SocPioIrqLevel = Livello
SocPioOutputIndividualBits = Bit di uscita impostato/chiaro:
SocPioOutputOnly = Solo porte di uscita
SocPioOutputResetValue = Valore di reset dell'uscita:
SocPioRisingEdge = Bordo ascendente
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Non è stato possibile creare l'intestazione e/o file c!
ExportC = Esportazione di modelli C
PioMenuBidirFunctionsRemark = /* Con le seguenti funzioni, il registro bidirezionale può essere impostato o letto.\n * a 1 indica che il bit di rispetto è un'uscita, a 0 indica che si tratta di un ingresso.\n * Nota: vengono utilizzati solo i bit %s più bassi.\n */
PioMenuCaptureAll = cancella tutti i bit nel registro di cattura indipendentemente dal valore del parametro "valore".
PioMenuCaptureAny = almeno un cambiamento da 0 a 1 o da 1 a 0
PioMenuCaptureBit = cancellare i bit nel registro di cattura che sono 1 nel parametro "valore".
PioMenuCaptureFalling = almeno un cambiamento da 1 a 0
PioMenuCaptureRising = almeno un cambiamento da 0 a 1
PioMenuEdgeCaptureRemark = /* Con le seguenti funzioni è possibile cancellare o leggere il registro di cattura dei bordi.\n * nel caso in cui il registro dei bordi sia letto un 1 su una posizione indica che il simbolo\n * Il rispettivo ingresso ha il cappello %s,\n * altrimenti il rispettivo ingresso non è cambiato.\n *\n * La scrittura su questo registro sarà %s.\n * Nota: vengono utilizzati solo i bit %s più bassi.\n */
PioMenuInputDataFunctionRemark = /* Con la seguente funzione i valori di ingresso del PIO possono essere\n # Leggi..... #\n * Questa funzione restituisce il rispettivo valore\n * Nota: sono validi solo i bit %s più bassi.\n */
PioMenuIrqEdge = bit corrispondente nel registro di cattura
PioMenuIrqLevel = ingresso corrispondente
PioMenuMaskFunctionsRemark = /* Con le seguenti funzioni è possibile impostare o leggere il registro maschera di interruzione.\n * Un 1 su una posizione specifica indica che verrà generato un interrupt.\n * se la %s è uguale a 1.\n * Nota: vengono utilizzati solo i bit %s più bassi.\n */
PioMenuOutClearRemark = /* Con la seguente funzione i bit che sono 1 nel parametro "valore" forzerà i bit che sono 1 nel parametro "valore\n * l'uscita corrispondente a 0\n * Nota: vengono utilizzati solo i bit %s più bassi.\n */
PioMenuOutputDataFunctionRemark = /* Con la seguente funzione i valori di uscita del PIO possono essere\n # Set...... #\n * Questa funzione prende il nuovo valore di uscita come parametro "valore".\n * Nota: sono validi solo i bit %s inferiori del parametro "valore" fornito.\n */
PioMenuOutSetRemark = /* Con la seguente funzione i bit che sono 1 nel parametro "valore" forzerà i bit che sono 1 nel parametro "valore\n * l'uscita corrispondente a 1\n * Nota: vengono utilizzati solo i bit %s più bassi.\n */
SelectDirectoryToStoreC = Impostare la directory per memorizzare i modelli C
SuccesCreatingHeaderAndCFile = creato con successo i file:\n%s\ne\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Perni bidirezionali
SocPioComponent = Espansore di ingresso/uscita parallela
SocPioInputPinx = Bit di ingresso %s
SocPioInputs = Perni di ingresso
SocPioIrqOutput = Uscita Irq
SocPioOutputPinx = Bit di uscita %s
SocPioOutputs = Perni di uscita
SocPioResetInput = Ingresso di reset
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Simulatore Risc V IM simulatore
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = Uno o due argomenti previsti
Rv32imAssemblerExpectedTwoOrThreeArguments = Due o tre argomenti previsti
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Attualmente il richiamo ambientale e i punti di interruzione non sono stati implementati.
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Previsto un registro tra parentesi, ad esempio (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Previsto un registro indicizzato immediato, ad es. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Opcode asm non supportato
Rv32imMOINotImplmented = Attualmente le istruzioni per l'ordine di memoria non sono state implementate
#
# Soc.java
#
SocBusComponent = Simulatore di bus SOC
socLibrary = Componenti del sistema su chip
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Opcode sconosciuto
UnknownInstruction = Istruzione sconosciuta
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Ipotizzando l'indirizzo più basso con un'istruzione come punto di ingresso.\nPer essere sicuri che la vostra cpu inizi l'esecuzione al giusto indirizzo\nsi prega di aggiungere un'etichetta chiamata '_start' sul posto\ndove la tua CPU dovrebbe iniziare ad eseguire il programma.
AssemblerCannotUseInsideMacro = Questo costrutto non può essere utilizzato all'interno di una definizione di macro
AssemblerEndOfMacroNotFound = Non è riuscito a trovare la fine della macro definizione
AssemblerExpectedMacroName = Previsto un nome della macro
AssemblerExpectedMacroNrOfParameters = Previsto il numero di parametri macro
AssemblerExpectingLabelIdentifier = Aspettarsi un'etichetta
AssemblerMissingLabelBefore = Per questo operatore dovrebbe essere un'etichetta
AssemblerNoExecutableSection = Non sono state trovate istruzioni che possono essere eseguite.
AssemblerReguiresNumberAfterMath = Dopo un'operazione matematica dovrebbe seguire un numero
AssemblerUnknowCharacter = Carattere sconosciuto
AssemblerWrongClosingBracket = Questa staffa di chiusura non è supportata
AssemblerWrongOpeningBracket = Questa staffa di apertura non è supportata
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Impossibile determinare un indirizzo per questa etichetta
AssemblerCouldNotFindValueForDefine = Non è stato possibile trovare una definizione di questo parametro
AssemblerDivZero = Dividere per errore zero
AssemblerExpectedImmediateValueAfterMath = Previsto un valore immediato dopo un'operazione matematica
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = I nomi delle etichette devono essere univoci, trovate definizioni multiple di questa etichetta
AssemblerDuplicatedName = Non è possibile utilizzare lo stesso nome per un .equ e un'etichetta
AssemblerDuplicatedSectionError = I nomi delle sezioni devono essere univoci, trovate sezioni multiple con questo nome
AssemblerExpectedLabel = Previsto un'etichetta
AssemblerExpectedLabelAndNumber = Prevista un'etichetta seguita da un valore immediato
AssemblerExpectedParameter = Previsto un parametro in questa posizione
AssemblerExpectingNumber = Previsto un numero
AssemblerExpectingPositiveNumber = Previsto un numero positivo
AssemblerExpectingSectionName = Aspettarsi un nome per questa sezione
AssemblerExpectingString = Previsto una stringa
AssemblerMacroIncorrectNumberOfParameters = Numero errato di parametri macro specificati
AssemblerOverlappingSections = Questa sezione si sovrappone ad un'altra sezione
AssemblerUnknownIdentifier = Non conosco questo identificatore
AssemblerUnknownLabel = Questa etichetta non è stata definita, quindi non posso usarla.
AssemblerUnsupportedAssemblerInstruction = Questa istruzione dell'assemblatore non è nota
AssemblerValueOutOfRange = Il valore è fuori intervallo
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Le macro si chiamano a vicenda causando una situazione di stallo.
AssemblerMacroCannotUseRecurency = Macro si sta definendo causando una situazione di stallo
AssemblerMacroParameterNotDefined = Questo parametro macro non è definito, controlla il numero di parametri nella tua definizione di macro
#
# vga/SocVgaShape.java
#
SocVgaComponent = Schermo VGA
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Pixel buffer Indirizzo:
VgaInitialDisplayMode = Modalità iniziale:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Software 1024x768:
VgaSoft160x120 = Software 160x120:
VgaSoft320x240 = Software 320x240:
VgaSoft640x480 = Software 640x480:
VgaSoft800x600 = Software 800x600:
VgaStartAddress = Indirizzo di base:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* Con le seguenti funzioni è possibile manipolare il modo vga.\n * La lettura della modalità vga restituisce le modalità supportate (vedi sopra per la definizione delle possibili modalità).\n * La scrittura di una modalità supportata cambierà la modalità di visualizzazione del display VGA.\n */


