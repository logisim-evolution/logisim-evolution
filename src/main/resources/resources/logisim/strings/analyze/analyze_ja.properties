#
# data/CsvInterpretor.java
#
CsvBitNotSpecified = csv ファイル '%s' の行 %d に変数 '%s' のビット %d が含まれていません。
CsvDuplicatedBit = csv ファイル '%d' の行 %d に変数 '%s' のビット %d が 2 倍含まれています。
CsvDuplicatedVar = csv ファイル '%s' の行 %d に変数 '%s' が複数回含まれています。
CsvIncorrectBitOrder = csv ファイル '%s' の行 %d に変数 '%s' の誤ったビット列が含まれています。
CsvIncorrectEmpty = csv ファイル '%s' の行 %d に位置 %d に誤った空フィールドが含まれています。
CsvIncorrectLine = csv ファイル '%s' の行 %d には必要な %d ではなく %d 個のエントリがあります。
CsvIncorrectVarName = csv ファイル '%s' の行 %d に誤ったフォーマットのラベル '%s' が含まれています。
CsvInvalidEntry = csv ファイル '%s' の行 %d にフィールド %d に無効なエントリ '%s' が含まれています。
CsvNoEntries = ファイル "%s" にはエントリが含まれていません。
CsvNoInputsFound = csv ファイル '%s' の行 %d に入力が含まれていません。
CsvNoSepFound = csv ファイル '%s' の行 %d にセパレータ・フィールドが含まれていません。
CsvNotEnoughEmpty = csv ファイル '%s' の行 %d に変数 '%s' の後に十分な空のフィールドがありません。
#
# data/ExpressionRenderData.java
#
expressionEmpty = (空)
#
# file/AnalyzerTexWriter.java
#
latexBabelLanguage = 英語
latexEmpty = 空の分析器
latexEmptyText = このドキュメントが生成された時点では、分析器には入力変数や出力変数がなかったため、表示するものは何もありません。
latexHeader = %s で Logisim-evolution が生成したドキュメントです。
latexIntroduction = はじめに
latexIntroductionText = このドキュメントはlogisim-evolutionによって生成されました。この TeX ソースの任意の部分は、あなた自身のドキュメントで問題なく使用することができます。この生成されたTeXソースの全部または一部を使いたい場合は、(1)必要なパッケージを忘れずに入れ、(2)このソースはlogisim-evolutionによって生成されたものであることを明記してください。
latexKarnaugh = カルノー図
latexKarnaughEmpty = 空のカルノー図
latexKarnaughFilledIn = カルノー図に充填されている
latexKarnaughFilledInGroups = カバー付きのカルノー図で埋め尽くされた
latexKarnaughText = このセクションでは、指定された関数のカルノー図のさまざまなバージョンを表示します。
latexKarnaughToBig = %d 以上の入力変数を持つカルノー図を表示できません。
latexMinimal = 最小式
latexTruthTable = 真実のテーブル
latexTruthTableComplete = 完全な真理値テーブル
latexTruthTableCompact = コンパクト化された真理値テーブル
latexTruthTableText = ページに表示するにはテーブルが大きすぎるかもしれません。生成時には、ページの幅/高さに対するテーブルのサイズの計算は行われていません。
latexTruthTableToBig = \\\\~\\\\真理値テーブルには%d個以上のエントリがあり、ここに表示するのは意味がありません。
tableLatexFilter = Logisim-evolution TeX document (*.tex)
#
# file/TruthtableCsvFile.java
#
tableCsvFileFilter = Logisim-evolution真理値表 (*.csv)
#
# file/TruthtableTextFile.java
#
tableParseErrorMessage = エラーを無視してもう一度やってみますか？
tableParseErrorTitle = Error Parsing Truth Table
tableRemark1 = # 真理値表
tableRemark2 = # 回路 %s から生成されます。
tableRemark3 = # %sでエクスポートされます。
tableRemark4 = # フォーマットのヒントと注意事項:\n# * このファイルを編集して、Logisimにインポートすることができます！\n# *  '#'の後のものはコメントなので無視されます。\n# * 空行と区切り線(例: ~~~~~~)は、無視されます。\n# * 列名は、シンプルに(スペース、句読点、その他)にしてください。\n# * 'Name[N..0]'はN+1ビットの変数を示します\n#  一方で 'Name' は、それ自体が１ビットの変数を示しています。\n# * 入力、出力ビットどちらの場合も、'x'か'-'を使って、"don't care "を表すことができます。\n# * バイナリ(例: '10100011xxxx')表記か、16進数(例: 'C3x')表記か。Logisimは、どちらがどちらかを判断します。
tableTxtFileFilter = Logisim-evolution 真理値表 (*.txt)
#
# gui/Analyzer.java
#
analyzePleaseWait = お待ちください
analyzerWindowTitle = 組合せ解析
buildCircuitButton = 回路を構築する
exportLatexButton = TeXのエクスポート
exportTableButton = テーブルのエクスポート
expressionTab = 式
expressionTabTip = 出力の式を表示して操作します
importTableButton = テーブルのインポート
inputsOutputsTab = 入力 & 出力
inputsOutputsTabTip = 入力変数と出力変数のセットを表示して編集します。
minimizedTab = 最小化された
minimizedTabTip = 真理値表に対応する最小化された式を表示します。
tableTab = テーブル
tableTabTip = 真理値表を表示して操作します。
# ==> minimizeMintermsButton =
# ==> minimizeMaxtermsButton =
#
# gui/MinimizeButton.java
#
# ==> OptimizeLongTimeWarning = 
# ==> minimizeFunctionTitle = 
# ==> minimizeDone = 
#
# model/Implicant.java
#
# ==> implicantOutputName =
# ==> implicantGroupSize =
# ==> implicantNoneFound =
# ==> implicantColumRowReduction =
# ==> implicantGreedy =
#
# gui/BuildCircuitButton.java
#
buildConfirmReplaceMessage = 回路 %s を置換してもよろしいですか？
buildConfirmReplaceTitle = 置換の確認
buildDialogErrorTitle = 回路を構築できませんでした。
buildDialogTitle = B回路を構築する
buildDuplicatedNameError = 回路名は入力または出力の名前と同じにはできません。別の名前を指定してください。
buildNameLabel = 回路名:
buildNandsLabel = NANDゲートのみ使用
buildNeedCircuitError = 回路名を指定する必要があります。
buildNeedProjectError = 接続先のプロジェクトを選択する必要があります。
buildProjectLabel = 送信先のプロジェクト:
buildTwoInputsLabel = 2入力ゲートのみを使用する。
replaceCircuitAction = 回路の置換
# ==> zeroOrNotOptimizedMessage = 
#
# gui/CsvReadParameterDialog.java
#
ConfirmCsvParameters = 続ける
cvsFilePreview = 読み込んだファイルの最初の4行のプレビュー:
seperatorSpace = {スペース}
SeperatorTab = {タブ}
UsedQuotesInFile = csvファイルで使用される "クォート "文字を選択します:
UsedSeperatorInFile = csvファイルで使用する"セパレータ"文字を選択します:
#
# gui/ExportLatexButton.java
#
cantWriteMessage = ファイルを書き込めません: %s
confirmOverwriteMessage = ファイル %s を上書きしてもよろしいですか？
confirmOverwriteTitle = 上書きの確認
notFileMessage = ファイルではありません: %s
saveButton = 真理値表のエクスポート
saveErrorTitle = ファイルの保存エラー
#
# gui/ExpressionTab.java
#
cantImportFormatError = このタイプのデータをインポートできません
outputExpressionEdit = 出力式（ダブルクリックで編集）:
#
# gui/ImportTableButton.java
#
cantReadMessage = ファイルを読み込めません: %s
DoNotKnowHowto = ファイル '%s' (拡張子は .txt または .csv である必要があります) の読み書き方法がわかりません。
openButton = 真理値表のインポート
openErrorTitle = ファイルの読み取りエラー
#
# gui/KarnaughMapPanel.java
#
karnaughNoInputsError = 利用可能な入力がありません。
karnaughNoOutputError = 選択された出力がありません。
# ==> karnaughTooFewInputsError =
karnaughTooManyInputsError = テーブルの入力が多すぎます。
NoSelectedKmapGroup = 選択されたグループがありません。
SelectedKmapGroup = 選択されたグループです:
#
# gui/MinimizedTab.java
#
expressionAltLogicrepresentation = 代替論理
expressionCalc = 式を計算する
expressionLogicrepresentation = 論理
expressionMathrepresentation = 算術
ExpressionNotation = 記法:
expressionProgbitsrepresentation = ビットによるプログラミング
expressionProgboolsrepresentation = ブーリアンを使ったプログラミング
KMapLinedStyle = 線を引かれた
KmapNumberedStyle = 番号付けされた
KmapStyle = スタイル:
minimizedFormat = フォーマット:
minimizedProductOfSums = 和の積
minimizedSetButton = 式として設定
minimizedSumOfProducts = 商品の合計
#
# gui/OutputSelector.java
#
outputSelectLabel = 出力:
#
# gui/TableTab.java
#
tableCompact = 重複した行を折りたたむ
tableExpand = すべての行を表示
tableNoInputs = (入力なし)
tableNoOutputs = (出力なし)
tableRowsShown = 表示されている %d 行の %d
#
# gui/TableTabCaret.java
#
tabcaretCompactRows = 行のコンパクト化
#
# gui/TableTabClip.java
#
clipPasteEndError = クリップボードがテーブルの端を超えてしまいます。
clipPasteErrorTitle = 貼り付けエラー
clipPasteSizeError = 貼り付け領域はクリップボードと同じサイズでなければなりません。
clipPasteSupportedError = クリップボードの内容をエディタに貼り付けることができません。
#
# gui/VariableTab.java
#
inputVariables = 入力変数
outputVariables = 出力変数
variableClickToAdd = 新しい変数を追加するためにクリックします。
variableDuplicateError = 名前が既存の変数と重複しています。
variableMaximumError = (%s の最大サイズに達しました。)
variablePartError = 名前に '%s' を含めることはできません。
variableRangeFinalPar = 範囲: LSB インデックスの直後の ] が見つかりません。
variableRangeInvalChar = 範囲: ]を閉じた後の無効な文字
variableRangeMSBWrong = 範囲: 開始 [ の後に数字が続くべきである
variableRangeStartPar = 範囲: 開始の [　が見つかりません
variableRangeWrongLB = 範囲: MSBインデックスはLSBインデックスより大きいか、LSBインデックスと同等でなければなりません。
variableRangeWrongSep = 範囲: MSBインデックスとLSBインデックスは、".." で区切られていなければなりません。
variableStartError = 名前は文字で始まる必要があります。
#
# model/Entry.java
#
busError = 回路内の出力値が競合しています。
oscillateError = 回路が発振しています。
#
# model/Parser.java
#
badVariableName = "%s" は入力変数ではありません。
implicitAndOperator = (暗黙のAND)
invalidCharacterError = 認識できない文字: '%s'
lparenMissingError = 開く括弧に一致するものがありません。
missingBraceError = 一致する中括弧がありません: "%s"
missingIdentifierError = 添え字の前に識別子がありません: "%s"
missingLeftOperandError = オペレータ "%s" の左オペランドが見つかりません。
missingRightOperandError = オペレータ "%s" の右オペランドが見つかりません。
missingSubscriptError = 添え字が見つかりません: "%s"
rparenMissingError = 閉じ括弧に一致するものがありません.
unexpectedApostrophe = 予期せぬアポストロフィ ("'")
unexpectedAssignmentError = 予期しない代入演算子です: "%s"
#
# model/Var.java
#
badVariableBitFormError = 変数名は 'name[i]' 形式でなければなりません。
badVariableColonError = 変数名が ':' の前になければなりません。
badVariableIndexError = 変数のビットインデックスが整数でなければなりません。
variableFormat = 変数は'name[N..0]形式でなければなりません。
variableTooMuchBits = 変数は32ビット以上の幅を持つことはできません。
