#
# data/CsvInterpretor.java
#
CsvBitNotSpecified = La ligne %d du fichier csv ‹ %s › ne contient pas le bit %d de la variable ‹ %s ›, abandon.
CsvDuplicatedBit = La ligne %d du fichier csv ‹ %s › contient le bit %d en doublon de la variable ‹ %s ›, abandon.
CsvDuplicatedVar = La ligne %d du fichier csv ‹ %s › contient plusieurs fois la variable ‹ %s ›, abandon.
CsvIncorrectBitOrder = La ligne %d du fichier csv ‹ %s › contient une séquence de bits incorrecte pour la variable ‹ %s ›, abandon.
CsvIncorrectEmpty = La ligne %d du fichier csv ‹ %s › contient un champ vide incorrect à la position %d, abandon.
CsvIncorrectLine = La ligne %d du fichier csv ‹ %s › comporte %d entrées au lieu des %d obligatoires, abandon.
CsvIncorrectVarName = La ligne %d du fichier csv ‹ %s › contient l’étiquette formattée incorrecte ‹ %s ›, abandon
CsvInvalidEntry = La ligne %d du fichier csv ‹ %s › contient une entrée non valide ‹ %s › dans le champ %d, abandon.
CsvNoEntries = Le fichier « %s » ne contient aucune entrée, abandon.
CsvNoInputsFound = La ligne %d du fichier csv ‹ %s › ne contient aucune entrée, abandon.
CsvNoSepFound = La ligne %d du fichier csv ‹ %s › ne contient aucun champ séparateur, abandon.
CsvNotEnoughEmpty = La ligne %d du fichier csv ‹ %s › ne contient pas assez de champs vides après la variable ‹ %s ›, abandon.
#
# data/ExpressionRenderData.java
#
expressionEmpty = (vide)
#
# file/AnalyzerTexWriter.java
#
latexBabelLanguage = french
latexEmpty = Analyseur vide
latexEmptyText = Comme l’analyseur n’avait pas de variables d’entrée et/ou de sortie au moment où ce document a été généré, rien ne s’affiche.
latexHeader = Document généré par Logisim-evolution sur %s
latexIntroduction = introduction
latexIntroductionText = Ce document a été généré par Logisim-evolution. Toute partie des sources TeX peut être utilisée dans vos propres documents sans aucun problème. Si vous souhaitez utiliser tout/partie des sources TeX générées, veuillez (1) ne pas oublier d’inclure les packages requis et (2) inclure une remarque indiquant que cette source a été générée par Logisim-evolution.
latexKarnaugh = Table de Karnaugh
latexKarnaughEmpty = Tables de Karnaugh vides
latexKarnaughFilledIn = Rempli dans les tables de Karnaugh
latexKarnaughFilledInGroups = Rempli dans les tables de Karnaugh avec des couvertures
latexKarnaughText = Cette section présente différentes versions des tables de Karnaugh des fonctions données.
latexKarnaughToBig = Impossible d’afficher les tables de Karnaugh avec plus de %d entrées.
latexMinimal = Expressions minimales
latexTruthTable = Table de vérité
latexTruthTableComplete = Table de vérité complète
latexTruthTableCompact = Table de vérité compactée
latexTruthTableText = Le tableau peut être trop gros pour être affiché sur la page. Au moment de la génération, aucun calcul n’a été effectué sur la taille du tableau par rapport à la largeur/hauteur de la page.
latexTruthTableToBig = \\\\~\\\\La table de vérité a plus de %d entrées, il n’y a pas de raison de l’afficher ici.
tableLatexFilter = Document TeX Logisim-evolution (*.tex)
#
# file/TruthtableCsvFile.java
#
tableCsvFileFilter = Table de vérité Logisim-evolution (*.csv)
#
# file/TruthtableTextFile.java
#
tableParseErrorMessage = Ignorer les erreurs et réessayer ?
tableParseErrorTitle = Erreur d’analyse de la table de vérité
tableRemark1 = # Table de vérité
tableRemark2 = # Générée à partir du circuit %s
tableRemark3 = # Exportée dans %s
tableRemark4 = # Conseils et remarques sur la mise en forme :\n# * Vous pouvez modifier ce fichier, puis le réimporter dans Logisim !\n# * Tout ce qui suit un ‹ # › correspond à un commentaire et sera ignoré.\n# * Les lignes vides et les lignes de séparation (par exemple : ~~~~~~) sont ignorées.\n# * Utilisez des noms de colonne simples (sans espaces, ni ponctuation, etc.)\n# * ‹ Nom[N..0] › indique une variable de N + 1 bits, alors que\n# ‹ Nom › tout seul indique une variable de 1 bit.\n# * Vous pouvez utiliser ‹ x › ou ‹ - › pour indiquer \« indifférent\ » pour les\n# bits d’entrée et de sortie.\n# * Vous pouvez utiliser la notation binaire (par exemple, ‹ 10100011xxxx ›) ou\n# ou hexadécimale (par exemple, ‹ C3x ›). Logisim déterminera la notation utilisée.
tableTxtFileFilter = Table de vérité Logisim-evolution (*.txt)
#
# gui/Analyzer.java
#
analyzePleaseWait = Veuillez patienter
analyzerWindowTitle = Analyse combinatoire
buildCircuitButton = Construire le circuit
exportLatexButton = Exporter TeX
exportTableButton = Exporter table
expressionTab = Expression
expressionTabTip = Visualiser et manipuler les expressions de sortie.
importTableButton = Importer table
inputsOutputsTab = Entrées & Sorties
inputsOutputsTabTip = Afficher et modifier l’ensemble des variables d’entrée et de sortie.
minimizedTab = Karnaugh
minimizedTabTip = Visualiser les tables de Karnaugh pour chaque entrée.
tableTab = Table
tableTabTip = Visualiser et manipuler la table de vérité.
minimizeMintermsButton = Optimiser les mintermes
minimizeMaxtermsButton = Optimiser les maxtermes
#
# gui/MinimizeButton.java
#
OptimizeLongTimeWarning = Attention, l’optimisation des fonctions logiques avec ce nombre d’entrées peut prendre beaucoup de temps (des heures) !\nVous voulez continuer ?
minimizeFunctionTitle = Optimisation des fonctions logiques
minimizeDone = L’optimisation de la fonction logique est terminée. Cliquez ici pour fermer la fenêtre.
#
# model/Implicant.java
#
implicantOutputName = Optimisation de la sortie : %s
implicantGroupSize = Trouver des nombres premiers de taille : %d
implicantNoneFound = Aucun
implicantColumRowReduction = Recherche de nombres premiers essentiels par réduction colonne-rangée :
implicantGreedy = Utilisation de l’algorithme glouton pour choisir les derniers nombres premiers essentiels :
#
# gui/BuildCircuitButton.java
#
buildConfirmReplaceMessage = Êtes-vous sûr de vouloir remplacer le circuit %s ?
buildConfirmReplaceTitle = Confirmer le remplacement
buildDialogErrorTitle = Impossible de construire le circuit
buildDialogTitle = Construire le circuit
buildDuplicatedNameError = Le nom du circuit ne peut pas être identique au nom d’une entrée ou d’une sortie. Veuillez spécifier un autre nom.
buildNameLabel = Nom du circuit :
buildNandsLabel = Utiliser des ports NAND uniquement
buildNeedCircuitError = Vous devez définir un nom de circuit.
buildNeedProjectError = Vous devez sélectionner un projet de destination.
buildProjectLabel = Projet de destination :
buildTwoInputsLabel = Utiliser des portes à deux entrées uniquement
replaceCircuitAction = Remplacer le circuit
zeroOrNotOptimizedMessage = La/les fonction(s) logique(s) est/sont indifférente(s) ou non optimisée(s). Impossible de construire le circuit.\nVeuillez fournir une (des) fonction(s) valide(s) ou utiliser le bouton d’optimisation.
#
# gui/CsvReadParameterDialog.java
#
ConfirmCsvParameters = Continuer
cvsFilePreview = Aperçu des quatre premières lignes du fichier lu :
seperatorSpace = {espace}
SeperatorTab = {tab}
UsedQuotesInFile = Sélectionnez le caractère « quote » utilisé dans le fichier csv :
UsedSeperatorInFile = Sélectionnez le caractère « séparateur » utilisé dans le fichier csv :
#
# gui/ExportLatexButton.java
#
cantWriteMessage = Impossible d'écrire le fichier : %s
confirmOverwriteMessage = Êtes-vous sûr de vouloir écraser le fichier %s ?
confirmOverwriteTitle = Confirmer l'écrasement
notFileMessage = Pas un fichier :%s
saveButton = Exporter la table
saveErrorTitle = Erreur d’enregistrement du fichier
#
# gui/ExpressionTab.java
#
cantImportFormatError = Impossible d’importer ce type de données
outputExpressionEdit = Expressions de sortie (double-cliquez pour éditer) :
#
# gui/ImportTableButton.java
#
cantReadMessage = Impossible de lire le fichier : %s
DoNotKnowHowto = impossible de lire ou écrire des fichiers ‹ %s › (l’extension doit être .txt ou .csv).
openButton = Exporter la table de vérité
openErrorTitle = Erreur de lecture du fichier
#
# gui/KarnaughMapPanel.java
#
karnaughNoInputsError = Aucune entrée disponible.
karnaughNoOutputError = Aucune entrée sélectionnée.
karnaughTooFewInputsError = Trop peu d’entrées pour la table.
karnaughTooManyInputsError = Trop d’entrées pour la table.
NoSelectedKmapGroup = Aucun groupe sélectionné.
SelectedKmapGroup = Groupe sélectionné :
#
# gui/MinimizedTab.java
#
expressionAltLogicrepresentation = Logique alternative
expressionCalc = Calculer une expression
expressionLogicrepresentation = Logique
expressionMathrepresentation = Mathématique
ExpressionNotation = Notation :
expressionProgbitsrepresentation = Programmation avec des bits
expressionProgboolsrepresentation = Programmation avec des booléens
KMapLinedStyle = Doublé
KmapNumberedStyle = Numéroté
KmapStyle = Style :
minimizedFormat = Format :
minimizedProductOfSums = Produit des sommes
minimizedSetButton = Définir comme expression
minimizedSumOfProducts = Somme des produits
#
# gui/OutputSelector.java
#
outputSelectLabel = Sortie :
#
# gui/TableTab.java
#
tableCompact = Réduire les lignes dupliquées
tableExpand = Afficher toutes les lignes
tableNoInputs = (pas d’entrées)
tableNoOutputs = (pas de sorties)
tableRowsShown = %d de %d lignes affichées
#
# gui/TableTabCaret.java
#
tabcaretCompactRows = Compacter les lignes
#
# gui/TableTabClip.java
#
clipPasteEndError = Le presse-papiers excède la fin de la table.
clipPasteErrorTitle = Erreur de collage
clipPasteSizeError = La destination doit être de la même taille que le presse-papiers.
clipPasteSupportedError = Le contenu du presse-papiers ne peut pas être collé dans l'éditeur.
#
# gui/VariableTab.java
#
inputVariables = Variables d’entrée
outputVariables = Variables de sortie
variableClickToAdd = Cliquez pour ajouter une nouvelle variable
variableDuplicateError = Une variable du même nom existe déjà.
variableMaximumError = (Taille maximum de %s atteinte.)
variablePartError = Le nom ne peut pas contenir ‹ %s ›.
variableRangeFinalPar = Plage : ] manquant après l’index LSB
variableRangeInvalChar = Plage : caractères non valides après le ]
variableRangeMSBWrong = Plage : le [ doit être suivi d’un nombre
variableRangeStartPar = Plage : [ manquant
variableRangeWrongLB = Plage : l’index MSB doit être supérieur ou égal à l’index LSB
variableRangeWrongSep = Plage : l’index MSB et l’index LSB doivent être séparés par « .. »
variableStartError = Le nom doit commencer par une lettre.
#
# model/Entry.java
#
busError = Conflit entre les valeurs de sortie du circuit.
oscillateError = Le circuit oscille.
#
# model/Parser.java
#
badVariableName = %s n’est pas une variable d’entrèe.
implicitAndOperator = (AND Implicite)
invalidCharacterError = Caractères non reconnus : %s
lparenMissingError = Aucune parenthèse ouvrante correspondante.
missingBraceError = Aucune accolade correspondante : « %s »
missingIdentifierError = Identifiant manquant avant l’indice : « %s »
missingLeftOperandError = Opérande gauche de %s manquante.
missingRightOperandError = Opérande droite de %s manquante.
missingSubscriptError = Indice manquant : « %s »
rparenMissingError = Parenthèse fermante manquante.
unexpectedApostrophe = Apostrophe inattendue (« ' »)
unexpectedAssignmentError = Opérateur d’affectation inattendu : « %s »
#
# model/Var.java
#
badVariableBitFormError = Le nom de la variable doit être de la forme ‹ nom[i] ›
badVariableColonError = Le nom de la variable doit apparaître avant ‹ : ›
badVariableIndexError = L’index du bit de la variable doit être un entier
variableFormat = Les variables doivent être de la forme ‹ nom[N..0] ›
variableTooMuchBits = Les variables ne peuvent pas faire plus de 32 bits
