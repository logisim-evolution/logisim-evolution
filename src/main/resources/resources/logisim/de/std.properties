#
# arith/Adder.java
#
adderCarryInTip = Übertragseingang: wenn 1 wird eine weitere 1 zur Summe addiert
adderCarryOutTip = Übertragsausgang: ist 1, wenn die Summe die verfügbare Bitbreite übersteigt
adderComponent = Addierer
adderInputTip = Eingang: einer der Summanden
adderOutputTip = Ausgang: die Summe der Eingänge (plus Übertragseingang)
#
# arith/Arithmetic.java
#
arithmeticLibrary = Arithmetik
#
# arith/BitAdder.java
#
bitAdderComponent = Bit-Zähler
bitAdderInputTip = Eingang: die zu zählenden Bits
bitAdderOutputManyTip = Ausgang: die Anzahl der 1-Bits an den Eingängen
gateInputsAttr = Anzahl der Eingänge
#
# arith/BitFinder.java
#
bitFinderComponent = Bit-Finder
bitFinderFindLabel = find
bitFinderHighLabel = high
bitFinderHighOption = Oberste %s
bitFinderIndexHighTip = Index: Index der höchstwertigsten %s des Eingangs
bitFinderIndexLowTip = Index: Index der niederwertigsten %s des Eingangs
bitFinderInputTip = Eingang: die zu durchsuchenden Bits
bitFinderLowLabel = low
bitFinderLowOption = Unterste %s
bitFinderPresentTip = Gefunden: ist 1, wenn der Eingang eine %s enthält
bitFinderTypeAttr = Type
#
# arith/Comparator.java
#
comparatorComponent = Komparator
comparatorEqualTip = Gleich: ist 1, wenn A gleich B ist
comparatorGreaterTip = Größer: ist 1, wenn A größer als B ist
comparatorInputATip = A: die Zahl vor dem Vergleichsoperator
comparatorInputBTip = B: die Zahl nach dem Vergleichsoperator
comparatorLessTip = Kleiner: ist 1, wenn A kleiner als B ist
comparatorType = Zahlentyp
twosComplementOption = Zweierkomplement
unsignedOption = ohne Vorzeichen
#
# arith/Divider.java
#
dividerComponent = Teiler
dividerDividendLowerTip = Dividend (unten): die untere Hälfte der zu teilenden Zahl
dividerDividendUpperTip = Dividend (oben): die obere Hälfte der zu teilenden Zahl
dividerDivisorTip = Divisor: die Zahl, durch die zu teilen ist
dividerOutputTip = Ausgang: das Ergebnis der Division von Dividend durch Divisor
dividerRemainderOutput = rem
dividerRemainderTip = Rest: der Rest der Division (Dividend - Ausgang * Divisor)
dividerUpperInput = upper
#
# arith/Multiplier.java
#
multiplierCarryInTip = Übertragseingang: zum Ergebnis zu addierender Wert
multiplierCarryOutTip = Übertragsausgang: die höherwertigen Bits des Produkts
multiplierComponent = Multiplizierer
multiplierInputTip = Eingang: eine der zu multiplizierenden Zahlen
multiplierOutputTip = Ausgang: das Produkt der Eingänge plus Übertragseingang
#
# arith/Negator.java
#
negatorComponent = Negator
negatorInputTip = Eingang: die zu negierende Zahl
negatorOutputTip = Ausgang: das Zweierkomplement des Eingangs
#
# arith/Shifter.java
#
shiftArithmeticRight = Arithmetisch nach rechts
shifterComponent = Bitschieber
shifterDistanceTip = Distanz: wie weit der Eingang zu schieben ist
shifterInputTip = Eingang: die zu schiebenden Bits
shifterOutputTip = Ausgang: Ergebnis der Schiebung des Eingangs
shifterShiftAttr = Schiebertyp
shiftLogicalLeft = Logisch nach links
shiftLogicalRight = Logisch nach rechts
shiftRollLeft = Rotieren nach links
shiftRollRight = Rotieren nach rechts
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Leiheingang: wenn 1 wird eine weitere 1 vom Ergebnis abgezogen
subtractorBorrowOutTip = Leihausgang: ist 1, wenn die Differenz ngativ ist
subtractorComponent = Subtrahierer
subtractorMinuendTip = Minuend: die Zahl, von der abzuziehen ist
subtractorOutputTip = Ausgang: die Differenz zwischen Minuend und Subtrahend
subtractorSubtrahendTip = Subtrahend: die Zahl, die abgezogen wird
#
# base/Base.java
#
baseLibrary = Basis
#
# base/Text.java
#
textComponent = Beschriftung
textFontAttr = Zeichensatz
textHorzAlignAttr = Horizontale Ausrichtung
textHorzAlignCenterOpt = Zentriert
textHorzAlignLeftOpt = Links
textHorzAlignRightOpt = Rechts
textTextAttr = Text
textVertAlignAttr = Vertikale Ausrichtung
textVertAlignBaseOpt = Basis
textVertAlignBottomOpt = Unten
textVertAlignCenterOpt = Zentriert
textVertAlignTopOpt = Oben
#
# base/VhdlParser.java
#
CannotFindEntityException = Die Entitätserklärung kann nicht gefunden werden.
emptySourceException = Leere Inhalte können nicht analysiert werden.
genericDeclarationException = Syntax illegaler Generika
genericTypeException = Nicht unterstützter Generikatyp
genericValueException = Standardwert für nicht erkannte Generika
invalidTypeException = Ungültiger Porttyp
portDeclarationException = Illegale Port-Syntax
#
# Builtin.java
#
builtinLibrary = Eingebaut
#
# gates/AndGate.java
#
andGateComponent = AND Gatter
#
# gates/Buffer.java
#
bufferComponent = Puffer
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Tristate-Puffer
controlledControlOption = Position der Steuerleitung
controlledInverterComponent = Tristate-Inverter
controlledLeftHanded = linke Seite
controlledRightHanded = rechte Seite
#
# gates/EvenParityGate.java
#
evenParityComponent = Gerade Parität
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/hochohmig
gateOutputAttr = Ausgabewert
gateOutputZ1 = hochohmig/1
gateSizeNormalOpt = Mittel
xorBehaviorAttr = Verhalten bei mehreren Eingängen
xorBehaviorOdd = Falls eine ungerade Anzahl gesetzt ist
xorBehaviorOne = Falls genau ein Eingang gesetzt ist
#
# gates/Gates.java
#
gatesLibrary = Gatter
#
# gates/NandGate.java
#
nandGateComponent = NAND Gatter
#
# gates/NegateAttribute.java
#
gateNegateAttr = Negiere %s
#
# gates/NorGate.java
#
norGateComponent = NOR Gatter
#
# gates/NotGate.java
#
notGateComponent = Inverter
#
# gates/OddParityGate.java
#
oddParityComponent = Ungerade Parität
#
# gates/OrGate.java
#
orGateComponent = OR Gatter
#
# gates/PLA.java
#
Bit Width In = Bitbreite in
Bit Width Out = Bitbreite aus
input = Input
output = Output
PLA = PLA
plaClickToEdit = (zum Bearbeiten anklicken)
plaEditMenuItem = PLA-Programm bearbeiten......
plaProgram = Programm
#
# gates/PLATable.java
#
plaEditorTitle = PLA-Programmeditor
plaFileCreateError = Es konnte keine Datei erstellt werden.
plaFileOpenError = Die Datei konnte nicht geöffnet werden.
plaLoadDialogTitle = PLA-Programm laden
plaLoadErrorTitle = Fehler beim Laden des PLA-Programms
plaSaveDialogTitle = PLA-Programm speichern
plaSaveErrorTitle = Fehler beim Speichern des PLA-Programms
#
# gates/XnorGate.java
#
xnorGateComponent = XNOR Gatter
#
# gates/XorGate.java
#
xorGateComponent = XOR Gatter
#
# InstanceComponent.java
#
KeywordNameError = Label ist ein reserviertes Schlüsselwort und kann nicht verwendet werden. Bitte geben Sie ein anderes Etikett an.
MatchedLabelNameError = Label und Komponentenname sind möglicherweise nicht identisch (Groß-/Kleinschreibung wird nicht beachtet). Bitte geben Sie ein anderes Label als den Komponentennamen an.
#
# InstanceTextField.java
#
changeLabelAction = Beschriftung ändern
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = Dip-Schalter
nrOfSwitch = Anzahl der Schalter
#
# io/DotMatrix.java
#
ioInputColumn = Spalten
ioInputRow = Zeilen
ioInputSelect = Zeilen / Spalten auswählen
ioMatrixCols = Matrixspalten
ioMatrixInput = Eingabeformat
ioMatrixPersistenceAttr = Nachleuchtdauer
ioMatrixRows = Matrixzeilen
ioMatrixShape = Punktform
ioShapeCircle = Rund
ioShapeSquare = Quadratisch
#
# io/extra/Buzzer.java
#
buzzerFrequecy = Häufigkeit
buzzerVolume = Volumen
buzzerVolumeBitWidth = Volumenbitbreite
dHz (0.1Hz) = dHz (0,1Hz)
enableSound = Ton aktivieren
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Randfarbe
bothOption = beide
ClearDiagram = Diagramm leeren
DigitalOscilloscopeClock = Uhr
DrawClockFrontLine = Uhr an der Frontlinie zeichnen
noOption = keine
ShowClockAttribute = Uhrattribut anzeigen
stdTriggerFalling = Fallende Flanke
stdTriggerRising = Steigende Flanke
#
# io/extra/ITA_IO.java
#
buzzerComponent = Summer
DigitalOscilloscopeComponent = digitale Oszillation
PlaRomComponent = 
Slider = Schieberegler
switchComponent = Schalter
#
# io/extra/PlaRom.java
#
memCSTip = Chip-Auswahl: 0 deaktiviert das Bauteil
PlaANDAttr = Und
PlaOutputsAttr = Output
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = Pla Rom %s Bearbeitungsfenster
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Anzahl der Staaten
ProgrammableGeneratorComponent = Progr. Generator
ramClearMenuItem = Inhalt löschen
ramEditMenuItem = Inhalt bearbeiten ...
romContentsAttr = Inhalt
romContentsValue = (Klicken zum Bearbeiten)
#
# io/extra/Slider.java
#
left_to_rightOption = von links nach rechts
right_to_leftOption = von rechts nach links
#
# io/HexDigit.java
#
hexDigitDataTip = Daten: Nibble zur Darstellung in hexadezimaler Darstellung
hexDigitDPTip = Dezimalpunkt: Leuchtet das Dezimalpunkt.
#
# io/Io.java
#
buttonComponent = Taster
dipswitchComponent = Dip-Schalter
dotMatrixComponent = LED-Matrix
hexDigitComponent = Hexadezimale Anzeige
ioActiveAttr = Eingeschaltet bei H-Signal?
ioBackgroundColor = Hintergrund
ioColorAttr = Farbe
ioLibrary = Eingabe/Ausgabe
ioOffColor = Farbe AUS
ioOnColor = Farbe AN
joystickComponent = Joystick
ledComponent = LED
pioComponent = Port I/O
repLBComponent = Reptar Lokaler Bus
RGBledComponent = RGBLED
sevenSegmentComponent = 7-Segmentanzeige
ttyComponent = Terminal
#
# io/Joystick.java
#
ioBitWidthAttr = Bitbreite
#
# io/Keyboard.java
#
keybAvailTip = Verfügbar: 1 wenn der Puffer Zeichen enthält
keybBufferLengthAttr = Pufferlänge
keybClearTip = Löschen: wenn 1 wird der Puffer gelöscht
keybClockTip = Takt: Triggersignal entfernt das vorderste Zeichen des Puffers
keybDesc = Tastatur (Pufferkap. %s)
keybEnableTip = Lesefreigabe: 0 sperrt das Taktsignal
keyboardComponent = Tastatur
keybOutputTip = Daten: ASCII-Wert des vordersten Zeichens im Puffer
#
# io/PortIO.java
#
# ==> pioDirection = 
# ==> pioInput = 
# ==> pioInputs = 
# ==> pioIOMultiple = 
# ==> pioIOSingle = 
pioNumber = Anzahl der PIN
# ==> pioOutEnable = 
# ==> pioOutEnables = 
# ==> pioOutput = 
# ==> pioOutputs = 
#
# io/ReptarLocalBus.java
#
repLBTip = B-Spitze
#
# io/RGBLed.java
#
BLUE = Blauer Eingang
GREEN = Grüner Eingang
RED = Roter Eingang
#
# io/SevenSegment.java
#
DecimalPoint = Dezimalpunkt
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
# ==> SevenSegDP = 
#
# io/Tty.java
#
ttyClearTip = Löschen: 1 löscht den Bildschirm
ttyClockTip = Takt: Triggersignal übernimmt das Zeichen vom Eingang
ttyColsAttr = Spalten
ttyDesc = Terminal (%s Zeilen, %s Spalten)
ttyDescShort = Terminal
ttyEnableTip = Schreibfreigabe: 0 sperrt das Taktsignal
ttyInputTip = Daten: ASCII-Wert des nächsten zu schreibenden Zeichens
ttyRowsAttr = Zeilen
#
# io/Video.java
#
rgbVideoCLK = Uhr
rgbVideoColor = Farbmodell
rgbVideoComponent = RGB-Video
rgbVideoCursor = Cursor
rgbVideoData = Daten im %s-Format
rgbVideoHeight = Höhe
rgbVideoReset = Verhalten zurücksetzen
rgbVideoRST = Zurücksetzen
rgbVideoScale = Skala
rgbVideoWE = Schreibfreigabe
rgbVideoWidth = Breite
rgbVideoX = X-Koordinate
rgbVideoY = Y-Koordinate
#
# library/bcd2sevenseg.java
#
BCD Value = BCD-Wert
BCD2SevenSegment = BCD auf sieben Segmente
#
# library/BFHPraktika.java
#
BFH mega functions = BFH Mega-Funktionen
Bin2BCD = Binairy zu BCD
#
# library/bin2bcd.java
#
Binairy data bits = Binairy-Datenbits
BinairyInputTip = Binairy-Eingabe
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Takt: Zustandsaktualisierung bei Triggersignal
flipFlopNotQTip = Aktuellen Flip-Flop-Zustand invertieren
flipFlopPresetTip = Setzen: wenn 1, gehe asynchron zu Zustand 1
flipFlopQTip = Aktueller Flip-Flop-Zustand
flipFlopResetTip = Löschen: wenn 1, gehe asynchron zu Zustand 0
#
# memory/Counter.java
#
counterCarryTip = Übertrag: ist 1, wenn der Zähler den Höchstwert erreicht (Minimalwert beim Abwärtszählen)
counterClockTip = Takt: Wert kann bei Triggersignal aktualisiert werden
counterComponent = Zähler
counterDataTip = Daten: in den Zähler zu ladender Wert
counterEnableLabel = ct
counterEnableTip = Takt: wenn 1, zähle aufwärts (oder abwärts falls Laden = 1)
counterGoalAttr = Bei Überlauf:
counterGoalContinue = Zähle weiter
counterGoalLoad = Lade den nächsten Wert
counterGoalStay = Halte an
counterGoalWrap = Starte neu
counterLabel = ctr
counterLoadTip = Laden: wenn 1, lade den Wert vom Daten-Eingang (falls Takt = 0) oder zähle abwärts
counterMaxAttr = Höchstwert
counterQTip = Ausgang: aktueller Wert des Zählers
counterResetTip = Löschen: wenn 1 wird der Zähler asynchron auf 0 gesetzt
counterUpDownTip = Aufwärts Abwärts: wenn 1, Zähler erhöht, wenn 0, Zähler verringert sich.
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
memAsyncRead = Asynchrones Lesen:
memByte = Verwendung von Byte-Freigaben
memDual = Zweifach
memEnables = Aktiviert:
memLine = Zeilenfreigaben verwenden
memLineSize = Größe der Linie
# ==> memMisaligned = 
memOcto = Octo
memQuad = Quad
memRaw = Lesen nach Schreiben
memReadBehav = Leseverhalten
memSingle = Einzeln
memWar = Schreiben nach Lesen
ramAddrWidthAttr = Bitbreite der Adresse
ramDataWidthAttr = Bitbreite der Daten
ramSelAttr = Auswählen
stdTriggerHigh = H-Niveau
stdTriggerLow = L-Niveau
#
# memory/MemMenu.java
#
ramConfirmClearMsg = Sind SIe sicher, daß der Speicher auf Null gesetzt werden soll?
ramConfirmClearTitle = Löschen bestätigen
ramLoadMenuItem = Speicherabbild laden...
ramSaveMenuItem = Speicherabbild speichern...
#
# memory/Memory.java
#
dFlipFlopComponent = D Flip-Flop
memoryLibrary = Speicher
tFlipFlopComponent = T Flip-Flop
#
# memory/Ram.java
#
ramComponent = RAM
#
# memory/RamAppearance.java
#
memAddrTip = Adresse: Zugriffsposition im Speicher
memDataTip = Daten: von der Adresse geladene Daten
memDataTip0 = Daten: Wert geladen von Adresse 0
memDataTip1 = Daten: Wert geladen von Adresse 1
memDataTip2 = Daten: Wert geladen von Adresse 2
memDataTip3 = Daten: Wert geladen von Adresse 3
ramByteEnableTip0 = Byte-Freigabe für Byte 0
ramByteEnableTip1 = Byte-Freigabe für Byte 1
ramByteEnableTip2 = Byte-Freigabe für Byte 2
ramByteEnableTip3 = Byte-Freigabe für Byte 3
ramClkTip = Takt: Speicherinhalt wird beim Übergang von 0 auf 1 aktualisiert
ramClrPin = Clear: eine Eins setzt alle Speicherplätze auf 0
ramInTip = Eingang: an der Adresse zu speichernder Wert
ramInTip0 = Eingabe: Wert, der auf Adresse 0 gespeichert werden soll
ramInTip1 = Eingabe: Wert, der an Adresse 1 gespeichert werden soll
ramInTip2 = Eingabe: Wert, der auf Adresse 2 gespeichert werden soll
ramInTip3 = Eingabe: Wert, der auf Adresse 3 gespeichert werden soll
ramLETip0 = Zeilenfreigabe für Adresse 0
ramLETip1 = Zeilenfreigabe für Adresse 1
ramLETip2 = Zeilenfreigabe für Adresse 2
ramLETip3 = Zeilenfreigabe für Adresse 3
ramOETip = Laden: wenn 1 wird Speicherinhalt auf Ausgang übertragen
ramWETip = Speichern: wenn 1 wird Eingang in Speicher übertragen
#
# memory/RamAttributes.java
#
ramBidirDataBus = Ein bidirektionaler Datenbus
ramByteEnables = Leseschreibsteuerung
RamClearPin = Klarstift verwenden
ramDataAttr = Datenbus-Implementierung
ramNoByteEnables = Nur Lesen/Schreiben von ganzen Wörtern
ramSeparateDataBus = Separater Datenbus für Lesen und Schreiben
ramTypeAttr = Ram-Typ
ramTypeNonVolatile = nichtflüchtig
ramTypeVolatile = flüchtige
ramWithByteEnables = Byte verwenden aktiviert
#
# memory/Random.java
#
randomClockTip = Takt: Wert kann bei Triggersignal aktualisiert werden
randomComponent = Zufallsgenerator
randomLabel = zufällig
randomNextTip = Freigabe: wechsle zum nächsten Schritt der Sequenz bei Triggersignal
randomQTip = Ausgang: aktuelle Zahl in der Zahlenfolge
randomResetTip = Löschen: wenn 1 wird asynchron auf den ursprünglichen Startwert zurückgesetzt
randomSeedAttr = Startwert
randomWidthLabel = Breite: %d
#
# memory/Register.java
#
registerClkTip = Takt: Wert wird bei Triggersignal aktualisiert
registerClrTip = Löschen: wenn 1 wird der Wert asynchron auf 0 gesetzt
registerComponent = Register
registerDTip = Daten: beim Triggersignal zu speichernder Wert
registerEnableTip = Freigabe: wenn 0 sind Taktsignale unwirksam
registerLabel = reg
registerQTip = Ausgang: aktueller Wert des Registers
registerShowInTab = In Registerkarten anzeigen
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = ROM-Inhalt bearbeiten
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Löschen: wenn 1 werden alle Werte asynchron auf 0 gesetzt
shiftRegClockTip = Takt: Werte können bei Triggersignal aktualisiert werden
shiftRegInTip = Eingang: Wert, der in die erste Stufe geschoben werden soll
shiftRegisterComponent = Schieberegister
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Anzahl der Stufen
shiftRegLoadTip = Laden: wenn 1 (mit Freigabe = 0) werden alle Stufen von den Eingängen geladen
shiftRegOutTip = Ausgang: der Inhalt der letzten Stufe
shiftRegParallelAttr = Paralleles Laden
shiftRegShiftTip = Freigabe: wenn 0 ist das Schieben gesperrt
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Bit-Wähler
bitSelectorDataTip = Eingang
bitSelectorGroupAttr = Ausgangsbits
bitSelectorOutputTip = Ausgang: Wert der ausgewählten Gruppe von Bits vom Eingang
bitSelectorSelectTip = Auswahl: gibt an, welche Gruppe von Bits ausgewählt werden soll
#
# plexers/Decoder.java
#
decoderEnableTip = Aktivierung: wenn nicht 0, wird 1 auf ausgewählten Ausgang geschaltet
decoderOutTip = Ausgang %s
decoderSelectTip = Auswahl: gibt an, welcher Ausgang auf 1 gesetzt wird
#
# plexers/Demultiplexer.java
#
demultiplexerEnableTip = Aktivierung: wenn nicht 0, wird Eingang auf ausgewählten Ausgang geschaltet
demultiplexerInTip = Eingang
demultiplexerOutTip = Ausgang %s
demultiplexerSelectTip = Auswahl: gibt an, an welchen Ausgang der Eingang durchgeschaltet wird
#
# plexers/Multiplexer.java
#
multiplexerEnableTip = Aktivierung: wenn nicht 0 wird ausgewählter Eingang auf Ausgang geschaltet
multiplexerInTip = Eingang %s
multiplexerOutTip = Ausgang
multiplexerSelectTip = Auswahl: gibt an, welcher Eingang an den Ausgang durchgeschaltet wird
#
# plexers/Plexers.java
#
decoderComponent = Dekoder
demultiplexerComponent = Demultiplexer
gateSizeAttr = Gattergröße
gateSizeNarrowOpt = Schmal
gateSizeWideOpt = Breit
multiplexerComponent = Multiplexer
plexerDisabledAttr = Disabled Output
plexerDisabledFloating = Offen
plexerDisabledZero = Null
plexerEnableAttr = Enable Eingang?
plexerLibrary = Auswahlschaltungen
plexerSelectBitsAttr = Auswahlleitungen
plexerSelectBottomLeftOption = Unten/Lonks
plexerSelectLocAttr = Position der Eingänge
plexerSelectTopRightOption = Oben/Rechts
plexerThreeStateAttr = Threestate?
priorityEncoderComponent = Prioritätsenkoder
#
# plexers/PriorityEncoder.java
#
priorityEncoderEnableInTip = Freigabeeingang: 0 sperrt das Bauteil
priorityEncoderEnableOutTip = Freigabeausgang: 1 wenn freigegeben und kein Eingang auf 1 gesetzt
priorityEncoderGroupSignalTip = Gruppenauswahl: 1 wenn einer der Eingänge auf 1 gesetzt
priorityEncoderInTip = Eingang %s
priorityEncoderOutTip = Ausgang: Adresse des höchst-indizierten, auf 1 gesetzten Eingangs
#
# StdAttr.java
#
ioLabelColorAttr = Farbe der Beschriftung
stdClassicAppearance = Klassisches Logisim
stdDataWidthAttr = Datenbits
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Ausrichtung
stdLabelAttr = Beschriftung
stdLabelCenter = Zentrum
stdLabelFontAttr = Zeichensatz der Beschriftung
stdLabelLocAttr = Etikettenposition
stdLabelVisibility = Etikett sichtbar
stdLogisimEvolutionAppearance = Logisim-Entwicklung
stdTriggerAttr = Trigger
#
# tcl/Tcl.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = TCL Inhaltsdatei
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = TCL REDS Konsole
#
# tcl/TclGeneric.java
#
tclGeneric = TCL generisch
tclInterfaceDefinition = TCL-Schnittstelle VHDL-Einheit
tclInterfaceDefinitionValue = (zum Bearbeiten anklicken)
#
# ttl/AbstractTtlGate.java
#
GNDPin = Erdungsstift %s
VCCPin = VCC-Pin %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Ausblendung
DisplayDecoderComponent = Display-Decoder
DisplayDecoderInTip = Input
DisplayDecoderOutTip = Output
ioMultiBit = Multi-Bit
LampTestInTip = Eingang Lampentest
LT = LT
memEnableLabel = en
RBI = RBI
RippleBlankingInputInTip = Ripple Blanking Eingang
#
# ttl/TTL.java
#
ShowInternalStructure = Zeigt die interne Struktur an
TTL7400 = 7400: Vierfach 2-Eingangs-NAND-Gate mit 2 Eingängen
TTL7402 = 7402: Vierfach-NOR-Gatter mit 2 Eingängen
TTL7404 = 7404: Hex-Wechselrichter
TTL7408 = 7408: Quad 2-Eingänge UND Gate
TTL7410 = 7410: dreifacher 3-Eingangs-NAND-Gate mit 3 Eingängen
TTL7411 = 7411: dreifach 3-Eingänge UND Gate
TTL74125 = 74125: Quad-Bus-Puffer, Drei-Status-Ausgänge, negative Freigabe
TTL7413 = 7413: Duales 4-Eingangs-NAND-Gate (Schmitt-Trigger)
TTL7414 = 7414: Hex-Wechselrichter (Schmitt-Trigger)
TTL74165 = 74165: 8-Bit Parallel-Serielles Schieberegister mit 8 Bit
TTL74175 = 74175: quad D-Flipflop, asynchroner Reset
TTL7418 = 7418: Duales 4-Eingangs-NAND-Gate (Schmitt-Trigger)
TTL7419 = 7419: Hex-Wechselrichter (Schmitt-Trigger)
TTL7420 = 7420: Duales 4-Eingangs-NAND-Gate mit 4 Eingängen
TTL7421 = 7421: Dual 4-Eingänge UND Gate
TTL7424 = 7424: vier 2-Eingänge NAND-Gatter (Schmitt-Trigger)
TTL74266 = 74266: Vierfach XNOR-Gate mit 2 Eingängen
TTL7427 = 7427: dreifacher 3-Eingangs-NOR-Gate mit 3 Eingängen
TTL74273 = 74273: oktaler D-Flipflop mit transparentem Rand
TTL74283 = 74283: 4-Bit-Binär-Volladdierer für Binärdateien
TTL7430 = 7430: einzelnes NAND-Gate mit 8 Eingängen
TTL7432 = 7432: Vierfach 2-Eingänge ODER-Gatter
TTL7436 = 7436: Vierfach-NOR-Gatter mit 2 Eingängen
TTL74377 = 74377: oktaler D-Flipflop mit Freigabe
TTL7442 = 7442: BCD auf Dezimaldecoder
TTL7443 = 7443: Excess-3 bis Dezimaldecoder
TTL7444 = 7444: Gray bis dezimaler Decoder
TTL7447 = 7447: BCD zu 7-Segment Decoder
TTL7451 = 7451: Dual AND-OR-INVERT-Gate
TTL7454 = 7454: Vier breite UND-OR-INVERT-Tore
TTL7458 = 7458: Dual AND-OR Gatter
TTL7464 = 7464: 4-2-3-2-2 AND-OR-INVERT Gate
TTL7474 = 7474: zwei D-Flipflops mit Preset und Clear
TTL7485 = 7485: 4-Bit Größenvergleicher
TTL7486 = 7486: Vierfach XOR-Gatter mit 2 Eingängen
VccGndPorts = Vcc- und Gnd-Ports aktivieren
#
# wiring/BitExtender.java
#
extenderInAttr = Bitbreite
extenderInputLabel = Eingang
extenderInputType = Eingang
extenderMainLabel = erweitern
extenderOneLabel = 1
extenderOneType = Eins
extenderOutAttr = Bitbreite Aus
extenderSignLabel = Vorzeichen
extenderSignType = Vorzeichen
extenderTypeAttr = Art der Erweiterung
extenderZeroLabel = 0
extenderZeroType = Null
#
# wiring/Clock.java
#
clockComponent = Takt
clockHighAttr = Dauer H-Signal
clockLowAttr = Dauer L-Signal
#
# wiring/Constant.java
#
constantComponent = Konstante
constantValueAttr = Wert
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 Takt
clockDurationValue = %s Takte
durationLargeMessage = Wert darf höchstens %s sein.
durationSmallMessage = Wert muß mindestens %s sein.
freqInvalidMessage = Wert ist nicht ganzzahlig
PORDurationOneValue = 1 Sek
PORDurationValue = %s Secs Secs
#
# wiring/Pin.java
#
PinCancel = Abbrechen
pinComponent = Pin
PinEnterDecimal = Dezimalzahl eingeben
pinFrozenQuestion = Der Pin ist mit dem Zustand der höheren Ebene verknüpft. Einen neuen Schaltungszustand erstellen?
pinFrozenTitle = Der Pin ist in der höheren Ebene zugeordnet.
pinInputName = Eingang
pinInputToolTip = Eingangspin hinzufügen
PinOkay = OK
pinOutputAttr = Ausgang?
pinOutputName = Ausgang
pinOutputToolTip = Ausgangspin hinzufügen
pinPullAttr = Pull-Verhalten
pinPullDownOption = Pull-Down
pinPullNoneOption = Unverändert
pinPullUpOption = Pull-Up
pinThreeStateAttr = Threestate?
#
# wiring/PowerOnReset.java
#
porHighAttr = POR-Zeit
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Testpunkt
#
# wiring/ProbeAttributes.java
#
probeNewPin = Pfeilformen
stdAppearanceAttr = Aussehen
#
# wiring/PullResistor.java
#
pullComponent = Pull-Widerstand
pullErrorType = Fehler
pullOneType = Eins
pullTypeAttr = Pull-Richtung
pullZeroType = Null
#
# wiring/Transistor.java
#
transistorNDrain = Drain: eine niedrige Quelle zieht den Drain nach unten (nur wenn das Gate hoch ist).
transistorNGate = Gate: wenn hoch, lässt der Strom durch den Transistor fließen.
transistorNSource = Quelle: eine niedrige Quelle zieht den Drain niedrig (nur wenn das Gate hoch ist).
transistorPDrain = Drain: eine hohe Quelle zieht den Drain nach oben (nur wenn das Gate niedrig ist).
transistorPGate = Gate: wenn niedrig, lässt der Strom durch den Transistor fließen.
transistorPSource = Quelle: eine hohe Quelle zieht den Drain hoch (nur wenn das Gate niedrig ist).
transistorTypeAttr = Type
transistorTypeN = N-Type
transistorTypeP = P-Type
#
# wiring/TransmissionGate.java
#
transmissionGateDrain = Ablauf: quellengesteuert, abhängig von p-Gate und n-Gate
transmissionGateNGate = n-gate: wenn niedrig, lässt die niedrige Quelle durch, um die Entwässerung zu erreichen.
transmissionGatePGate = p-gate: wenn hoch, lässt es zu, dass eine hohe Quelle durchströmt und abfließt.
transmissionGateSource = Quelle: steuert den Abfluss, abhängig von p-gate und n-gate
#
# wiring/Tunnel.java
#
tunnelComponent = Tunnel
#
# wiring/Wiring.java
#
extenderComponent = Bit-Erweiterung
groundComponent = Masse
noConnectionComponent = Nicht anschließen
powerComponent = Versorgungsspannung
transistorComponent = Transistor
transmissionGateComponent = Übertragungsgatter
wiringGateAttr = Position der Eingänge
wiringGateBottomRightOption = Unten/Rechts
wiringGateTopLeftOption = Oben/Links
wiringLibrary = Verdrahtung


