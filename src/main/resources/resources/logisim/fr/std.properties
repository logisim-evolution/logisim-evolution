#
# arith/Adder.java
#
adderCarryInTip = Retenue en entr\u00e9e: si 1, 1 de plus est ajout\u00e9 \u00e0 la sortie
adderCarryOutTip = Retenue en sortie: 1 si la somme d\u00e9passe le nombre de bits disponibles
adderComponent = Additionneur
adderInputTip = Entr\u00e9e: un des nombres \u00e0 additionner
adderOutputTip = Sortie: la somme des entr\u00e9e (plus la retenue en entr\u00e9e)
#
# arith/Arithmetic.java
#
arithmeticLibrary = Arithm\u00e9tique
#
# arith/BitAdder.java
#
bitAdderComponent = Additionneur bit \u00e0 bit
bitAdderInputTip = Entr\u00e9e: les bits \u00e0 compter
bitAdderOutputManyTip = Sortie: combien de bits sont \u00e0 1
gateInputsAttr = Nombre d'entr\u00e9es
#
# arith/BitFinder.java
#
bitFinderComponent = Recherche de bits
bitFinderFindLabel = trouver
bitFinderHighLabel = haut
bitFinderHighOption = Ordre le plus haut %s
bitFinderIndexHighTip = Index: index de l'entr\u00e9e avec l'ordre le plus haut %s
bitFinderIndexLowTip = Index: index de l'entr\u00e9e avec l'ordre le plus bas %s
bitFinderInputTip = Entr\u00e9e: les bits \u00e0 rechercher
bitFinderLowLabel = bas
bitFinderLowOption = Ordre le plus bas %s
bitFinderPresentTip = Pr\u00e9sence: 1 si l'entr\u00e9e contien un %s
bitFinderTypeAttr = Type
#
# arith/Comparator.java
#
comparatorComponent = Comparateur
comparatorEqualTip = Equal: 1 si A est \u00e9gal \u00e0 B
comparatorGreaterTip = Greater: 1 si A est plus grand que B
comparatorInputATip = A: membre de gauche de l'op\u00e9ration
comparatorInputBTip = B: membre de droite de l'op\u00e9ration
comparatorLessTip = Less: 1 si A est plus petit que B
comparatorType = Type num\u00e9rique
twosComplementOption = compl\u00e9ment \u00e0 2
unsignedOption = Non sign\u00e9
#
# arith/Divider.java
#
dividerComponent = Diviseur
dividerDividendLowerTip = num\u00e9rateur bas: la moiti\u00e9 basse du nombre \u00e0 diviser
dividerDividendUpperTip = num\u00e9rateur haut: la moiti\u00e9 haute du nombre \u00e0 diviser
dividerDivisorTip = Diviseur: d\u00e9nominateur par lequel diviser
dividerOutputTip = Sortie: le r\u00e9sultat de la division du num\u00e9rateur par le d\u00e9nominateur
dividerRemainderOutput = reste
dividerRemainderTip = Reste: (num\u00e9rateur - sortie * diviseur)
dividerUpperInput = num\u00e9rateur
#
# arith/Multiplier.java
#
multiplierCarryInTip = Retenue en entr\u00e9e: une valeur \u00e0 ajouter \u00e0 la sortie
multiplierCarryOutTip = Retenue en sortie: le bit de poids le plus fort du produit
multiplierComponent = Multiplicateur
multiplierInputTip = Entr\u00e9e: l'un des nombres \u00e0 multiplier
multiplierOutputTip = Output: le produit des entr\u00e9es plus la retenue en entr\u00e9e
#
# arith/Negator.java
#
negatorComponent = Inverseur
negatorInputTip = Entr\u00e9e: le nombre \u00e0 inverser
negatorOutputTip = Sortie: le compl\u00e9men \u00e0 deux de l'inversion de l'entr\u00e9e
#
# arith/Shifter.java
#
shiftArithmeticRight = Arithm\u00e9tique \u00e0 droite
shifterComponent = D\u00e9calage
shifterDistanceTip = Distance: combien de d\u00e9calage sur l'entr\u00e9e
shifterInputTip = Entr\u00e9e: les bits \u00e0 d\u00e9caler
shifterOutputTip = Sortie: r\u00e9sultat du d\u00e9calage de l'entr\u00e9e
shifterShiftAttr = Type de d\u00e9calage
shiftLogicalLeft = Logique \u00e0 gauche
shiftLogicalRight = Logique \u00e0 droite
shiftRollLeft = Rotation \u00e0 gauche
shiftRollRight = Rotation \u00e0 droite
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Emprunt en entr\u00e9e: si 1 la sortie est dminu\u00e9e de 1
subtractorBorrowOutTip = Emprunt en sortie: 1 si la diff\u00e9rence est n\u00e9gative
subtractorComponent = Soustracteur
subtractorMinuendTip = Diminu\u00e9: le nombre dont on soustrait
subtractorOutputTip = Sortie: la diff\u00e9rence entre le diminu\u00e9 et le soustrait
subtractorSubtrahendTip = Soustrait: le nombre \u00e0 soustraire du diminu\u00e9
#
# base/Base.java
#
baseLibrary = Base
#
# base/Text.java
#
textComponent = Label
textFontAttr = Police
textHorzAlignAttr = Alignement horizontal
textHorzAlignCenterOpt = Centr\u00e9
textHorzAlignLeftOpt = Gauche
textHorzAlignRightOpt = Droite
textTextAttr = Texte
textVertAlignAttr = Alignment vertical
textVertAlignBaseOpt = Base
textVertAlignBottomOpt = Fond
textVertAlignCenterOpt = Centre
textVertAlignTopOpt = Sommet
#
# base/VhdlParser.java
#
CannotFindEntityException = La d\u00e9claration d'entit\u00e9 ne peut pas \u00eatre trouv\u00e9e
emptySourceException = Impossible d'analyser le contenu vide
genericDeclarationException = Syntaxe ill\u00e9gale des g\u00e9n\u00e9riques
genericTypeException = Type de m\u00e9dicaments g\u00e9n\u00e9riques non pris en charge
genericValueException = Valeur par d\u00e9faut des g\u00e9n\u00e9riques non reconnus
invalidTypeException = Type de port non valide
portDeclarationException = Syntaxe de port ill\u00e9gale
#
# Builtin.java
#
builtinLibrary = inclue
#
# gates/AndGate.java
#
andGateComponent = Porte AND
#
# gates/Buffer.java
#
bufferComponent = Buffer
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Buffer controll\u00e9
controlledControlOption = Position de la commande
controlledInverterComponent = Inverseur controll\u00e9
controlledLeftHanded = A gauche
controlledRightHanded = A droite
#
# gates/EvenParityGate.java
#
evenParityComponent = Parit\u00e9 paire
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/flottant
gateOutputAttr = Valeur de sortie
gateOutputZ1 = flottant/1
gateSizeNormalOpt = moyen
xorBehaviorAttr = Comportement multi-entr\u00e9es
xorBehaviorOdd = Quand un nombre impaire est Haut
xorBehaviorOne = Quand une entr\u00e9e est Haut
#
# gates/Gates.java
#
gatesLibrary = Portes logiques
#
# gates/NandGate.java
#
nandGateComponent = Porte NAND
#
# gates/NegateAttribute.java
#
gateNegateAttr = Inverseur %s
#
# gates/NorGate.java
#
norGateComponent = Porte NOR
#
# gates/NotGate.java
#
gateSizeAttr = Dimension dessins
gateSizeNarrowOpt = \u00e9troit
gateSizeWideOpt = large
notGateComponent = Porte NOT
#
# gates/OddParityGate.java
#
oddParityComponent = Parit\u00e9 impaire
#
# gates/OrGate.java
#
orGateComponent = Porte OR
#
# gates/PLA.java
#
Bit Width In = Largeur du foret en
Bit Width Out = Largeur du panneton vers l'ext\u00e9rieur
input = contribution
output = rendement
PLA = PLA
plaClickToEdit = (cliquez pour \u00e9diter)
plaEditMenuItem = Editer le programme PLA ...
plaProgram = Programme
#
# gates/PLATable.java
#
plaEditorTitle = Editeur de programme PLA
plaFileCreateError = Impossible de cr\u00e9er le fichier.
plaFileOpenError = Impossible d'ouvrir le fichier.
plaLoadDialogTitle = Charger le programme PLA
plaLoadErrorTitle = Erreur de chargement du programme PLA
plaSaveDialogTitle = Sauvegarder le programme PLA
plaSaveErrorTitle = Erreur d'enregistrement du programme PLA
#
# gates/XnorGate.java
#
xnorGateComponent = Porte XNOR
#
# gates/XorGate.java
#
xorGateComponent = Porte XOR
#
# InstanceComponent.java
#
KeywordNameError = Label est un mot cl\u00e9 r\u00e9serv\u00e9 et ne peut pas \u00eatre utilis\u00e9. Veuillez sp\u00e9cifier une \u00e9tiquette diff\u00e9rente.
MatchedLabelNameError = L'\u00e9tiquette et le nom composant ne peuvent pas \u00eatre les m\u00eames (ils ne sont pas sensibles \u00e0 la casse). Veuillez sp\u00e9cifier une \u00e9tiquette diff\u00e9rente du nom du composant.
#
# InstanceTextField.java
#
changeLabelAction = Changer le Label
#
# io/Button.java
#
buttonComponent = Bouton
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = Interrupteur DIP
nrOfSwitch = Nbr. commutateur
#
# io/DotMatrix.java
#
ioInputColumn = Colonnes
ioInputRow = Lignes
ioInputSelect = Selectionner ligne/colonne
ioMatrixCols = Colonne de la matrice
ioMatrixInput = Format de l'entr\u00e9e
ioMatrixPersistenceAttr = Persistence lumineuse
ioMatrixRows = Ligne de la matrice
ioMatrixShape = Forme d'un point
ioShapeCircle = Circulaire
ioShapeSquare = Carr\u00e9
#
# io/extra/Buzzer.java
#
buzzerComponent = Buzzer
buzzerFrequecy = fr\u00e9quence
buzzerVolume = contenance
buzzerVolumeBitWidth = volume largeur de bit
dHz (0.1Hz) = dHz (0,1Hz)
enableSound = Activer le son
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Couleur de la bordure
bothOption = tous les deux
ClearDiagram = Sch\u00e9ma clair
DigitalOscilloscopeClock = chronom\u00e9trer
DrawClockFrontLine = tracer la ligne de front de l'horloge
noOption = aucun
ShowClockAttribute = Afficher l'attribut horloge
stdTriggerFalling = Flanc descendant
stdTriggerRising = Flanc Montant
#
# io/extra/ITA_IO.java
#
DigitalOscilloscopeComponent = oscill. num\u00e9rique
Slider = glissi\u00e8re
#
# io/extra/PlaRom.java
#
memCSTip = Chip select: 0 d\u00e9sactive le composant
PlaANDAttr = Et
PlaOutputsAttr = Sortie
PlaRomComponent = 
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = Fen\u00eatre d'\u00e9dition Pla Rom %s
#
# io/extra/PlaRomPanel.java
#
demultiplexerInTip = Entr\u00e9e
multiplexerOutTip = Sortie
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Nombre d'\u00c9tats
#
# io/extra/ProgrammableGeneratorState.java
#
ProgrammableGeneratorComponent = G\u00e9n\u00e9rateur progressif
#
# io/extra/Slider.java
#
left_to_rightOption = de gauche \u00e0 droite
right_to_leftOption = de droite \u00e0 gauche
#
# io/extra/Switch.java
#
switchComponent = revirement
#
# io/HexDigit.java
#
hexDigitDataTip = Donn\u00e9es: nibble \u00e0 afficher en hexad\u00e9cimal
hexDigitDPTip = DecimalPoint: allume le point d\u00e9cimal
#
# io/HexDigitShape.java
#
hexDigitComponent = Afficheur Hexad\u00e9cimal
#
# io/Io.java
#
dipswitchComponent = Dip switch
dotMatrixComponent = Matrice de LED
ioActiveAttr = Actif si haut?
ioBackgroundColor = Fond (background)
ioColorAttr = Couleur
ioLibrary = Entr\u00e9e/Sortie
ioOffColor = Off Color
ioOnColor = On Color
joystickComponent = Joystick
#
# io/Joystick.java
#
ioBitWidthAttr = Largeur donn\u00e9es
#
# io/Keyboard.java
#
keybAvailTip = Disponible: 1 quand le tampon contient des caract\u00e8res
keybBufferLengthAttr = Longueur du Buffer
keybClearTip = Clear: 1 efface le buffer
keybClockTip = Horloge: trigger consomme le premier caract\u00e8re du buffer
keybDesc = Clavier (buffer cap. %s)
keybEnableTip = Read activ\u00e9: 0 d\u00e9sactive l'horloge
keyboardComponent = Clavier
keybOutputTip = Donn\u00e9es: Valeur ASCII du premier caract\u00e8re du tampon
#
# io/Led.java
#
ledComponent = LED
#
# io/PortIO.java
#
pioBuses = Un ou plusieurs bus
pioComponent = Port I/O
pioNumber = Nombre de contacte
pioPins = Pin Simple
pioShowBus = Type de connexion ?
#
# io/ReptarLocalBus.java
#
repLBComponent = Reptar Local Bus
repLBTip = Pointe B
#
# io/RGBLed.java
#
BLUE = Entr\u00e9e bleue
GREEN = Entr\u00e9e verte
RED = Entr\u00e9e rouge
RGBledComponent = LED RVB
#
# io/SevenSegment.java
#
DecimalPoint = Point d\u00e9cimal
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
sevenSegmentComponent = Afficheur 7-Segment
#
# io/Tty.java
#
ttyClearTip = Effacer: 1 efface l'\u00e9cran
ttyClockTip = Horloge: trigger ajoute le caract\u00e8re en entr\u00e9e
ttyColsAttr = Colonnes
ttyComponent = TTY
ttyDesc = TTY (%s lignes, %s colonnes)
ttyDescShort = TTY
ttyEnableTip = Active l'\u00e9criture: 0 d\u00e9sactive l'horloge
ttyInputTip = Donn\u00e9es: valeur ASCII du prochain character \u00e0 \u00e9crire
ttyRowsAttr = Lignes
#
# io/Video.java
#
rgbVideoCLK = Horloge
rgbVideoColor = Mod\u00e8le de couleur
rgbVideoComponent = Video RVB
rgbVideoCursor = Curseur
rgbVideoData = Data dans le format %s
rgbVideoHeight = hauteur
rgbVideoReset = R\u00e9initialiser le comportement
rgbVideoRST = R\u00e9initialiser
rgbVideoScale = \u00c9chelle
rgbVideoWE = Ecriture autoris\u00e9e
rgbVideoWidth = Largeur
rgbVideoX = Coordon\u00e9e X
rgbVideoY = Coordon\u00e9e Y
#
# library/bcd2sevenseg.java
#
BCD Value = valeur BCD
BCD2SevenSegment = BCD \u00e0 sept segments
#
# library/BFHPraktika.java
#
BFH mega functions = M\u00e9ga-fonctions BFH
#
# library/bin2bcd.java
#
Bin2BCD = Binairy \u00e0 BCD
Binairy data bits = Bits de donn\u00e9es binairy
BinairyInputTip = Entr\u00e9e binairy
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Horloge: l'\u00e9tat impact sur le trigger
flipFlopNotQTip = Compl\u00e9ment \u00e0 l'\u00e9tat courrant du flip-flop
flipFlopPresetTip = Preset: si 1, l'\u00e9tat du pin \u00e0 1 de mani\u00e8re asynchrone
flipFlopQTip = Etat courrant du flip-flop
flipFlopResetTip = Clear: si 1, l'\u00e9tat du pin \u00e0 0 de mani\u00e8re asynchrone
#
# memory/Counter.java
#
counterCarryTip = Carry: est \u00e0 1 si la valeur atteinte le maximum (minimum si d\u00e9cr\u00e9mente)
counterClockTip = Horloge: la valeur peut modifier le trigger
counterDataTip = Data: valeur \u00e0 charger dans le compteur
counterEnableLabel = ct
counterEnableTip = Count: si 1, le compteur s'incr\u00e9mente (ou d\u00e9cr\u00e9mente si Load
counterGoalAttr = Action en cas de d\u00e9passement
counterGoalContinue = Continue le compte
counterGoalLoad = Charger la valeur suivante
counterGoalStay = Rester \u00e0 la valeur
counterGoalWrap = Entourer
counterLabel = ctr
counterLoadTip = Load: si 1, charge \u00e0 partir des donn\u00e9es entr\u00e9es (if Count
counterMaxAttr = Valeur max
counterQTip = Sortie: valeur courrant du compteur
counterResetTip = Clear: si 1, remet \u00e0 0 de mani\u00e8re asynchrone
counterUpDownTip = UpDown: Si 1 Incr\u00e9mente, Si 0, d\u00e9cremente
registerWidthLabel = (%sb)
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
ByteLabel = octet
GigabyteLabel = Gbyte
KilobyteLabel = kByte
MegabyteLabel = MByte
ramAddrLabel = A
ramAddrWidthAttr = Largeur d'adresse
ramDataWidthAttr = Largeur donn\u00e9es
ramSelAttr = S\u00e9lectionnez
stdTriggerHigh = Niveau haut
stdTriggerLow = Niveau bas
#
# memory/MemMenu.java
#
ramClearMenuItem = Effacer les contenus
ramConfirmClearMsg = Etes vous s\u00fbr de vouloir remettre \u00e0 z\u00e9ro la sortie m\u00e9moire?
ramConfirmClearTitle = Confirmer l'\u00e9ffacement
ramEditMenuItem = Editer le contenu...
ramLoadDialogTitle = Charge une image RAM
ramLoadErrorTitle = Erreur de chargement
ramLoadMenuItem = Charger l'image...
ramSaveDialogTitle = Sauvegarder une image RAM
ramSaveErrorTitle = Erreur de sauvegarde
ramSaveMenuItem = Sauvegarder l'image...
#
# memory/Memory.java
#
counterComponent = Compteur
dFlipFlopComponent = D Flip-Flop
memoryLibrary = M\u00e9moire / S\u00e9quenciel
ramComponent = RAM
randomComponent = G\u00e9n\u00e9rateur al\u00e9atoire
registerComponent = Registre
#
# memory/Ram.java
#
ramBusTip = Data: valeur charg\u00e9 ou stock\u00e9e \u00e0 l'adresse
ramClkTip = Clock: la valeur en m\u00e9moire change sur flanc de 0 \u00e0 1
ramContentsAttr = Contenu Initial
ramDataLabel = D
ramInTip = Input: valeur \u00e0 charger \u00e0 l'adresse
ramOELabel = ld
ramOETip = Load: si 1, charge la m\u00e9moire sur la sortie
ramWELabel = str
ramWETip = Store: si 1, stock l'entr\u00e9e dans la m\u00e9moire
#
# memory/RamAttributes.java
#
ramBidirDataBus = bidirectionnel
ramByteEnables = Contr\u00f4le lecture/\u00e9criture
ramDataAttr = Type de bus donn\u00e9es
ramNoByteEnables = Mot entier en lecture/\u00e9criture seulement
ramSeparateDataBus = monodirectionnel deux bus lire/\u00e9crire
ramWithByteEnables = Use byte enables
#
# memory/Random.java
#
randomClockTip = Clock: la valeur peut changer avec le trigger
randomLabel = al\u00e9atoire
randomNextTip = Enable: avance au suivant dans la s\u00e9quence avec le trigger d'horloge
randomQTip = Sortie: nombre courrant dans la s\u00e9quence
randomResetTip = Clear: si 1, initialise \u00e0 la semence de mani\u00e8re asynchrone
randomSeedAttr = Semence
randomWidthLabel = Largeur : %d
#
# memory/Register.java
#
registerClkTip = Clock: la valeur change avec le trigger
registerClrTip = Clear: si 1, la valeur du pin mise \u00e0 0 de mani\u00e8re asynchrone
registerDTip = Data: valeur stock\u00e9e dans l'horloge du trigger
registerEnableTip = Enable: si 0, les trigger d'horloge sont inop\u00e9rants
registerLabel = reg
registerQTip = Sortie: valeur courrant du registre
registerShowInTab = Show in Registers Tab
#
# memory/Rom.java
#
memAddrTip = Address: emplacement acc\u00e9d\u00e9 en m\u00e9moire
memDataTip = Data: valeur charg\u00e9e depuis une adresse
romComponent = ROM
romContentsAttr = Contenu
romContentsValue = (click pour \u00e9diter)
#
# memory/RomContentsListener.java
#
romChangeAction = Editer le contenu de la ROM
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Clear: quand 1, remise \u00e0 z\u00e9ro compl\u00e8te et asynchrone
shiftRegClockTip = Clock: les valeurs peuvent changer avec le trigger
shiftRegInTip = Input: valeur \u00e0 d\u00e9caler dans le premier \u00e9tage
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Nombre d'\u00e9tages
shiftRegLoadTip = Load: quand 1 (avec shift
shiftRegOutTip = Output: est le contenu du dernier \u00e9tage
shiftRegParallelAttr = Chargement parall\u00e8le
shiftRegShiftTip = Shift: d\u00e9calage d\u00e9sactiv\u00e9 quand 0
#
# memory/ShiftRegisterLogger.java
#
shiftRegisterComponent = Registre \u00e0 d\u00e9calage
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# memory/TFlipFlop.java
#
tFlipFlopComponent = T Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorDataTip = Data
bitSelectorGroupAttr = Bits en sortie
bitSelectorOutputTip = Sortie: valeur du groupe de bits s\u00e9lectionn\u00e9s dans data
bitSelectorSelectTip = Select: identifie quel groupe de donn\u00e9es est s\u00e9lectionn\u00e9
#
# plexers/Decoder.java
#
decoderComponent = Decodeur
decoderEnableTip = Enable: si non 0, la sortie s\u00e9lectionn\u00e9e est \u00e0 1
decoderOutTip = Sortie %s
decoderSelectTip = Select: identifie quelle sortie est \u00e0 1
#
# plexers/Demultiplexer.java
#
demultiplexerComponent = Demultiplexeur
demultiplexerEnableTip = Enable: si non 0, la sortie s\u00e9lectionn\u00e9e et l'entr\u00e9e
demultiplexerSelectTip = Select: identifie quelle sortie re\u00e7oit l'entr\u00e9e
#
# plexers/Multiplexer.java
#
multiplexerComponent = Multiplexeur
multiplexerEnableTip = Enable: si non 0, la sortie est l'entr\u00e9e s\u00e9lectionn\u00e9e
multiplexerSelectTip = Select: identifie l'entr\u00e9e qui devient la sortie
#
# plexers/Plexers.java
#
bitSelectorComponent = S\u00e9lecteur de Bit
plexerDisabledAttr = D\u00e9sactiv\u00e9 les sorties
plexerDisabledFloating = Flottant
plexerDisabledZero = Zero
plexerEnableAttr = Inclure l'activation ?
plexerLibrary = De/Multiplexeurs,Encodeurs
plexerSelectBitsAttr = Select Bits
plexerSelectBottomLeftOption = Fond/Gauche
plexerSelectLocAttr = Selectionner l'emplacement
plexerSelectTopRightOption = Haut/Droite
plexerThreeStateAttr = Trois \u00e9tats?
#
# plexers/PriorityEncoder.java
#
priorityEncoderComponent = Encodeur prioritaire
priorityEncoderEnableOutTip = Activer la sortie: 1 si activ\u00e9 et aucune entr\u00e9e est \u00e0 1
priorityEncoderGroupSignalTip = Group Select: 1 si activ\u00e9 et n'importe quelle entr\u00e9e est \u00e0 1
priorityEncoderInTip = Entr\u00e9e %s
priorityEncoderOutTip = Sortie: adresse du 1 avec le plus haut indexe
#
# StdAttr.java
#
ioLabelColorAttr = Couleur du label
stdClassicAppearance = Logisim classique
stdDataWidthAttr = Largeur donn\u00e9es
stdEvolutionAppearance = Logisim-Hybride
stdFacingAttr = Orientation
stdLabelAttr = Label
stdLabelCenter = Centre
stdLabelFontAttr = Police du Label
stdLabelLocAttr = Emplacement de l'\u00e9tiquette
stdLabelVisibility = \u00c9tiquette visible
stdLogisimEvolutionAppearance = Logisim-Evolution
stdTriggerAttr = Trigger
#
# tcl/Tcl.java
#
tclGeneric = TCL generic
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = TCL content file
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = TCL REDS console
#
# tcl/TclGeneric.java
#
tclInterfaceDefinition = TCL interface VHDL entity
tclInterfaceDefinitionValue = (click pour \u00e9diter)
#
# ttl/AbstractTtlGate.java
#
demultiplexerOutTip = Sortie %s
GNDPin = Goupille de mise \u00e0 la terre %s
multiplexerInTip = Entr\u00e9e %s
VCCPin = VCC pin %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Suppression
DisplayDecoderComponent = D\u00e9codeur d'affichage
DisplayDecoderInTip = Entr\u00e9e
DisplayDecoderOutTip = Sortie
ioMultiBit = multi bit
LampTestInTip = Entr\u00e9e test lampe
LT = LT
memEnableLabel = en
priorityEncoderEnableInTip = Activer l'entr\u00e9e: 0 d\u00e9sactive le composant
RBI = RBI
RippleBlankingInputInTip = Entr\u00e9e de suppression de l'ondulation
#
# ttl/TTL.java
#
ShowInternalStructure = Afficher la structure interne
TTL7400 = 7400 : quadruple porte NAND \u00e0 2 entr\u00e9es
TTL7402 = 7402 : quad porte NOR 2 entr\u00e9es quadruple
TTL7404 = 7404 : onduleur hexagonal
TTL7408 = 7408 : quad 2 entr\u00e9es ET porte d'entr\u00e9e
TTL7410 = 7410 : triple porte NAND \u00e0 3 entr\u00e9es
TTL7411 = 7411 : triple 3 entr\u00e9es ET porte d'entr\u00e9e
TTL74125 = 74125 : tampon quadruple bus, sorties \u00e0 trois \u00e9tats, validation n\u00e9gative
TTL7413 = 7413 : double porte NAND \u00e0 4 entr\u00e9es (schmitt-trigger)
TTL7414 = 7414 : onduleur hexagonal (schmitt-trigger)
TTL74165 = 74165 : registre \u00e0 d\u00e9calage parall\u00e8le-\u00e0-s\u00e9rie 8 bits
TTL74175 = 74175 : bascule quadruple en D, remise \u00e0 z\u00e9ro asynchrone
TTL7418 = 7418 : double porte NAND \u00e0 4 entr\u00e9es (schmitt-trigger)
TTL7419 = 7419 : onduleur hexagonal (schmitt-trigger)
TTL7420 = 7420 : double porte NAND 4 entr\u00e9es \u00e0 4 entr\u00e9es
TTL7421 = 7421 : double 4 entr\u00e9es ET porte d'entr\u00e9e
TTL7424 = 7424 : quad 2 entr\u00e9es NAND gate (schmitt-trigger)
TTL74266 = 74266 : quad porte XNOR 2 entr\u00e9es quadruple
TTL7427 = 7427 : triple porte NOR \u00e0 3 entr\u00e9es NOR
TTL74273 = 74273 : bascule octale en D avec bascule transparente
TTL74283 = 74283 : Additionneur complet binaire 4 bits
TTL7430 = 7430 : porte NAND simple \u00e0 8 entr\u00e9es
TTL7432 = 7432 : quad 2 entr\u00e9es OU porte OU
TTL7436 = 7436 : quad 2 entr\u00e9es porte NOR 2 entr\u00e9es
TTL74377 = 74377 : bascule octale D-Flipflop avec validation
TTL7442 = 7442 : BCD vers d\u00e9codeur d\u00e9cimal
TTL7443 = 7443 : Exc\u00e8s-3 au d\u00e9codeur d\u00e9cimal
TTL7444 = 7444 : Gris vers d\u00e9codeur d\u00e9cimal
TTL7447 = 7447 : BCD vers d\u00e9codeur 7 segments
TTL7451 = 7451 : porte double AND-OR-INVERT
TTL7454 = 7454 : Quatre portes ET-OU-OU-INVERTES larges
TTL7458 = 7458 : porte double AND-OR
TTL7464 = 7464 : 4-2-3-3-2 Porte AND-OR-INVERT
TTL7474 = 7474 : double D-Flipflops avec pr\u00e9r\u00e9glage et clair
TTL7485 = 7485 : comparateur de grandeurs 4 bits
TTL7486 = 7486 : quadruple porte XOR \u00e0 2 entr\u00e9es
VccGndPorts = Activer les ports Vcc et Gnd
#
# wiring/BitExtender.java
#
extenderComponent = Extension de bit
extenderInAttr = Largeur bus entr\u00e9e
extenderInputLabel = entr\u00e9e
extenderInputType = Entr\u00e9e
extenderMainLabel = \u00e9tendre
extenderOneLabel = 1
extenderOneType = Un
extenderOutAttr = Largeur bus sortie
extenderSignLabel = sign\u00e9
extenderSignType = Signe
extenderTypeAttr = Type d'Extension
extenderZeroLabel = 0
extenderZeroType = Z\u00e9ro
#
# wiring/Clock.java
#
clockComponent = Horloge
clockHighAttr = Dur\u00e9e haute
clockLowAttr = Dur\u00e9e basse
#
# wiring/Constant.java
#
constantComponent = Constante
constantValueAttr = Valeur
#
# wiring/DoNotConnect.java
#
noConnectionComponent = Ne connectez pas
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 Tic
clockDurationValue = %s Tics
durationLargeMessage = La valeur doit \u00eatre %s ou moins.
durationSmallMessage = La valeur doit \u00eatre au moins %s.
freqInvalidMessage = La valeur n'est pas un entier valide
PORDurationOneValue = 1 Sec
PORDurationValue = %s Secs
#
# wiring/Ground.java
#
groundComponent = Masse
#
# wiring/Pin.java
#
PinCancel = Annuler
pinComponent = Pin
PinEnterDecimal = Entrer d\u00e9cimal
pinFrozenQuestion = Le pin est li\u00e9 \u00e0 l'\u00e9tat du supercircuit. Cr\u00e9er un nouvel \u00e9tat pour le circuit?
pinFrozenTitle = Pin attach\u00e9 au super-circuit.
pinInputName = Entr\u00e9e
pinInputToolTip = Ajouter un pin d'entr\u00e9e
PinOkay = OK
pinOutputAttr = Sortie?
pinOutputName = Sortie
pinOutputToolTip = Ajouter un pin de sortie
pinPullAttr = Comportement Pull
pinPullDownOption = Pull Down
pinPullNoneOption = Inchang\u00e9
pinPullUpOption = Pull Up
pinThreeStateAttr = Trois \u00e9tats?
#
# wiring/PowerOnReset.java
#
porHighAttr = Temps reset
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Sonde
#
# wiring/ProbeAttributes.java
#
probeNewPin = Formes de fl\u00e8che
stdAppearanceAttr = Apparence
#
# wiring/PullResistor.java
#
pullComponent = R\u00e9sistance de charge
pullErrorType = Erreur
pullOneType = Un
pullTypeAttr = DIrection charge
pullZeroType = Z\u00e9ro
#
# wiring/Transistor.java
#
transistorComponent = Transistor
transistorNDrain = drain: une source bas tirera le drain sur bas (uniquement lorsque la porte est haute)
transistorNGate = gate: \u00e0 l'\u00e9tat haut, laisse passer le courant dans le transistor
transistorNSource = source: une source bas tirera le drain sur bas (seulement lorsque la porte est haute)
transistorPDrain = drain: une source haut tirera le drain haut (uniquement lorsque la porte est bas)
transistorPGate = gate: au niveau bas, laisse passer le courant \u00e0 travers le transistor
transistorPSource = source: une source haut tirera le drain vers haut (uniquement lorsque la porte est bas)
transistorTypeAttr = Type
transistorTypeN = N-Type
transistorTypeP = P-Type
#
# wiring/TransmissionGate.java
#
transmissionGateComponent = Porte de transmission
transmissionGateDrain = drain: contr\u00f4l\u00e9 par la source, en fonction du type de porte p ou n
transmissionGateNGate = n-gate: au niveau bas, laisse passer la source bas vers drain
transmissionGatePGate = p-gate: au niveau haut, laisse passer la source haut vers drain
transmissionGateSource = source: Contr\u00f4l le drain, en fonction du type de porte p ou n
#
# wiring/Tunnel.java
#
tunnelComponent = Tunnel
#
# wiring/Wiring.java
#
powerComponent = Alimentation
wiringGateAttr = Position de la Gate
wiringGateBottomRightOption = Bas/Droite
wiringGateTopLeftOption = Haut/Gauche
wiringLibrary = C\u00e2blage


