#
# arith/Adder.java
#
adderCarryInTip = Retenue en entr\u00e9e: si 1, 1 de plus est ajout\u00e9 \u00e0 la sortie
adderCarryOutTip = Retenue en sortie: 1 si la somme d\u00e9passe le nombre de bits disponibles
adderComponent = Additionneur
adderInputTip = Entr\u00e9e: un des nombres \u00e0 additionner
adderOutputTip = Sortie: la somme des entr\u00e9e (plus la retenue en entr\u00e9e)
#
# arith/Arithmetic.java
#
arithmeticLibrary = Arithm\u00e9tique
#
# arith/BitAdder.java
#
bitAdderComponent = Additionneur bit \u00e0 bit
bitAdderInputTip = Entr\u00e9e: les bits \u00e0 compter
bitAdderOutputManyTip = Sortie: combien de bits sont \u00e0 1
gateInputsAttr = Nombre d'entr\u00e9es
#
# arith/BitFinder.java
#
bitFinderComponent = Recherche de bits
bitFinderFindLabel = trouver
bitFinderHighLabel = haut
bitFinderHighOption = Ordre le plus haut %s
bitFinderIndexHighTip = Index: index de l'entr\u00e9e avec l'ordre le plus haut %s
bitFinderIndexLowTip = Index: index de l'entr\u00e9e avec l'ordre le plus bas %s
bitFinderInputTip = Entr\u00e9e: les bits \u00e0 rechercher
bitFinderLowLabel = bas
bitFinderLowOption = Ordre le plus bas %s
bitFinderPresentTip = Pr\u00e9sence: 1 si l'entr\u00e9e contien un %s
bitFinderTypeAttr = Type
#
# arith/Comparator.java
#
comparatorComponent = Comparateur
comparatorEqualTip = Equal: 1 si A est \u00e9gal \u00e0 B
comparatorGreaterTip = Greater: 1 si A est plus grand que B
comparatorInputATip = A: membre de gauche de l'op\u00e9ration
comparatorInputBTip = B: membre de droite de l'op\u00e9ration
comparatorLessTip = Less: 1 si A est plus petit que B
comparatorType = Type num\u00e9rique
twosComplementOption = compl\u00e9ment \u00e0 2
unsignedOption = Non sign\u00e9
#
# arith/Divider.java
#
dividerComponent = Diviseur
dividerDividendLowerTip = num\u00e9rateur bas: la moiti\u00e9 basse du nombre \u00e0 diviser
dividerDividendUpperTip = num\u00e9rateur haut: la moiti\u00e9 haute du nombre \u00e0 diviser
dividerDivisorTip = Diviseur: d\u00e9nominateur par lequel diviser
dividerOutputTip = Sortie: le r\u00e9sultat de la division du num\u00e9rateur par le d\u00e9nominateur
dividerRemainderOutput = reste
dividerRemainderTip = Reste: (num\u00e9rateur - sortie * diviseur)
dividerUpperInput = num\u00e9rateur
#
# arith/Multiplier.java
#
multiplierCarryInTip = Retenue en entr\u00e9e: une valeur \u00e0 ajouter \u00e0 la sortie
multiplierCarryOutTip = Retenue en sortie: le bit de poids le plus fort du produit
multiplierComponent = Multiplicateur
multiplierInputTip = Entr\u00e9e: l'un des nombres \u00e0 multiplier
multiplierOutputTip = Output: le produit des entr\u00e9es plus la retenue en entr\u00e9e
#
# arith/Negator.java
#
negatorComponent = Inverseur
negatorInputTip = Entr\u00e9e: le nombre \u00e0 inverser
negatorOutputTip = Sortie: le compl\u00e9men \u00e0 deux de l'inversion de l'entr\u00e9e
#
# arith/Shifter.java
#
shiftArithmeticRight = Arithm\u00e9tique \u00e0 droite
shifterComponent = D\u00e9calage
shifterDistanceTip = Distance: combien de d\u00e9calage sur l'entr\u00e9e
shifterInputTip = Entr\u00e9e: les bits \u00e0 d\u00e9caler
shifterOutputTip = Sortie: r\u00e9sultat du d\u00e9calage de l'entr\u00e9e
shifterShiftAttr = Type de d\u00e9calage
shiftLogicalLeft = Logique \u00e0 gauche
shiftLogicalRight = Logique \u00e0 droite
shiftRollLeft = Rotation \u00e0 gauche
shiftRollRight = Rotation \u00e0 droite
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Emprunt en entr\u00e9e: si 1 la sortie est dminu\u00e9e de 1
subtractorBorrowOutTip = Emprunt en sortie: 1 si la diff\u00e9rence est n\u00e9gative
subtractorComponent = Soustracteur
subtractorMinuendTip = Diminu\u00e9: le nombre dont on soustrait
subtractorOutputTip = Sortie: la diff\u00e9rence entre le diminu\u00e9 et le soustrait
subtractorSubtrahendTip = Soustrait: le nombre \u00e0 soustraire du diminu\u00e9
#
# base/Base.java
#
baseLibrary = Base
#
# base/Text.java
#
textComponent = Label
textFontAttr = Police
textHorzAlignAttr = Alignement horizontal
textHorzAlignCenterOpt = Centr\u00e9
textHorzAlignLeftOpt = Gauche
textHorzAlignRightOpt = Droite
textTextAttr = Texte
textVertAlignAttr = Alignment vertical
textVertAlignBaseOpt = Base
textVertAlignBottomOpt = Fond
textVertAlignCenterOpt = Centre
textVertAlignTopOpt = Sommet
#
# base/VhdlContent.java
#
# ==> validationErrorButton = 
# ==> validationParseError = 
# ==> vhdlDuplicateNameError = 
# ==> vhdlInvalidNameError = 
# ==> vhdlKeywordNameError = 
#
# base/VhdlParser.java
#
# ==> CannotFindEntityException = 
# ==> emptySourceException = 
# ==> genericDeclarationException = 
# ==> genericTypeException = 
# ==> genericValueException = 
# ==> invalidTypeException = 
# ==> portDeclarationException = 
#
# Builtin.java
#
builtinLibrary = inclue
#
# gates/AndGate.java
#
andGateComponent = Porte AND
#
# gates/Buffer.java
#
bufferComponent = Buffer
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Buffer controll\u00e9
controlledControlOption = Position de la commande
controlledInverterComponent = Inverseur controll\u00e9
controlledLeftHanded = A gauche
controlledRightHanded = A droite
#
# gates/EvenParityGate.java
#
evenParityComponent = Parit\u00e9 paire
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/flottant
gateOutputAttr = Valeur de sortie
gateOutputZ1 = flottant/1
gateSizeNormalOpt = moyen
xorBehaviorAttr = Comportement multi-entr\u00e9es
xorBehaviorOdd = Quand un nombre impaire est Haut
xorBehaviorOne = Quand une entr\u00e9e est Haut
#
# gates/Gates.java
#
gatesLibrary = Portes logiques
#
# gates/NandGate.java
#
nandGateComponent = Porte NAND
#
# gates/NegateAttribute.java
#
gateNegateAttr = Inverseur %s
#
# gates/NorGate.java
#
norGateComponent = Porte NOR
#
# gates/NotGate.java
#
gateSizeAttr = Dimension dessins
gateSizeNarrowOpt = \u00e9troit
gateSizeWideOpt = large
notGateComponent = Porte NOT
#
# gates/OddParityGate.java
#
oddParityComponent = Parit\u00e9 impaire
#
# gates/OrGate.java
#
orGateComponent = Porte OR
#
# gates/PLA.java
#
# ==> Bit Width In = 
# ==> Bit Width Out = 
# ==> input = 
# ==> output = 
# ==> PLA = 
plaClickToEdit = (cliquez pour \u00e9diter)
plaEditMenuItem = Editer le programme PLA ...
plaProgram = Programme
#
# gates/PLATable.java
#
plaEditorTitle = Editeur de programme PLA
plaFileCreateError = Impossible de cr\u00e9er le fichier.
plaFileOpenError = Impossible d'ouvrir le fichier.
plaLoadDialogTitle = Charger le programme PLA
plaLoadErrorTitle = Erreur de chargement du programme PLA
plaSaveDialogTitle = Sauvegarder le programme PLA
plaSaveErrorTitle = Erreur d'enregistrement du programme PLA
#
# gates/XnorGate.java
#
xnorGateComponent = Porte XNOR
#
# gates/XorGate.java
#
xorGateComponent = Porte XOR
#
# InstanceComponent.java
#
KeywordNameError = Label est un mot cl\u00e9 r\u00e9serv\u00e9 et ne peut pas \u00eatre utilis\u00e9. Veuillez sp\u00e9cifier une \u00e9tiquette diff\u00e9rente.
MatchedLabelNameError = L'\u00e9tiquette et le nom composant ne peuvent pas \u00eatre les m\u00eames (ils ne sont pas sensibles \u00e0 la casse). Veuillez sp\u00e9cifier une \u00e9tiquette diff\u00e9rente du nom du composant.
#
# InstanceTextField.java
#
changeLabelAction = Changer le Label
#
# io/Button.java
#
buttonComponent = Bouton
#
# io/DipSwitch.java
#
# ==> DIP = 
# ==> DipSwitchComponent = 
nrOfSwitch = Nbr. commutateur
#
# io/DotMatrix.java
#
ioInputColumn = Colonnes
ioInputRow = Lignes
ioInputSelect = Selectionner ligne/colonne
ioMatrixCols = Colonne de la matrice
ioMatrixInput = Format de l'entr\u00e9e
ioMatrixPersistenceAttr = Persistence lumineuse
ioMatrixRows = Ligne de la matrice
ioMatrixShape = Forme d'un point
ioShapeCircle = Circulaire
ioShapeSquare = Carr\u00e9
#
# io/extra/Buzzer.java
#
# ==> buzzerComponent = 
# ==> buzzerFrequecy = 
# ==> buzzerVolume = 
# ==> buzzerVolumeBitWidth = 
# ==> dHz (0.1Hz) = 
# ==> enableSound = 
# ==> Hz = 
#
# io/extra/DigitalOscilloscope.java
#
# ==> BorderColor = 
# ==> bothOption = 
# ==> ClearDiagram = 
# ==> DigitalOscilloscopeClock = 
# ==> DrawClockFrontLine = 
# ==> noOption = 
# ==> ShowClockAttribute = 
stdTriggerFalling = Flanc descendant
stdTriggerRising = Flanc Montant
#
# io/extra/ITA_IO.java
#
# ==> DigitalOscilloscopeComponent = 
# ==> Slider = 
#
# io/extra/PlaRom.java
#
memCSTip = Chip select: 0 d\u00e9sactive le composant
# ==> PlaANDAttr = 
# ==> PlaOutputsAttr = 
# ==> PlaRomComponent = 
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
# ==> Logisim: Pla Rom  = 
#
# io/extra/PlaRomPanel.java
#
demultiplexerInTip = Entr\u00e9e
multiplexerOutTip = Sortie
#
# io/extra/ProgrammableGenerator.java
#
# ==> NStateAttr = 
#
# io/extra/ProgrammableGeneratorState.java
#
# ==> ProgrammableGeneratorComponent = 
#
# io/extra/Slider.java
#
# ==> left_to_rightOption = 
# ==> right_to_leftOption = 
#
# io/extra/Switch.java
#
# ==> switchComponent = 
#
# io/HexDigit.java
#
hexDigitDataTip = Donn\u00e9es: nibble \u00e0 afficher en hexad\u00e9cimal
hexDigitDPTip = DecimalPoint: allume le point d\u00e9cimal
#
# io/HexDigitShape.java
#
hexDigitComponent = Afficheur Hexad\u00e9cimal
#
# io/Io.java
#
dipswitchComponent = Dip switch
dotMatrixComponent = Matrice de LED
ioActiveAttr = Actif si haut?
ioBackgroundColor = Fond (background)
ioColorAttr = Couleur
ioLibrary = Entr\u00e9e/Sortie
ioOffColor = Off Color
ioOnColor = On Color
joystickComponent = Joystick
#
# io/Joystick.java
#
ioBitWidthAttr = Largeur donn\u00e9es
#
# io/Keyboard.java
#
keybAvailTip = Disponible: 1 quand le tampon contient des caract\u00e8res
keybBufferLengthAttr = Longueur du Buffer
keybClearTip = Clear: 1 efface le buffer
keybClockTip = Horloge: trigger consomme le premier caract\u00e8re du buffer
keybDesc = Clavier (buffer cap. %s)
keybEnableTip = Read activ\u00e9: 0 d\u00e9sactive l'horloge
keyboardComponent = Clavier
keybOutputTip = Donn\u00e9es: Valeur ASCII du premier caract\u00e8re du tampon
#
# io/Led.java
#
ledComponent = LED
#
# io/PortIO.java
#
pioBuses = Un ou plusieurs bus
pioComponent = Port I/O
pioNumber = Nombre de contacte
pioPins = Pin Simple
pioShowBus = Type de connexion ?
#
# io/ReptarLocalBus.java
#
repLBComponent = Reptar Local Bus
# ==> repLBTip = 
#
# io/RGBLed.java
#
BLUE = Entr\u00e9e bleu
GREEN = Entr\u00e9e verte
RED = Enr\u00e9e rouge
RGBledComponent = LED RVB
#
# io/SevenSegment.java
#
# ==> DecimalPoint = 
# ==> Segment_A = 
# ==> Segment_B = 
# ==> Segment_C = 
# ==> Segment_D = 
# ==> Segment_E = 
# ==> Segment_F = 
# ==> Segment_G = 
sevenSegmentComponent = Afficheur 7-Segment
#
# io/Tty.java
#
ttyClearTip = Effacer: 1 efface l'\u00e9cran
ttyClockTip = Horloge: trigger ajoute le caract\u00e8re en entr\u00e9e
ttyColsAttr = Colonnes
ttyComponent = TTY
ttyDesc = TTY (%s lignes, %s colonnes)
ttyDescShort = TTY
ttyEnableTip = Active l'\u00e9criture: 0 d\u00e9sactive l'horloge
ttyInputTip = Donn\u00e9es: valeur ASCII du prochain character \u00e0 \u00e9crire
ttyRowsAttr = Lignes
#
# io/Video.java
#
rgbVideoCLK = Horloge
rgbVideoColor = Mod\u00e8le de couleur
rgbVideoComponent = Video RVB
rgbVideoCursor = Curseur
rgbVideoData = Data dans le format %s
rgbVideoHeight = hauteur
rgbVideoReset = R\u00e9initialiser le comportement
rgbVideoRST = R\u00e9initialiser
rgbVideoScale = \u00c9chelle
rgbVideoWE = Ecriture autoris\u00e9e
rgbVideoWidth = Largeur
rgbVideoX = Coordon\u00e9e X
rgbVideoY = Coordon\u00e9e Y
#
# library/bcd2sevenseg.java
#
# ==> BCD Value = 
# ==> BCD2SevenSegment = 
#
# library/BFHPraktika.java
#
# ==> BFH mega functions = 
#
# library/bin2bcd.java
#
# ==> Bin2BCD = 
# ==> Binairy data bits = 
# ==> BinairyInputTip = 
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Horloge: l'\u00e9tat impact sur le trigger
flipFlopNotQTip = Compl\u00e9ment \u00e0 l'\u00e9tat courrant du flip-flop
flipFlopPresetTip = Preset: si 1, l'\u00e9tat du pin \u00e0 1 de mani\u00e8re asynchrone
flipFlopQTip = Etat courrant du flip-flop
flipFlopResetTip = Clear: si 1, l'\u00e9tat du pin \u00e0 0 de mani\u00e8re asynchrone
#
# memory/Counter.java
#
counterCarryTip = Carry: est \u00e0 1 si la valeur atteinte le maximum (minimum si d\u00e9cr\u00e9mente)
counterClockTip = Horloge: la valeur peut modifier le trigger
counterDataTip = Data: valeur \u00e0 charger dans le compteur
counterEnableLabel = ct
counterEnableTip = Count: si 1, le compteur s'incr\u00e9mente (ou d\u00e9cr\u00e9mente si Load
counterGoalAttr = Action en cas de d\u00e9passement
counterGoalContinue = Continue le compte
counterGoalLoad = Charger la valeur suivante
counterGoalStay = Rester \u00e0 la valeur
counterGoalWrap = Entourer
counterLabel = ctr
counterLoadTip = Load: si 1, charge \u00e0 partir des donn\u00e9es entr\u00e9es (if Count
counterMaxAttr = Valeur max
counterQTip = Sortie: valeur courrant du compteur
counterResetTip = Clear: si 1, remet \u00e0 0 de mani\u00e8re asynchrone
counterUpDownTip = UpDown: Si 1 Incr\u00e9mente, Si 0, d\u00e9cremente
registerWidthLabel = (%sb)
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
# ==> ByteLabel = 
# ==> GigabyteLabel = 
# ==> KilobyteLabel = 
# ==> MegabyteLabel = 
ramAddrLabel = A
ramAddrWidthAttr = Largeur d'adresse
ramDataWidthAttr = Largeur donn\u00e9es
# ==> ramSelAttr = 
stdTriggerHigh = Niveau haut
stdTriggerLow = Niveau bas
#
# memory/MemMenu.java
#
ramClearMenuItem = Effacer les contenus
ramConfirmClearMsg = Etes vous s\u00fbr de vouloir remettre \u00e0 z\u00e9ro la sortie m\u00e9moire?
ramConfirmClearTitle = Confirmer l'\u00e9ffacement
ramEditMenuItem = Editer le contenu...
ramLoadDialogTitle = Charge une image RAM
ramLoadErrorTitle = Erreur de chargement
ramLoadMenuItem = Charger l'image...
ramSaveDialogTitle = Sauvegarder une image RAM
ramSaveErrorTitle = Erreur de sauvegarde
ramSaveMenuItem = Sauvegarder l'image...
#
# memory/Memory.java
#
counterComponent = Compteur
dFlipFlopComponent = D Flip-Flop
memoryLibrary = M\u00e9moire / S\u00e9quenciel
ramComponent = RAM
randomComponent = G\u00e9n\u00e9rateur al\u00e9atoire
registerComponent = Registre
#
# memory/Ram.java
#
ramBusTip = Data: valeur charg\u00e9 ou stock\u00e9e \u00e0 l'adresse
ramClkTip = Clock: la valeur en m\u00e9moire change sur flanc de 0 \u00e0 1
ramContentsAttr = Contenu Initial
ramDataLabel = D
ramInTip = Input: valeur \u00e0 charger \u00e0 l'adresse
ramOELabel = ld
ramOETip = Load: si 1, charge la m\u00e9moire sur la sortie
ramWELabel = str
ramWETip = Store: si 1, stock l'entr\u00e9e dans la m\u00e9moire
#
# memory/RamAttributes.java
#
ramBidirDataBus = bidirectionnel
ramByteEnables = Contr\u00f4le lecture/\u00e9criture
ramDataAttr = Type de bus donn\u00e9es
ramNoByteEnables = Mot entier en lecture/\u00e9criture seulement
ramSeparateDataBus = monodirectionnel deux bus lire/\u00e9crire
ramWithByteEnables = Use byte enables
#
# memory/Random.java
#
randomClockTip = Clock: la valeur peut changer avec le trigger
# ==> randomLabel = 
randomNextTip = Enable: avance au suivant dans la s\u00e9quence avec le trigger d'horloge
randomQTip = Sortie: nombre courrant dans la s\u00e9quence
randomResetTip = Clear: si 1, initialise \u00e0 la semence de mani\u00e8re asynchrone
randomSeedAttr = Semence
# ==> randomWidthLabel = 
#
# memory/Register.java
#
registerClkTip = Clock: la valeur change avec le trigger
registerClrTip = Clear: si 1, la valeur du pin mise \u00e0 0 de mani\u00e8re asynchrone
registerDTip = Data: valeur stock\u00e9e dans l'horloge du trigger
registerEnableTip = Enable: si 0, les trigger d'horloge sont inop\u00e9rants
registerLabel = reg
registerQTip = Sortie: valeur courrant du registre
registerShowInTab = Show in Registers Tab
#
# memory/Rom.java
#
memAddrTip = Address: emplacement acc\u00e9d\u00e9 en m\u00e9moire
memDataTip = Data: valeur charg\u00e9e depuis une adresse
romComponent = ROM
romContentsAttr = Contenu
romContentsValue = (click pour \u00e9diter)
#
# memory/RomContentsListener.java
#
romChangeAction = Editer le contenu de la ROM
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Clear: quand 1, remise \u00e0 z\u00e9ro compl\u00e8te et asynchrone
shiftRegClockTip = Clock: les valeurs peuvent changer avec le trigger
shiftRegInTip = Input: valeur \u00e0 d\u00e9caler dans le premier \u00e9tage
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Nombre d'\u00e9tages
shiftRegLoadTip = Load: quand 1 (avec shift
shiftRegOutTip = Output: est le contenu du dernier \u00e9tage
shiftRegParallelAttr = Chargement parall\u00e8le
shiftRegShiftTip = Shift: d\u00e9calage d\u00e9sactiv\u00e9 quand 0
#
# memory/ShiftRegisterLogger.java
#
shiftRegisterComponent = Registre \u00e0 d\u00e9calage
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# memory/TFlipFlop.java
#
tFlipFlopComponent = T Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorDataTip = Data
bitSelectorGroupAttr = Bits en sortie
bitSelectorOutputTip = Sortie: valeur du groupe de bits s\u00e9lectionn\u00e9s dans data
bitSelectorSelectTip = Select: identifie quel groupe de donn\u00e9es est s\u00e9lectionn\u00e9
#
# plexers/Decoder.java
#
decoderComponent = Decodeur
decoderEnableTip = Enable: si non 0, la sortie s\u00e9lectionn\u00e9e est \u00e0 1
decoderOutTip = Sortie %s
decoderSelectTip = Select: identifie quelle sortie est \u00e0 1
#
# plexers/Demultiplexer.java
#
demultiplexerComponent = Demultiplexeur
demultiplexerEnableTip = Enable: si non 0, la sortie s\u00e9lectionn\u00e9e et l'entr\u00e9e
demultiplexerSelectTip = Select: identifie quelle sortie re\u00e7oit l'entr\u00e9e
#
# plexers/Multiplexer.java
#
multiplexerComponent = Multiplexeur
multiplexerEnableTip = Enable: si non 0, la sortie est l'entr\u00e9e s\u00e9lectionn\u00e9e
multiplexerSelectTip = Select: identifie l'entr\u00e9e qui devient la sortie
#
# plexers/Plexers.java
#
bitSelectorComponent = S\u00e9lecteur de Bit
plexerDisabledAttr = D\u00e9sactiv\u00e9 les sorties
plexerDisabledFloating = Flottant
plexerDisabledZero = Zero
plexerEnableAttr = Inclure l'activation ?
plexerLibrary = De/Multiplexeurs,Encodeurs
plexerSelectBitsAttr = Select Bits
plexerSelectBottomLeftOption = Fond/Gauche
plexerSelectLocAttr = Selectionner l'emplacement
plexerSelectTopRightOption = Haut/Droite
plexerThreeStateAttr = Trois \u00e9tats?
#
# plexers/PriorityEncoder.java
#
priorityEncoderComponent = Encodeur prioritaire
priorityEncoderEnableOutTip = Activer la sortie: 1 si activ\u00e9 et aucune entr\u00e9e est \u00e0 1
priorityEncoderGroupSignalTip = Group Select: 1 si activ\u00e9 et n'importe quelle entr\u00e9e est \u00e0 1
priorityEncoderInTip = Entr\u00e9e %s
priorityEncoderOutTip = Sortie: adresse du 1 avec le plus haut indexe
#
# StdAttr.java
#
ioLabelColorAttr = Couleur du label
stdClassicAppearance = Logisim classique
stdDataWidthAttr = Largeur donn\u00e9es
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Orientation
stdLabelAttr = Label
stdLabelCenter = Centre
stdLabelFontAttr = Police du Label
stdLabelLocAttr = Emplacement de l'\u00e9tiquette
stdLabelVisibility = \u00c9tiquette visible
stdLogisimEvolutionAppearance = Logisim-Evolution
stdTriggerAttr = Trigger
#
# tcl/Tcl.java
#
tclGeneric = TCL generic
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = TCL content file
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = TCL REDS console
#
# tcl/TclGeneric.java
#
tclInterfaceDefinition = TCL interface VHDL entity
tclInterfaceDefinitionValue = (click pour \u00e9diter)
#
# ttl/AbstractTtlGate.java
#
demultiplexerOutTip = Sortie %s
# ==> GND:  = 
multiplexerInTip = Entr\u00e9e %s
# ==> Vcc:  = 
#
# ttl/DisplayDecoder.java
#
# ==> BI = 
# ==> BlankingInputInTip = 
# ==> DisplayDecoderComponent = 
# ==> DisplayDecoderInTip = 
# ==> DisplayDecoderOutTip = 
# ==> ioMultiBit = 
# ==> LampTestInTip = 
# ==> LT = 
memEnableLabel = en
priorityEncoderEnableInTip = Activer l'entr\u00e9e: 0 d\u00e9sactive le composant
# ==> RBI = 
# ==> RippleBlankingInputInTip = 
#
# ttl/TTL.java
#
ShowInternalStructure = Montrer la structure interne
TTL7400 = 7400: Quatre NAND 2 entr\u00e9es
TTL7402 = 7402: Quatre NOR 2 entr\u00e9es
TTL7404 = 7404: SIx inverseurs
TTL7408 = 7408: Quatre AND 2 entr\u00e9es
TTL7410 = 7410: Trois NAND 3 entr\u00e9es
TTL7411 = 7411: Trois AND 3 entr\u00e9es
TTL74125 = 74125: Quatre buffers de bus, sortie trois \u00e9tat, Activation niveau bas
TTL7413 = 7413: Double NAND 4 entr\u00e9es (schmitt-trigger)
TTL7414 = 7414: Six inverseurs (schmitt-trigger)
TTL74165 = 74165: Registre \u00e0 d\u00e9calage 8-bit
TTL74175 = 74175: Quatre D-flipflop, Reset Asynchrone
TTL7418 = 7418: Double NAND 4 entr\u00e9es (schmitt-trigger)
TTL7419 = 7419: SIx inverseurs (schmitt-trigger)
TTL7420 = 7420: Deux NAND 4 entr\u00e9es
TTL7421 = 7421: Deux AND 4 entr\u00e9es
TTL7424 = 7424: Quatre NAND 2 entr\u00e9es (schmitt-trigger)
TTL74266 = 74266: Quatre XNOR deux entr\u00e9es
TTL7427 = 7427: Trois NOR 3 entr\u00e9es
TTL74273 = 74273: Huit D-Flipflop avec reset
TTL74283 = 74283: Additionneur complet 4-bits, binaire
TTL7430 = 7430: NAND 8 entr\u00e9e
TTL7432 = 7432: Quatre OR  2 entr\u00e9es
TTL7436 = 7436: Quatre NOR 2 entr\u00e9es
TTL74377 = 74377: Huit D-Flipflop avec autorisation
TTL7442 = 7442: D\u00e9codeur BCD vers decimal
TTL7443 = 7443: D\u00e9codeur Excess-3 vers decimal
TTL7444 = 7444: D\u00e9codeur Gray vers decimal
TTL7447 = 7447: D\u00f6coduer BCD vers 7-segments
TTL7451 = 7451: Double AND-OR-INVERT
TTL7454 = 7454: Quatre wide AND-OR-INVERT
TTL7458 = 7458: Double AND-OR
TTL7464 = 7464: 4-2-3-2 AND-OR-INVERT
TTL7474 = 7474: Double D-Flipflops avec preset et reset
TTL7485 = 7485: Comparateur de magnitude 4-bit
TTL7486 = 7486: Quatre XOR 2 entr\u00e9es
VccGndPorts = Activer les ports Vcc et Gnd
#
# wiring/BitExtender.java
#
extenderComponent = Extension de bit
extenderInAttr = Largeur bus entr\u00e9e
extenderInputLabel = entr\u00e9e
extenderInputType = Entr\u00e9e
extenderMainLabel = \u00e9tendre
extenderOneLabel = 1
extenderOneType = Un
extenderOutAttr = Largeur bus sortie
extenderSignLabel = sign\u00e9
extenderSignType = Signe
extenderTypeAttr = Type d'Extension
extenderZeroLabel = 0
extenderZeroType = Z\u00e9ro
#
# wiring/Clock.java
#
clockComponent = Horloge
clockHighAttr = Dur\u00e9e haute
clockLowAttr = Dur\u00e9e basse
#
# wiring/Constant.java
#
constantComponent = Constante
constantValueAttr = Valeur
#
# wiring/DoNotConnect.java
#
noConnectionComponent = Ne connectez pas
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 Tic
clockDurationValue = %s Tics
durationLargeMessage = La valeur doit \u00eatre %s ou moins.
durationSmallMessage = La valeur doit \u00eatre au moins %s.
freqInvalidMessage = La valeur n'est pas un entier valide
PORDurationOneValue = 1 Sec
PORDurationValue = %s Secs
#
# wiring/Ground.java
#
groundComponent = Masse
#
# wiring/Pin.java
#
PinCancel = Annuler
pinComponent = Pin
PinEnterDecimal = Entrer d\u00e9cimal
pinFrozenQuestion = Le pin est li\u00e9 \u00e0 l'\u00e9tat du supercircuit. Cr\u00e9er un nouvel \u00e9tat pour le circuit?
pinFrozenTitle = Pin attach\u00e9 au super-circuit.
pinInputName = Entr\u00e9e
pinInputToolTip = Ajouter un pin d'entr\u00e9e
PinOkay = OK
pinOutputAttr = Sortie?
pinOutputName = Sortie
pinOutputToolTip = Ajouter un pin de sortie
pinPullAttr = Comportement Pull
pinPullDownOption = Pull Down
pinPullNoneOption = Inchang\u00e9
pinPullUpOption = Pull Up
pinThreeStateAttr = Trois \u00e9tats?
#
# wiring/PowerOnReset.java
#
porHighAttr = Temps reset
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Sonde
#
# wiring/ProbeAttributes.java
#
probeNewPin = Formes de fl\u00e8che
stdAppearanceAttr = Apparence
#
# wiring/PullResistor.java
#
pullComponent = R\u00e9sistance de charge
pullErrorType = Erreur
pullOneType = Un
pullTypeAttr = DIrection charge
pullZeroType = Z\u00e9ro
#
# wiring/Transistor.java
#
transistorComponent = Transistor
transistorNDrain = drain: une source bas tirera le drain sur bas (uniquement lorsque la porte est haute)
transistorNGate = gate: \u00e0 l'\u00e9tat haut, laisse passer le courant dans le transistor
transistorNSource = source: une source bas tirera le drain sur bas (seulement lorsque la porte est haute)
transistorPDrain = drain: une source haut tirera le drain haut (uniquement lorsque la porte est bas)
transistorPGate = gate: au niveau bas, laisse passer le courant \u00e0 travers le transistor
transistorPSource = source: une source haut tirera le drain vers haut (uniquement lorsque la porte est bas)
transistorTypeAttr = Type
transistorTypeN = N-Type
transistorTypeP = P-Type
#
# wiring/TransmissionGate.java
#
transmissionGateComponent = Porte de transmission
transmissionGateDrain = drain: contr\u00f4l\u00e9 par la source, en fonction du type de porte p ou n
transmissionGateNGate = n-gate: au niveau bas, laisse passer la source bas vers drain
transmissionGatePGate = p-gate: au niveau haut, laisse passer la source haut vers drain
transmissionGateSource = source: Contr\u00f4l le drain, en fonction du type de porte p ou n
#
# wiring/Tunnel.java
#
tunnelComponent = Tunnel
#
# wiring/Wiring.java
#
powerComponent = Alimentation
wiringGateAttr = Position de la Gate
wiringGateBottomRightOption = Bas/Droite
wiringGateTopLeftOption = Haut/Gauche
wiringLibrary = C\u00e2blage
