#
# arith/Adder.java
#
adderCarryInTip = Retenue en entrée: si 1, 1 de plus est ajouté à la sortie
adderCarryOutTip = Retenue en sortie: 1 si la somme dépasse le nombre de bits disponibles
adderComponent = Additionneur
adderInputTip = Entrée: un des nombres à additionner
adderOutputTip = Sortie: la somme des entrée (plus la retenue en entrée)
#
# arith/Arithmetic.java
#
arithmeticLibrary = Arithmétique
#
# arith/BitAdder.java
#
bitAdderComponent = Additionneur bit à bit
bitAdderInputTip = Entrée: les bits à compter
bitAdderOutputManyTip = Sortie: combien de bits sont à 1
gateInputsAttr = Nombre d'entrées
#
# arith/BitFinder.java
#
bitFinderComponent = Recherche de bits
bitFinderFindLabel = trouver
bitFinderHighLabel = haut
bitFinderHighOption = Ordre le plus haut %s
bitFinderIndexHighTip = Index: index de l'entrée avec l'ordre le plus haut %s
bitFinderIndexLowTip = Index: index de l'entrée avec l'ordre le plus bas %s
bitFinderInputTip = Entrée: les bits à rechercher
bitFinderLowLabel = bas
bitFinderLowOption = Ordre le plus bas %s
bitFinderPresentTip = Présence: 1 si l'entrée contien un %s
bitFinderTypeAttr = Type
#
# arith/Comparator.java
#
comparatorComponent = Comparateur
comparatorEqualTip = Equal: 1 si A est égal à B
comparatorGreaterTip = Greater: 1 si A est plus grand que B
comparatorInputATip = A: membre de gauche de l'opération
comparatorInputBTip = B: membre de droite de l'opération
comparatorLessTip = Less: 1 si A est plus petit que B
comparatorType = Type numérique
twosComplementOption = complément à 2
unsignedOption = Non signé
#
# arith/Divider.java
#
dividerComponent = Diviseur
dividerDividendLowerTip = numérateur bas: la moitié basse du nombre à diviser
dividerDividendUpperTip = numérateur haut: la moitié haute du nombre à diviser
dividerDivisorTip = Diviseur: dénominateur par lequel diviser
dividerOutputTip = Sortie: le résultat de la division du numérateur par le dénominateur
dividerRemainderOutput = reste
dividerRemainderTip = Reste: (numérateur - sortie * diviseur)
dividerUpperInput = numérateur
#
# arith/Multiplier.java
#
multiplierCarryInTip = Retenue en entrée: une valeur à ajouter à la sortie
multiplierCarryOutTip = Retenue en sortie: le bit de poids le plus fort du produit
multiplierComponent = Multiplicateur
multiplierInputTip = Entrée: l'un des nombres à multiplier
multiplierOutputTip = Output: le produit des entrées plus la retenue en entrée
#
# arith/Negator.java
#
negatorComponent = Inverseur
negatorInputTip = Entrée: le nombre à inverser
negatorOutputTip = Sortie: le complémen à deux de l'inversion de l'entrée
#
# arith/Shifter.java
#
shiftArithmeticRight = Arithmétique à droite
shifterComponent = Décalage
shifterDistanceTip = Distance: combien de décalage sur l'entrée
shifterInputTip = Entrée: les bits à décaler
shifterOutputTip = Sortie: résultat du décalage de l'entrée
shifterShiftAttr = Type de décalage
shiftLogicalLeft = Logique à gauche
shiftLogicalRight = Logique à droite
shiftRollLeft = Rotation à gauche
shiftRollRight = Rotation à droite
#
# arith/Subtractor.java
#
subtractorBorrowInTip = Emprunt en entrée: si 1 la sortie est dminuée de 1
subtractorBorrowOutTip = Emprunt en sortie: 1 si la différence est négative
subtractorComponent = Soustracteur
subtractorMinuendTip = Diminué: le nombre dont on soustrait
subtractorOutputTip = Sortie: la différence entre le diminué et le soustrait
subtractorSubtrahendTip = Soustrait: le nombre à soustraire du diminué
#
# base/Base.java
#
baseLibrary = Base
#
# base/Text.java
#
textComponent = Label
textFontAttr = Police
textHorzAlignAttr = Alignement horizontal
textHorzAlignCenterOpt = Centré
textHorzAlignLeftOpt = Gauche
textHorzAlignRightOpt = Droite
textTextAttr = Texte
textVertAlignAttr = Alignment vertical
textVertAlignBaseOpt = Base
textVertAlignBottomOpt = Fond
textVertAlignCenterOpt = Centre
textVertAlignTopOpt = Sommet
#
# base/VhdlParser.java
#
CannotFindEntityException = La déclaration d'entité ne peut pas être trouvée
emptySourceException = Impossible d'analyser le contenu vide
genericDeclarationException = Syntaxe illégale des génériques
genericTypeException = Type de médicaments génériques non pris en charge
genericValueException = Valeur par défaut des génériques non reconnus
invalidTypeException = Type de port non valide
portDeclarationException = Syntaxe de port illégale
#
# Builtin.java
#
builtinLibrary = inclue
#
# gates/AndGate.java
#
andGateComponent = Porte AND
#
# gates/Buffer.java
#
bufferComponent = Buffer
#
# gates/ControlledBuffer.java
#
controlledBufferComponent = Buffer controllé
controlledControlOption = Position de la commande
controlledInverterComponent = Inverseur controllé
controlledLeftHanded = A gauche
controlledRightHanded = A droite
#
# gates/EvenParityGate.java
#
evenParityComponent = Parité paire
#
# gates/GateAttributes.java
#
gateOutput01 = 0/1
gateOutput0Z = 0/flottant
gateOutputAttr = Valeur de sortie
gateOutputZ1 = flottant/1
gateSizeNormalOpt = moyen
xorBehaviorAttr = Comportement multi-entrées
xorBehaviorOdd = Quand un nombre impaire est Haut
xorBehaviorOne = Quand une entrée est Haut
#
# gates/Gates.java
#
gatesLibrary = Portes logiques
#
# gates/NandGate.java
#
nandGateComponent = Porte NAND
#
# gates/NegateAttribute.java
#
gateNegateAttr = Inverseur %s
#
# gates/NorGate.java
#
norGateComponent = Porte NOR
#
# gates/NotGate.java
#
notGateComponent = Porte NOT
#
# gates/OddParityGate.java
#
oddParityComponent = Parité impaire
#
# gates/OrGate.java
#
orGateComponent = Porte OR
#
# gates/PLA.java
#
Bit Width In = Largeur du foret en
Bit Width Out = Largeur du panneton vers l'extérieur
input = contribution
output = rendement
PLA = PLA
plaClickToEdit = (cliquez pour éditer)
plaEditMenuItem = Editer le programme PLA ...
plaProgram = Programme
#
# gates/PLATable.java
#
plaEditorTitle = Editeur de programme PLA
plaFileCreateError = Impossible de créer le fichier.
plaFileOpenError = Impossible d'ouvrir le fichier.
plaLoadDialogTitle = Charger le programme PLA
plaLoadErrorTitle = Erreur de chargement du programme PLA
plaSaveDialogTitle = Sauvegarder le programme PLA
plaSaveErrorTitle = Erreur d'enregistrement du programme PLA
#
# gates/XnorGate.java
#
xnorGateComponent = Porte XNOR
#
# gates/XorGate.java
#
xorGateComponent = Porte XOR
#
# InstanceComponent.java
#
KeywordNameError = Label est un mot clé réservé et ne peut pas être utilisé. Veuillez spécifier une étiquette différente.
MatchedLabelNameError = L'étiquette et le nom composant ne peuvent pas être les mêmes (ils ne sont pas sensibles à la casse). Veuillez spécifier une étiquette différente du nom du composant.
#
# InstanceTextField.java
#
changeLabelAction = Changer le Label
#
# io/DipSwitch.java
#
DIP = DIP
DipSwitchComponent = Interrupteur DIP
nrOfSwitch = Nbr. commutateur
#
# io/DotMatrix.java
#
ioInputColumn = Colonnes
ioInputRow = Lignes
ioInputSelect = Selectionner ligne/colonne
ioMatrixCols = Colonne de la matrice
ioMatrixInput = Format de l'entrée
ioMatrixPersistenceAttr = Persistence lumineuse
ioMatrixRows = Ligne de la matrice
ioMatrixShape = Forme d'un point
ioShapeCircle = Circulaire
ioShapeSquare = Carré
#
# io/extra/Buzzer.java
#
buzzerFrequecy = fréquence
buzzerVolume = contenance
buzzerVolumeBitWidth = volume largeur de bit
dHz (0.1Hz) = dHz (0,1Hz)
enableSound = Activer le son
Hz = Hz
#
# io/extra/DigitalOscilloscope.java
#
BorderColor = Couleur de la bordure
bothOption = tous les deux
ClearDiagram = Schéma clair
DigitalOscilloscopeClock = chronométrer
DrawClockFrontLine = tracer la ligne de front de l'horloge
noOption = aucun
ShowClockAttribute = Afficher l'attribut horloge
stdTriggerFalling = Flanc descendant
stdTriggerRising = Flanc Montant
#
# io/extra/ITA_IO.java
#
buzzerComponent = Buzzer
DigitalOscilloscopeComponent = oscill. numérique
PlaRomComponent = PLA Rom
Slider = glissière
switchComponent = Int a bascule
#
# io/extra/PlaRom.java
#
memCSTip = Chip select: 0 désactive le composant
PlaANDAttr = Et
PlaOutputsAttr = Sortie
ramCSLabel = sel
#
# io/extra/PlaRomData.java
#
PlaEditWindowTitel = Fenêtre d'édition Pla Rom %s
#
# io/extra/ProgrammableGenerator.java
#
NStateAttr = Nombre d'États
ProgrammableGeneratorComponent = Générateur progressif
ramClearMenuItem = Effacer les contenus
ramEditMenuItem = Editer le contenu...
romContentsAttr = Contenu
romContentsValue = (click pour éditer)
#
# io/extra/Slider.java
#
left_to_rightOption = de gauche à droite
right_to_leftOption = de droite à gauche
#
# io/HexDigit.java
#
hexDigitDataTip = Données: nibble à afficher en hexadécimal
hexDigitDPTip = DecimalPoint: allume le point décimal
#
# io/Io.java
#
buttonComponent = Bouton
dipswitchComponent = Interrupteur DIP
dotMatrixComponent = Matrice de LED
hexDigitComponent = Afficheur Hexadécimal
ioActiveAttr = Actif si haut?
ioBackgroundColor = Couleur du fond
ioColorAttr = Couleur
ioLibrary = Entrée/Sortie
ioOffColor = Couleur Ã©teint
ioOnColor = Couleur allumÃ©
joystickComponent = Joystick
ledComponent = LED
pioComponent = Port I/O
repLBComponent = Reptar Local Bus
RGBledComponent = LED RVB
sevenSegmentComponent = Afficheur 7-Segment
ttyComponent = TTY
#
# io/Joystick.java
#
ioBitWidthAttr = Largeur données
#
# io/Keyboard.java
#
keybAvailTip = Disponible: 1 quand le tampon contient des caractères
keybBufferLengthAttr = Longueur du Buffer
keybClearTip = Clear: 1 efface le buffer
keybClockTip = Horloge: trigger consomme le premier caractère du buffer
keybDesc = Clavier (buffer cap. %s)
keybEnableTip = Read activé: 0 désactive l'horloge
keyboardComponent = Clavier
keybOutputTip = Données: Valeur ASCII du premier caractère du tampon
#
# io/PortIO.java
#
# ==> pioDirection = 
# ==> pioInput = 
# ==> pioInputs = 
# ==> pioIOMultiple = 
# ==> pioIOSingle = 
pioNumber = Nombre de contacte
# ==> pioOutEnable = 
# ==> pioOutEnables = 
# ==> pioOutput = 
# ==> pioOutputs = 
#
# io/ReptarLocalBus.java
#
repLBTip = Pointe B
#
# io/RGBLed.java
#
BLUE = Entrée bleue
GREEN = Entrée verte
RED = Entrée rouge
#
# io/SevenSegment.java
#
DecimalPoint = Point décimal
Segment_A = Segment A
Segment_B = Segment B
Segment_C = Segment C
Segment_D = Segment D
Segment_E = Segment E
Segment_F = Segment F
Segment_G = Segment G
# ==> SevenSegDP = 
#
# io/Tty.java
#
ttyClearTip = Effacer: 1 efface l'écran
ttyClockTip = Horloge: trigger ajoute le caractère en entrée
ttyColsAttr = Colonnes
ttyDesc = TTY (%s lignes, %s colonnes)
ttyDescShort = TTY
ttyEnableTip = Active l'écriture: 0 désactive l'horloge
ttyInputTip = Données: valeur ASCII du prochain character à écrire
ttyRowsAttr = Lignes
#
# io/Video.java
#
rgbVideoCLK = Horloge
rgbVideoColor = Modèle de couleur
rgbVideoComponent = Video RVB
rgbVideoCursor = Curseur
rgbVideoData = Data dans le format %s
rgbVideoHeight = hauteur
rgbVideoReset = Réinitialiser le comportement
rgbVideoRST = Réinitialiser
rgbVideoScale = Échelle
rgbVideoWE = Ecriture autorisée
rgbVideoWidth = Largeur
rgbVideoX = Coordonée X
rgbVideoY = Coordonée Y
#
# library/bcd2sevenseg.java
#
BCD Value = valeur BCD
BCD2SevenSegment = BCD à sept segments
#
# library/BFHPraktika.java
#
BFH mega functions = Méga-fonctions BFH
Bin2BCD = Binairy à BCD
#
# library/bin2bcd.java
#
Binairy data bits = Bits de données binairy
BinairyInputTip = Entrée binairy
#
# memory/AbstractFlipFlop.java
#
flipFlopClockTip = Horloge: l'état impact sur le trigger
flipFlopNotQTip = Complément à l'état courrant du flip-flop
flipFlopPresetTip = Preset: si 1, l'état du pin à 1 de manière asynchrone
flipFlopQTip = Etat courrant du flip-flop
flipFlopResetTip = Clear: si 1, l'état du pin à 0 de manière asynchrone
#
# memory/Counter.java
#
counterCarryTip = Carry: est à 1 si la valeur atteinte le maximum (minimum si décrémente)
counterClockTip = Horloge: la valeur peut modifier le trigger
counterComponent = Compteur
counterDataTip = Data: valeur à charger dans le compteur
counterEnableLabel = ct
counterEnableTip = Count: si 1, le compteur s'incrémente (ou décrémente si Load
counterGoalAttr = Action en cas de dépassement
counterGoalContinue = Continue le compte
counterGoalLoad = Charger la valeur suivante
counterGoalStay = Rester à la valeur
counterGoalWrap = Entourer
counterLabel = ctr
counterLoadTip = Load: si 1, charge à partir des données entrées (if Count
counterMaxAttr = Valeur max
counterQTip = Sortie: valeur courrant du compteur
counterResetTip = Clear: si 1, remet à 0 de manière asynchrone
counterUpDownTip = UpDown: Si 1 Incrémente, Si 0, décremente
#
# memory/JKFlipFlop.java
#
jkFlipFlopComponent = J-K Flip-Flop
#
# memory/Mem.java
#
memAsyncRead = Lecture asynchrone :
memByte = Par adressage
memDual = Double
memEnables = Activation :
memLine = Par signal (Output Enable)
memLineSize = Taille de la ligne
# ==> memMisaligned = 
memOcto = Octo
memQuad = Quad
memRaw = Lire après écrire
memReadBehav = Comportement de lecture
memSingle = Simple
memWar = Ecrire après avoir lu
ramAddrWidthAttr = Largeur d'adresse
ramDataWidthAttr = Largeur données
ramSelAttr = Sélectionnez
stdTriggerHigh = Niveau haut
stdTriggerLow = Niveau bas
#
# memory/MemMenu.java
#
ramConfirmClearMsg = Etes vous sûr de vouloir remettre à zéro la sortie mémoire?
ramConfirmClearTitle = Confirmer l'éffacement
ramLoadMenuItem = Charger l'image...
ramSaveMenuItem = Sauvegarder l'image...
#
# memory/Memory.java
#
dFlipFlopComponent = D Flip-Flop
memoryLibrary = Mémoire / Séquenciel
tFlipFlopComponent = T Flip-Flop
#
# memory/Ram.java
#
ramComponent = RAM
#
# memory/RamAppearance.java
#
memAddrTip = Address: emplacement accédé en mémoire
memDataTip = Data: valeur chargée depuis une adresse
memDataTip0 = Données : valeur chargée à partir de l'adresse 0
memDataTip1 = Données : valeur chargée à partir de l'adresse 1
memDataTip2 = Données : valeur chargée à partir de l'adresse 2
memDataTip3 = Données : valeur chargée à partir de l'adresse 3
ramByteEnableTip0 = Validation de l'octet pour l'octet 0
ramByteEnableTip1 = Validation de l'octet 1
ramByteEnableTip2 = Validation de l'octet 2
ramByteEnableTip3 = Validation de l'octet 3
ramClkTip = Clock: la valeur en mémoire change sur flanc de 0 à 1
ramClrPin = Effacer : a on met tous les emplacements de mémoire à 0
ramInTip = Input: valeur à charger à l'adresse
ramInTip0 = Entrée : valeur à mémoriser à l'adresse 0
ramInTip1 = Entrée : valeur à mémoriser à l'adresse 1
ramInTip2 = Entrée : valeur à mémoriser à l'adresse 2
ramInTip3 = Entrée : valeur à mémoriser à l'adresse 3
ramLETip0 = Validation de la ligne pour l'adresse 0
ramLETip1 = Validation de la ligne pour l'adresse 1
ramLETip2 = Validation de la ligne pour l'adresse 2
ramLETip3 = Validation de la ligne pour l'adresse 3
ramOETip = Load: si 1, charge la mémoire sur la sortie
ramWETip = Store: si 1, stock l'entrée dans la mémoire
#
# memory/RamAttributes.java
#
ramBidirDataBus = Bus bidirectionnel
ramByteEnables = Contrôle lecture/écriture
RamClearPin = Pin Clear
ramDataAttr = Type de bus données
ramNoByteEnables = Mot entier en lecture/écriture seulement
ramSeparateDataBus = deux bus monodirectionnel
ramTypeAttr = Type de RAM
ramTypeNonVolatile = non volatil
ramTypeVolatile = volatile
ramWithByteEnables = Use byte enables
#
# memory/Random.java
#
randomClockTip = Clock: la valeur peut changer avec le trigger
randomComponent = Générateur aléatoire
randomLabel = aléatoire
randomNextTip = Enable: avance au suivant dans la séquence avec le trigger d'horloge
randomQTip = Sortie: nombre courrant dans la séquence
randomResetTip = Clear: si 1, initialise à la semence de manière asynchrone
randomSeedAttr = Semence
randomWidthLabel = Largeur : %d
#
# memory/Register.java
#
registerClkTip = Clock: la valeur change avec le trigger
registerClrTip = Clear: si 1, la valeur du pin mise à 0 de manière asynchrone
registerComponent = Registre
registerDTip = Data: valeur stockée dans l'horloge du trigger
registerEnableTip = Enable: si 0, les trigger d'horloge sont inopérants
registerLabel = reg
registerQTip = Sortie: valeur courrant du registre
registerShowInTab = Show in Registers Tab
registerWidthLabel = (%sb)
#
# memory/Rom.java
#
romComponent = ROM
#
# memory/RomContentsListener.java
#
romChangeAction = Editer le contenu de la ROM
#
# memory/ShiftRegister.java
#
shiftRegClearTip = Clear: quand 1, remise à zéro complète et asynchrone
shiftRegClockTip = Clock: les valeurs peuvent changer avec le trigger
shiftRegInTip = Input: valeur à décaler dans le premier étage
shiftRegisterComponent = Registre à décalage
shiftRegisterLabel1 = shift reg
shiftRegisterLabel2 = %sx%s
shiftRegLengthAttr = Nombre d'étages
shiftRegLoadTip = Load: quand 1 (avec shift
shiftRegOutTip = Output: est le contenu du dernier étage
shiftRegParallelAttr = Chargement parallèle
shiftRegShiftTip = Shift: décalage désactivé quand 0
#
# memory/SRFlipFlop.java
#
srFlipFlopComponent = S-R Flip-Flop
#
# plexers/BitSelector.java
#
bitSelectorComponent = Sélecteur de Bit
bitSelectorDataTip = Data
bitSelectorGroupAttr = Bits en sortie
bitSelectorOutputTip = Sortie: valeur du groupe de bits sélectionnés dans data
bitSelectorSelectTip = Select: identifie quel groupe de données est sélectionné
#
# plexers/Decoder.java
#
decoderEnableTip = Enable: si non 0, la sortie sélectionnée est à 1
decoderOutTip = Sortie %s
decoderSelectTip = Select: identifie quelle sortie est à 1
#
# plexers/Demultiplexer.java
#
demultiplexerEnableTip = Enable: si non 0, la sortie sélectionnée et l'entrée
demultiplexerInTip = Entrée
demultiplexerOutTip = Sortie %s
demultiplexerSelectTip = Select: identifie quelle sortie reçoit l'entrée
#
# plexers/Multiplexer.java
#
multiplexerEnableTip = Enable: si non 0, la sortie est l'entrée sélectionnée
multiplexerInTip = Entrée %s
multiplexerOutTip = Sortie
multiplexerSelectTip = Select: identifie l'entrée qui devient la sortie
#
# plexers/Plexers.java
#
decoderComponent = Decodeur
demultiplexerComponent = Demultiplexeur
gateSizeAttr = Dimension dessins
gateSizeNarrowOpt = étroit
gateSizeWideOpt = large
multiplexerComponent = Multiplexeur
plexerDisabledAttr = Désactivé les sorties
plexerDisabledFloating = Flottant
plexerDisabledZero = Zero
plexerEnableAttr = Inclure l'activation ?
plexerLibrary = De/Multiplexeurs,Encodeurs
plexerSelectBitsAttr = Select Bits
plexerSelectBottomLeftOption = Fond/Gauche
plexerSelectLocAttr = Selectionner l'emplacement
plexerSelectTopRightOption = Haut/Droite
plexerThreeStateAttr = Trois états?
priorityEncoderComponent = Encodeur prioritaire
#
# plexers/PriorityEncoder.java
#
priorityEncoderEnableInTip = Activer l'entrée: 0 désactive le composant
priorityEncoderEnableOutTip = Activer la sortie: 1 si activé et aucune entrée est à 1
priorityEncoderGroupSignalTip = Group Select: 1 si activé et n'importe quelle entrée est à 1
priorityEncoderInTip = Entrée %s
priorityEncoderOutTip = Sortie: adresse du 1 avec le plus haut indexe
#
# StdAttr.java
#
ioLabelColorAttr = Couleur du label
stdClassicAppearance = Logisim classique
stdDataWidthAttr = Largeur données
stdEvolutionAppearance = Logisim-HolyCross
stdFacingAttr = Orientation
stdLabelAttr = Label
stdLabelCenter = Centre
stdLabelFontAttr = Police du Label
stdLabelLocAttr = Emplacement de l'étiquette
stdLabelVisibility = Étiquette visible
stdLogisimEvolutionAppearance = Logisim-Evolution
stdTriggerAttr = Trigger
#
# tcl/Tcl.java
#
tclLibrary = TCL
#
# tcl/TclComponentAttributes.java
#
tclConsoleContentFile = TCL content file
#
# tcl/TclConsoleReds.java
#
tclConsoleReds = TCL REDS console
#
# tcl/TclGeneric.java
#
tclGeneric = TCL generic
tclInterfaceDefinition = TCL interface VHDL entity
tclInterfaceDefinitionValue = (click pour éditer)
#
# ttl/AbstractTtlGate.java
#
GNDPin = Goupille de mise à la terre %s
VCCPin = VCC pin %s
#
# ttl/DisplayDecoder.java
#
BI = BI
BlankingInputInTip = Suppression
DisplayDecoderComponent = Décodeur d'affichage
DisplayDecoderInTip = Entrée
DisplayDecoderOutTip = Sortie
ioMultiBit = multi bit
LampTestInTip = Entrée test lampe
LT = LT
memEnableLabel = en
RBI = RBI
RippleBlankingInputInTip = Entrée de suppression de l'ondulation
#
# ttl/TTL.java
#
ShowInternalStructure = Afficher la structure interne
TTL7400 = 7400 : quadruple porte NAND à 2 entrées
TTL7402 = 7402 : quad porte NOR 2 entrées quadruple
TTL7404 = 7404 : onduleur hexagonal
TTL7408 = 7408 : quad 2 entrées ET porte d'entrée
TTL7410 = 7410 : triple porte NAND à 3 entrées
TTL7411 = 7411 : triple 3 entrées ET porte d'entrée
TTL74125 = 74125 : tampon quadruple bus, sorties à trois états, validation négative
TTL7413 = 7413 : double porte NAND à 4 entrées (schmitt-trigger)
TTL7414 = 7414 : onduleur hexagonal (schmitt-trigger)
TTL74165 = 74165 : registre à décalage parallèle-à-série 8 bits
TTL74175 = 74175 : bascule quadruple en D, remise à zéro asynchrone
TTL7418 = 7418 : double porte NAND à 4 entrées (schmitt-trigger)
TTL7419 = 7419 : onduleur hexagonal (schmitt-trigger)
TTL7420 = 7420 : double porte NAND 4 entrées à 4 entrées
TTL7421 = 7421 : double 4 entrées ET porte d'entrée
TTL7424 = 7424 : quad 2 entrées NAND gate (schmitt-trigger)
TTL74266 = 74266 : quad porte XNOR 2 entrées quadruple
TTL7427 = 7427 : triple porte NOR à 3 entrées NOR
TTL74273 = 74273 : bascule octale en D avec bascule transparente
TTL74283 = 74283 : Additionneur complet binaire 4 bits
TTL7430 = 7430 : porte NAND simple à 8 entrées
TTL7432 = 7432 : quad 2 entrées OU porte OU
TTL7436 = 7436 : quad 2 entrées porte NOR 2 entrées
TTL74377 = 74377 : bascule octale D-Flipflop avec validation
TTL7442 = 7442 : BCD vers décodeur décimal
TTL7443 = 7443 : Excès-3 au décodeur décimal
TTL7444 = 7444 : Code Gray vers décimal
TTL7447 = 7447 : BCD vers décodeur 7 segments
TTL7451 = 7451 : porte double AND-OR-INVERT
TTL7454 = 7454 : Quatre portes ET-OU-OU-INVERTES larges
TTL7458 = 7458 : porte double AND-OR
TTL7464 = 7464 : 4-2-3-3-2 Porte AND-OR-INVERT
TTL7474 = 7474 : double D-Flipflops avec préréglage et clair
TTL7485 = 7485 : comparateur de grandeurs 4 bits
TTL7486 = 7486 : quadruple porte XOR à 2 entrées
VccGndPorts = Activer les ports Vcc et Gnd
#
# wiring/BitExtender.java
#
extenderInAttr = Largeur bus entrée
extenderInputLabel = entrée
extenderInputType = Entrée
extenderMainLabel = étendre
extenderOneLabel = 1
extenderOneType = Un
extenderOutAttr = Largeur bus sortie
extenderSignLabel = signé
extenderSignType = Signe
extenderTypeAttr = Type d'Extension
extenderZeroLabel = 0
extenderZeroType = Zéro
#
# wiring/Clock.java
#
clockComponent = Horloge
clockHighAttr = Durée haute
clockLowAttr = Durée basse
#
# wiring/Constant.java
#
constantComponent = Constante
constantValueAttr = Valeur
#
# wiring/DurationAttribute.java
#
clockDurationOneValue = 1 Tic
clockDurationValue = %s Tics
durationLargeMessage = La valeur doit être %s ou moins.
durationSmallMessage = La valeur doit être au moins %s.
freqInvalidMessage = La valeur n'est pas un entier valide
PORDurationOneValue = 1 Sec
PORDurationValue = %s Secs
#
# wiring/Pin.java
#
PinCancel = Annuler
pinComponent = Pin
PinEnterDecimal = Entrer décimal
pinFrozenQuestion = Le pin est lié à l'état du supercircuit. Créer un nouvel état pour le circuit?
pinFrozenTitle = Pin attaché au super-circuit.
pinInputName = Entrée
pinInputToolTip = Ajouter un pin d'entrée
PinOkay = OK
pinOutputAttr = Sortie?
pinOutputName = Sortie
pinOutputToolTip = Ajouter un pin de sortie
pinPullAttr = Comportement Pull
pinPullDownOption = Pull Down
pinPullNoneOption = Inchangé
pinPullUpOption = Pull Up
pinThreeStateAttr = Trois états?
#
# wiring/PowerOnReset.java
#
porHighAttr = Temps reset
PowerOnResetComponent = POR
#
# wiring/Probe.java
#
probeComponent = Sonde
#
# wiring/ProbeAttributes.java
#
probeNewPin = Formes de flèche
stdAppearanceAttr = Apparence
#
# wiring/PullResistor.java
#
pullComponent = Résistance de charge
pullErrorType = Erreur
pullOneType = Un
pullTypeAttr = DIrection charge
pullZeroType = Zéro
#
# wiring/Transistor.java
#
transistorNDrain = drain: une source bas tirera le drain sur bas (uniquement lorsque la porte est haute)
transistorNGate = gate: à l'état haut, laisse passer le courant dans le transistor
transistorNSource = source: une source bas tirera le drain sur bas (seulement lorsque la porte est haute)
transistorPDrain = drain: une source haut tirera le drain haut (uniquement lorsque la porte est bas)
transistorPGate = gate: au niveau bas, laisse passer le courant à travers le transistor
transistorPSource = source: une source haut tirera le drain vers haut (uniquement lorsque la porte est bas)
transistorTypeAttr = Type
transistorTypeN = N-Type
transistorTypeP = P-Type
#
# wiring/TransmissionGate.java
#
transmissionGateDrain = drain: contrôlé par la source, en fonction du type de porte p ou n
transmissionGateNGate = n-gate: au niveau bas, laisse passer la source bas vers drain
transmissionGatePGate = p-gate: au niveau haut, laisse passer la source haut vers drain
transmissionGateSource = source: Contrôl le drain, en fonction du type de porte p ou n
#
# wiring/Tunnel.java
#
tunnelComponent = Tunnel
#
# wiring/Wiring.java
#
extenderComponent = Extension de bit
groundComponent = Masse
noConnectionComponent = Ne connectez pas
powerComponent = Alimentation
transistorComponent = Transistor
transmissionGateComponent = Porte de transmission
wiringGateAttr = Position de la Gate
wiringGateBottomRightOption = Bas/Droite
wiringGateTopLeftOption = Haut/Gauche
wiringLibrary = Câblage


